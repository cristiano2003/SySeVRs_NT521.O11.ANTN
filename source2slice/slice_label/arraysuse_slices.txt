1 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c [u'v_count'] 6
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int v_count [ MAX_COMPONENTS ] ; 6
memset ( v_count , 0 , sizeof ( v_count ) ); 66
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
if ( s -> bits <= 8 )  324
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
if ( ret < 0 )  4
av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ); 5
return ret ; 6
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
1
------------------------------
2 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c [u'h_count'] 5
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int h_count [ MAX_COMPONENTS ] ; 5
memset ( h_count , 0 , sizeof ( h_count ) ); 65
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
if ( s -> bits <= 8 )  324
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
if ( ret < 0 )  4
av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ); 5
return ret ; 6
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
1
------------------------------
3 /home/speedy/test/source2slice/NVD/CVE-2015-3815_VULN_logcat_log.c [u'time_buffer'] 5
static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,
gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,
const gchar *log) 3
gchar time_buffer [ 15 ] ; 5
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 24
return g_strdup_printf ( "%s.%03i %c/%s(%5i): %s\n" , time_buffer , microseconds , priority , tag , pid , log ) ; 26
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 29
return g_strdup_printf ( "%s.%03i %5i:%5i %c %s: %s\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 31
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 34
return g_strdup_printf ( "[ %s.%03i %5i:%5i %c/%s ]\n%s\n\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 36
0
------------------------------
4 /home/speedy/test/source2slice/NVD/CVE-2015-3906_VULN_logcat_log.c [u'time_buffer'] 5
static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,
gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,
const gchar *log) 3
gchar time_buffer [ 15 ] ; 5
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 24
return g_strdup_printf ( "%s.%03i %c/%s(%5i): %s\n" , time_buffer , microseconds , priority , tag , pid , log ) ; 26
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 29
return g_strdup_printf ( "%s.%03i %5i:%5i %c %s: %s\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 31
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 34
return g_strdup_printf ( "[ %s.%03i %5i:%5i %c/%s ]\n%s\n\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 36
0
------------------------------
5 /home/speedy/test/source2slice/NVD/CVE-2016-2329_VULN_tiff_decode_tag.c [u'pal_gb'] 199
static int tiff_decode_tag(TiffContext *s, AVFrame *frame) 1
unsigned tag , type , count , off , value = 0 , value2 = 0 ; 3
int ret ; 6
ret = ff_tread_tag ( & s -> gb , s -> le , & tag , & type , & count , & start ); 9
if ( ret < 0 )  10
switch ( tag )  35
GetByteContext pal_gb [ 3 ] ; 199
pal_gb [ 0 ] = pal_gb [ 1 ] = pal_gb [ 2 ] = s -> gb; 205
bytestream2_skip ( & pal_gb [ 1 ] , count / 3 * off ); 206
bytestream2_skip ( & pal_gb [ 2 ] , count / 3 * off * 2 ); 207
p |= ( ff_tget ( & pal_gb [ 0 ] , type , s -> le ) >> off ) << 16; 212
p |= ( ff_tget ( & pal_gb [ 1 ] , type , s -> le ) >> off ) << 8; 213
p |= ff_tget ( & pal_gb [ 2 ] , type , s -> le ) >> off; 214
s -> palette [ i ] = p; 215
s -> palette_is_set = 1; 217
s -> planar = value == 2; 221
av_log ( s -> avctx , AV_LOG_ERROR , "subsample count invalid\n" ); 225
for (i = 0; i < count; i++) 228
s -> subsampling [ i ] = ff_tget ( & s -> gb , type , s -> le ); 229
if ( s -> compr == TIFF_G3 )  232
s -> fax_opts = value; 233
if ( s -> compr == TIFF_G4 )  236
s -> fax_opts = value; 237
if ( ( ret = add_metadata ( count , type , name , sep , s , frame ) ) < 0 )  240
av_log ( s -> avctx , AV_LOG_ERROR , "Error allocating temporary buffer\n" ); 241
s -> geotag_count = ff_tget_short ( & s -> gb , s -> le ); 256
if ( s -> geotag_count > count / 4 - 1 )  257
s -> geotag_count = count / 4 - 1; 258
av_log ( s -> avctx , AV_LOG_WARNING , "GeoTIFF key directory buffer shorter than specified\n" ); 259
if ( bytestream2_get_bytes_left ( & s -> gb ) < s -> geotag_count * sizeof ( int16_t ) * 4 )  261
s -> geotag_count = 0; 262
s -> geotags = av_mallocz_array ( s -> geotag_count , sizeof ( TiffGeoTag ) ); 265
if ( ! s -> geotags )  266
av_log ( s -> avctx , AV_LOG_ERROR , "Error allocating temporary buffer\n" ); 267
s -> geotag_count = 0; 268
for (i = 0; i < s->geotag_count; i++) 271
s -> geotags [ i ] . key = ff_tget_short ( & s -> gb , s -> le ); 272
s -> geotags [ i ] . type = ff_tget_short ( & s -> gb , s -> le ); 273
s -> geotags [ i ] . count = ff_tget_short ( & s -> gb , s -> le ); 274
if ( ! s -> geotags [ i ] . type )  276
s -> geotags [ i ] . val = get_geokey_val ( s -> geotags [ i ] . key , ff_tget_short ( & s -> gb , s -> le ) ); 277
s -> geotags [ i ] . offset = ff_tget_short ( & s -> gb , s -> le ); 279
if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) )  285
av_log ( s -> avctx , AV_LOG_ERROR , "Error allocating temporary buffer\n" ); 289
for (i = 0; i < count; i++) 292
dp [ i ] = ff_tget_double ( & s -> gb , s -> le ); 293
for (i = 0; i < s->geotag_count; i++) 294
if ( s -> geotags [ i ] . type == TIFF_GEO_DOUBLE_PARAMS )  295
if ( s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count )  296
av_log ( s -> avctx , AV_LOG_WARNING , "Invalid GeoTIFF key %d\n" , s -> geotags [ i ] . key ); 298
char * ap = doubles2str ( & dp [ s -> geotags [ i ] . offset ] , s -> geotags [ i ] . count , ", " ) ; 300
if ( ! ap )  301
av_log ( s -> avctx , AV_LOG_ERROR , "Error allocating temporary buffer\n" ); 302
av_freep ( & dp ); 303
s -> geotags [ i ] . val = ap; 306
av_freep ( & dp ); 310
pos = bytestream2_tell ( & s -> gb ); 313
for (i = 0; i < s->geotag_count; i++) 314
if ( s -> geotags [ i ] . type == TIFF_GEO_ASCII_PARAMS )  315
if ( s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count )  316
av_log ( s -> avctx , AV_LOG_WARNING , "Invalid GeoTIFF key %d\n" , s -> geotags [ i ] . key ); 318
bytestream2_seek ( & s -> gb , pos + s -> geotags [ i ] . offset , SEEK_SET ); 322
if ( bytestream2_get_bytes_left ( & s -> gb ) < s -> geotags [ i ] . count )  323
ap = av_malloc ( s -> geotags [ i ] . count ); 325
if ( ! ap )  326
av_log ( s -> avctx , AV_LOG_ERROR , "Error allocating temporary buffer\n" ); 327
bytestream2_get_bufferu ( & s -> gb , ap , s -> geotags [ i ] . count ); 330
ap [ s -> geotags [ i ] . count - 1 ] = '\0'; 331
s -> geotags [ i ] . val = ap; 332
if ( s -> avctx -> err_recognition & AV_EF_EXPLODE )  371
av_log ( s -> avctx , AV_LOG_ERROR , "Unknown or unsupported tag %d/0X%0X\n" , tag , tag ); 372
if ( s -> bpp > 64U )  379
av_log ( s -> avctx , AV_LOG_ERROR , "This format is not supported (bpp=%d, %d components)\n" , s -> bpp , count ); 380
s -> bpp = 0; 383
1
------------------------------
6 /home/speedy/test/source2slice/NVD/CVE-2016-4082_VULN_dissect_schedule_message.c [u'other_slots'] 7
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 1
guint16 other_slots [ 48 ] ; 7
memset ( & other_slots , 0xFF , sizeof ( other_slots ) ); 44
octet1 = tvb_get_guint8 ( tvb , offset ); 67
if ( ( octet1 & 0x80 ) == 0x80 )  68
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 74
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 75
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , new_slots [ i ] , "%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 76
offset += 2; 79
other_slots [ new_slots [ i ] - 1 ] = msg_id; 80
if ( ( octet1 & 0xC0 ) == 0 )  82
if ( octet1 == 0 )  85
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Repeat of non-existant slot %d" , new_slots [ i ] , octet1 ); 87
if ( octet1 < new_slots [ i ] )  91
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 93
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 96
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 100
if ( octet1 == 0x40 )  105
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, optional reading" , new_slots [ k ] ); 108
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 110
if ( octet1 == 0x41 )  112
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, reading advised" , new_slots [ k ] ); 115
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , new_slots [ k ] , "%d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 124
proto_item_set_end ( item , tvb , offset ); 127
sched_subtree = proto_tree_add_subtree ( sched_tree , tvb , offset , 0 , ett_schedule_new_msg , & item , "Other message slots in this schedule" ); 130
for (k=0; offset < len; ) 132
while ( ( k < sched_end ) && ( other_slots [ k ] != 0xFFFF ) )  140
k ++; 142
if ( k >= sched_end )  144
octet1 = tvb_get_guint8 ( tvb , offset ); 147
if ( ( octet1 & 0x80 ) == 0x80 )  148
if ( ( offset + 1 ) < len )  150
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 156
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 157
other_slots [ k ] = msg_id; 158
k ++; 159
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , k , "%d, Message: %d, First transmission of an SMSCB within the Schedule Period" , k , msg_id ); 160
offset += 2; 163
if ( octet1 && ( ( octet1 & 0xC0 ) == 0 ) )  176
if ( octet1 < k )  179
other_slots [ k ] = other_slots [ octet1 - 1 ]; 181
k ++; 182
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Message ID: %d, Repeat of Slot %d" , k , other_slots [ octet1 - 1 ] , octet1 ); 183
k ++; 189
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Apparent forward reference to slot %d" , k , octet1 ); 190
if ( octet1 == 0x40 )  195
k ++; 198
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, optional reading" , k ); 199
if ( octet1 == 0x41 )  202
k ++; 205
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, reading advised" , k ); 206
k ++; 212
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , k , "%d reserved MDT: %x" , k , octet1 ); 213
proto_item_set_end ( item , tvb , offset ); 217
proto_tree_add_item ( sched_tree , hf_gsm_cbch_padding , tvb , offset , - 1 , ENC_NA ); 218
0
------------------------------
7 /home/speedy/test/source2slice/NVD/CVE-2016-4082_VULN_dissect_schedule_message.c [u'sched_begin', u'sched_end', u'new_slots'] 5
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 1
guint8 sched_begin , sched_end , new_slots [ 48 ] ; 5
sched_begin = octet1 & 0x3F; 25
if ( ( sched_begin < 1 ) || ( sched_begin > 48 ) )  27
sched_end = tvb_get_guint8 ( tvb , offset ); 32
if ( sched_end < sched_begin )  34
memset ( & new_slots , 0xFF , sizeof ( new_slots ) ); 43
new_slots [ k ++ ] = ( i << 3 ) + j + 1; 57
sched_subtree = proto_tree_add_subtree_format ( sched_tree , tvb , offset - 6 , 6 , ett_schedule_new_msg , & item , "This schedule contains %d slots with new messages" , k ); 62
for (i=0; i<k; i++) 64
DISSECTOR_ASSERT ( new_slots [ i ] <= 48 ); 66
octet1 = tvb_get_guint8 ( tvb , offset ); 67
if ( ( octet1 & 0x80 ) == 0x80 )  68
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 74
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 75
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , new_slots [ i ] , "%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 76
offset += 2; 79
other_slots [ new_slots [ i ] - 1 ] = msg_id; 80
if ( ( octet1 & 0xC0 ) == 0 )  82
if ( octet1 == 0 )  85
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Repeat of non-existant slot %d" , new_slots [ i ] , octet1 ); 87
if ( octet1 < new_slots [ i ] )  91
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 93
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 96
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 100
if ( octet1 == 0x40 )  105
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, optional reading" , new_slots [ k ] ); 108
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 110
if ( octet1 == 0x41 )  112
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, reading advised" , new_slots [ k ] ); 115
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , new_slots [ k ] , "%d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 124
proto_item_set_end ( item , tvb , offset ); 127
sched_subtree = proto_tree_add_subtree ( sched_tree , tvb , offset , 0 , ett_schedule_new_msg , & item , "Other message slots in this schedule" ); 130
for (k=0; offset < len; ) 132
if ( sched_end > 48 )  138
sched_end = 48; 139
while ( ( k < sched_end ) && ( other_slots [ k ] != 0xFFFF ) )  140
k ++; 142
if ( k >= sched_end )  144
octet1 = tvb_get_guint8 ( tvb , offset ); 147
if ( ( octet1 & 0x80 ) == 0x80 )  148
if ( ( offset + 1 ) < len )  150
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 156
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 157
other_slots [ k ] = msg_id; 158
k ++; 159
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , k , "%d, Message: %d, First transmission of an SMSCB within the Schedule Period" , k , msg_id ); 160
offset += 2; 163
if ( octet1 && ( ( octet1 & 0xC0 ) == 0 ) )  176
if ( octet1 < k )  179
other_slots [ k ] = other_slots [ octet1 - 1 ]; 181
k ++; 182
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Message ID: %d, Repeat of Slot %d" , k , other_slots [ octet1 - 1 ] , octet1 ); 183
k ++; 189
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Apparent forward reference to slot %d" , k , octet1 ); 190
if ( octet1 == 0x40 )  195
k ++; 198
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, optional reading" , k ); 199
if ( octet1 == 0x41 )  202
k ++; 205
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, reading advised" , k ); 206
k ++; 212
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , k , "%d reserved MDT: %x" , k , octet1 ); 213
proto_item_set_end ( item , tvb , offset ); 217
proto_tree_add_item ( sched_tree , hf_gsm_cbch_padding , tvb , offset , - 1 , ENC_NA ); 218
0
------------------------------
8 /home/speedy/test/source2slice/NVD/CVE-2016-5400_VULN_airspy_probe.c [u'buf', u'u8tmp'] 6
static int airspy_probe(struct usb_interface *intf,
const struct usb_device_id *id) 2
u8 u8tmp , buf [ BUF_SIZE ] ; 6
ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , buf , BUF_SIZE ); 28
if ( ret )  30
buf [ BUF_SIZE - 1 ] = '\0'; 35
dev_info ( s -> dev , "Board ID: %02x\n" , u8tmp ); 37
dev_info ( s -> dev , "Firmware version: %s\n" , buf ); 38
if ( ret )  49
if ( ret )  63
dev_err ( s -> dev , "Failed to register v4l2-device (%d)\n" , ret ); 64
if ( ret )  95
dev_err ( s -> dev , "Failed to register as video device (%d)\n" , ret ); 96
return ret ; 111
0
------------------------------
9 /home/speedy/test/source2slice/NVD/CVE-2016-6508_VULN_add_description.c [u'info_buffer'] 5
add_description(proto_item *li_ti, proto_item *length_ti,
const char *format, ...) 2
static char info_buffer [ MAX_INFO_BUFFER ] ; 5
g_vsnprintf ( info_buffer , MAX_INFO_BUFFER , format , ap ); 10
proto_item_append_text ( li_ti , " (%s)" , info_buffer ); 13
proto_item_append_text ( length_ti , " (%s)" , info_buffer ); 14
0
------------------------------
10 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c [u'xbuf'] 8
static int proc_keys_show(struct seq_file *m, void *v) 1
char xbuf [ 12 ] ; 8
memcpy ( xbuf , "perm" , 5 ); 49
memcpy ( xbuf , "expd" , 5 ); 51
sprintf ( xbuf , "%lus" , timo ); 56
sprintf ( xbuf , "%lum" , timo / 60 ); 58
sprintf ( xbuf , "%luh" , timo / ( 60 * 60 ) ); 60
sprintf ( xbuf , "%lud" , timo / ( 60 * 60 * 24 ) ); 62
sprintf ( xbuf , "%luw" , timo / ( 60 * 60 * 24 * 7 ) ); 64
seq_printf ( m , "%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s " , key -> serial , showflag ( key , 'I' , KEY_FLAG_INSTANTIATED ) , showflag ( key , 'R' , KEY_FLAG_REVOKED ) , showflag ( key , 'D' , KEY_FLAG_DEAD ) , showflag ( key , 'Q' , KEY_FLAG_IN_QUOTA ) , showflag ( key , 'U' , KEY_FLAG_USER_CONSTRUCT ) , showflag ( key , 'N' , KEY_FLAG_NEGATIVE ) , showflag ( key , 'i' , KEY_FLAG_INVALIDATED ) , atomic_read ( & key -> usage ) , xbuf , key -> perm , from_kuid_munged ( seq_user_ns ( m ) , key -> uid ) , from_kgid_munged ( seq_user_ns ( m ) , key -> gid ) , key -> type -> name ); 70
1
------------------------------
11 /home/speedy/test/source2slice/NVD/CVE-2016-7179_VULN_parse_outhdr_string.c [u'digit_array'] 8
static void parse_outhdr_string(const guchar *outhdr_string, gint outhdr_string_len) 1
int n = 0 ; 3
for (outhdr_values_found=0; outhdr_values_found < MAX_OUTHDR_VALUES; ) 6
guint digit_array [ MAX_OUTHDR_VALUES ] ; 8
guint number_digits = 0 ; 9
guint number = 0 ; 11
guint multiplier = 1 ; 12
guint d ; 13
for ( ; n < outhdr_string_len; n++) 16
if ( ! g_ascii_isdigit ( outhdr_string [ n ] ) )  17
digit_array [ number_digits ++ ] = outhdr_string [ n ] - '0'; 21
if ( number_digits == 0 )  25
for (d=number_digits; d > 0; d--) 31
number += ( ( digit_array [ d - 1 ] ) * multiplier ); 32
multiplier *= 10; 33
outhdr_values [ outhdr_values_found ++ ] = number; 35
n ++; 38
0
------------------------------
12 /home/speedy/test/source2slice/NVD/CVE-2016-7180_VULN_dissect_ipmi_trace.c [u'str'] 38
dissect_ipmi_trace(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 1
guint block_type , chn_num , data_type , tmp ; 3
if ( tvb_captured_length ( tvb ) < 11 )  6
tmp = tvb_get_guint8 ( tvb , 0 ); 13
block_type = ( tmp >> 4 ) & 3; 16
if ( block_type == HPM2_TRACE_PACKET_DATA )  32
if ( block_type == HPM2_CHN_STATE_NOTIFY )  34
if ( block_type == HPM2_EMBED_ASCII_MSG )  37
char str [ 257 ] ; 38
tvb_memcpy ( tvb , str , 11 , str_len ); 45
str [ str_len ] = 0; 48
col_add_str ( pinfo -> cinfo , COL_INFO , str ); 51
0
------------------------------
13 /home/speedy/test/source2slice/NVD/CVE-2017-5547_VULN_k90_backlight_get.c [u'data'] 9
static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev) 1
char data [ 8 ] ; 9
ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ); 11
if ( ret < 0 )  16
dev_warn ( dev , "Failed to get K90 initial state (error %d).\n" , ret ); 17
brightness = data [ 4 ]; 21
if ( brightness < 0 || brightness > 3 )  22
dev_warn ( dev , "Read invalid backlight brightness: %02hhx.\n" , data [ 4 ] ); 23
return brightness ; 28
1
------------------------------
14 /home/speedy/test/source2slice/NVD/CVE-2017-6470_VULN_dissect_iax2_command.c [u'address_data'] 6
static guint32 dissect_iax2_command(tvbuff_t *tvb, guint32 offset,
packet_info *pinfo, proto_tree *tree,
iax_packet_data *iax_packet) 3
guint8 address_data [ MAX_ADDRESS ] ; 6
ie_data . peer_address . data = address_data; 13
ie_data . peer_ptype = PT_NONE; 14
ie_data . peer_port = 0; 15
ie_data . peer_callno = 0; 16
ie_data . dataformat = ( guint32 ) - 1; 17
offset = dissect_ies ( tvb , pinfo , offset , tree , ti , & ie_data ); 30
if ( iax_call && ie_data . dataformat != ( guint32 ) - 1 && iax_call -> subdissector == NULL )  33
iax_call -> subdissector = dissector_get_uint_handle ( iax2_dataformat_dissector_table , ie_data . dataformat ); 34
iax_call -> dataformat = ( iax_dataformat_t ) ie_data . dataformat; 35
if ( ie_data . peer_address . type != AT_NONE && ie_data . peer_callno != 0 )  40
guint tx_circuit = iax_circuit_lookup ( & ie_data . peer_address , ie_data . peer_ptype , ie_data . peer_port , ie_data . peer_callno ) ; 41
iax2_new_circuit_for_call ( pinfo , NULL , tx_circuit , pinfo -> fd -> num , iax_call , iax_packet -> reversed ); 46
return offset ; 50
0
------------------------------
15 /home/speedy/test/source2slice/NVD/CVE_2004_1151_PATCHED_sys32_ni_syscall.c [u'lastcomm'] 4
int CVE_2004_1151_PATCHED_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ sizeof ( me -> comm ) ] ; 4
if ( strncmp ( lastcomm , me -> comm , sizeof ( lastcomm ) ) )  6
strncpy ( lastcomm , me -> comm , sizeof ( lastcomm ) ); 9
0
------------------------------
16 /home/speedy/test/source2slice/NVD/CVE_2004_1151_VULN_sys32_ni_syscall.c [u'lastcomm'] 4
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
strcpy ( lastcomm , me -> comm ); 8
1
------------------------------
17 /home/speedy/test/source2slice/NVD/CVE_2005_3356_PATCHED_do_open.c [u'O_ACCMODE', u'oflag2acc'] 3
static struct file *CVE_2005_3356_PATCHED_do_open(struct dentry *dentry, int oflag) 1
static int oflag2acc [ O_ACCMODE ] = { MAY_READ , MAY_WRITE , MAY_READ | MAY_WRITE } ; 3
if ( ( oflag & O_ACCMODE ) == ( O_RDWR | O_WRONLY ) )  6
if ( permission ( dentry -> d_inode , oflag2acc [ oflag & O_ACCMODE ] , NULL ) )  12
0
------------------------------
18 /home/speedy/test/source2slice/NVD/CVE_2005_3356_VULN_do_open.c [u'O_ACCMODE', u'oflag2acc'] 3
static struct file *CVE_2005_3356_VULN_do_open(struct dentry *dentry, int oflag) 1
static int oflag2acc [ O_ACCMODE ] = { MAY_READ , MAY_WRITE , MAY_READ | MAY_WRITE } ; 3
if ( ( oflag & O_ACCMODE ) == ( O_RDWR | O_WRONLY ) )  7
if ( permission ( dentry -> d_inode , oflag2acc [ oflag & O_ACCMODE ] , NULL ) )  10
1
------------------------------
19 /home/speedy/test/source2slice/NVD/CVE_2006_2778_PATCHED_nsCrypto__SignText.c [u'hash'] 313
NS_IMETHODIMP
CVE_2006_2778_PATCHED_nsCrypto::SignText(const nsAString& aStringToSign, const nsAString& aCaOption,
nsAString& aResult) 3
nsCOMPtr < nsIXPCNativeCallContext > ncc ; 11
if ( ! ncc )  17
PRUint32 argc ; 23
JSContext * cx ; 26
if ( ! cx )  28
if ( ! aCaOption . Equals ( NS_LITERAL_STRING ( "auto" ) ) && ! aCaOption . Equals ( NS_LITERAL_STRING ( "ask" ) ) )  34
nsCOMPtr < nsIInterfaceRequestor > uiContext = new PipUIContext 46
if ( ! uiContext )  47
PRBool bestOnly = PR_TRUE ; 53
PRBool validOnly = PR_TRUE ; 54
CERTCertList * certList = CERT_FindUserCertsByUsage ( CERT_GetDefaultCertDB ( ) , certUsageEmailSigner , bestOnly , validOnly , uiContext ) ; 55
PRUint32 numCAs = argc - 2 ; 59
if ( numCAs > 0 )  60
if ( ! caNames )  62
jsval * argv = nsnull ; 68
PRUint32 i ; 71
for (i = 2; i < argc; ++i) 72
JSString * caName = JS_ValueToString ( cx , argv [ i ] ) ; 73
if ( ! caName )  74
caNames [ i - 2 ] = JS_GetStringBytes ( caName ); 79
if ( certList && CERT_FilterCertListByCANames ( certList , numCAs , caNames , certUsageEmailSigner ) != SECSuccess )  82
if ( ! certList || CERT_LIST_EMPTY ( certList ) )  91
nsCOMPtr < nsIFormSigningDialog > fsd = do_CreateInstance ( NS_FORMSIGNINGDIALOG_CONTRACTID ) ; 97
if ( ! fsd )  99
nsCOMPtr < nsIProxyObjectManager > proxyman = do_GetService ( NS_XPCOMPROXY_CONTRACTID ) ; 105
if ( ! proxyman )  107
nsCOMPtr < nsIFormSigningDialog > proxied_fsd ; 113
nsresult rv = proxyman -> GetProxyForObject ( NS_UI_THREAD_EVENTQ , NS_GET_IID ( nsIFormSigningDialog ) , fsd , PROXY_SYNC , getter_AddRefs ( proxied_fsd ) ) ; 114
if ( NS_FAILED ( rv ) )  118
nsCOMPtr < nsIDocument > document ; 124
if ( ! document )  126
nsIURI * uri = document -> GetDocumentURI ( ) ; 133
if ( ! uri )  134
nsCString host ; 140
rv = uri -> GetHost ( host ); 141
if ( NS_FAILED ( rv ) )  142
CERTCertListNode * node ; 149
for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
node = CERT_LIST_NEXT(node)) 151
CERTCertNicknames * nicknames = CERT_NicknameStringsFromCertList ( certList , NICKNAME_EXPIRED_STRING , NICKNAME_NOT_YET_VALID_STRING ) ; 155
if ( ! nicknames )  158
if ( ! certNicknameList )  170
PRUnichar * * certDetailsList = certNicknameList . get ( ) + nicknames -> numnicknames ; 176
PRInt32 certsToUse ; 178
for (node = CERT_LIST_HEAD(certList), certsToUse = 0;
!CERT_LIST_END(node, certList) && certsToUse < nicknames->numnicknames;
node = CERT_LIST_NEXT(node)) 181
nsRefPtr < nsNSSCertificate > tempCert = new nsNSSCertificate ( node -> cert ) ; 182
if ( tempCert )  183
nsAutoString nickWithSerial , details ; 184
rv = tempCert -> FormatUIStrings ( NS_ConvertUTF8toUTF16 ( nicknames -> nicknames [ certsToUse ] ) , nickWithSerial , details ); 185
if ( NS_SUCCEEDED ( rv ) )  187
certNicknameList [ certsToUse ] = ToNewUnicode ( nickWithSerial ); 188
if ( certNicknameList [ certsToUse ] )  189
certDetailsList [ certsToUse ] = ToNewUnicode ( details ); 190
if ( ! certDetailsList [ certsToUse ] )  191
if ( certsToUse == 0 )  201
CERTCertificate * signingCert = nsnull ; 209
PRBool tryAgain , canceled ; 210
PRInt32 selectedIndex = - 1 ; 215
rv = proxied_fsd -> ConfirmSignText ( uiContext , utf16Host , aStringToSign ,
NS_CONST_CAST ( const PRUnichar * * , certNicknameList . get ( ) ) ,
NS_CONST_CAST ( const PRUnichar * * , certDetailsList ) ,
certsToUse , & selectedIndex , password ,
& canceled ) 220
if ( NS_FAILED ( rv ) || canceled )  221
PRInt32 j = 0 ; 225
for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
node = CERT_LIST_NEXT(node)) 227
if ( j == selectedIndex )  228
signingCert = CERT_DupCertificate ( node -> cert ); 229
if ( ! signingCert )  235
rv = NS_ERROR_FAILURE; 236
tryAgain =
PK11_CheckUserPassword ( signingCert -> slot ,
NS_CONST_CAST ( char * , pwUtf8 . get ( ) ) ) != SECSuccess 244
while ( tryAgain )  246
if ( NS_FAILED ( rv ) )  254
if ( canceled )  260
SECKEYPrivateKey * privKey = PK11_FindKeyByAnyCert ( signingCert , uiContext ) ; 266
if ( ! privKey )  267
nsCAutoString charset ( document -> GetDocumentCharacterSet ( ) ) ; 273
nsCOMPtr < nsISaveAsCharset > encoder = do_CreateInstance ( NS_SAVEASCHARSET_CONTRACTID ) ; 281
if ( encoder )  283
rv = encoder -> Init ( charset . get ( ) , ( nsISaveAsCharset :: attr_EntityAfterCharsetConv + nsISaveAsCharset :: attr_FallbackDecimalNCR ) , 0 ); 284
nsXPIDLCString buffer ; 290
if ( aStringToSign . Length ( ) > 0 )  291
if ( encoder && NS_SUCCEEDED ( rv ) )  292
rv = encoder -> Convert ( PromiseFlatString ( aStringToSign ) . get ( ) , getter_Copies ( buffer ) ); 293
if ( NS_FAILED ( rv ) )  295
HASHContext * hc = HASH_Create ( HASH_AlgSHA1 ) ; 306
if ( ! hc )  307
unsigned char hash [ SHA1_LENGTH ] ; 313
digest . data = hash; 316
HASH_End ( hc , digest . data , & digest . len , SHA1_LENGTH ); 321
SEC_PKCS7ContentInfo * ci = SEC_PKCS7CreateSignedData ( signingCert , certUsageEmailSigner , nsnull , SEC_OID_SHA1 , & digest , nsnull , uiContext ) ; 327
if ( ci )  331
srv = SEC_PKCS7IncludeCertChain ( ci , nsnull ); 332
if ( srv == SECSuccess )  333
srv = SEC_PKCS7AddSigningTime ( ci ); 334
if ( srv == SECSuccess )  335
srv = SEC_PKCS7Encode ( ci , signTextOutputCallback , & p7 , nsnull , nsnull , uiContext ); 336
SEC_PKCS7DestroyContentInfo ( ci ); 341
if ( srv != SECSuccess )  344
0
------------------------------
20 /home/speedy/test/source2slice/NVD/CVE_2006_2778_VULN_nsCrypto__SignText.c [u'hash'] 313
NS_IMETHODIMP
CVE_2006_2778_VULN_nsCrypto::SignText(const nsAString& aStringToSign, const nsAString& aCaOption,
nsAString& aResult) 3
nsCOMPtr < nsIXPCNativeCallContext > ncc ; 11
if ( ! ncc )  17
PRUint32 argc ; 23
JSContext * cx ; 26
if ( ! cx )  28
if ( ! aCaOption . Equals ( NS_LITERAL_STRING ( "auto" ) ) && ! aCaOption . Equals ( NS_LITERAL_STRING ( "ask" ) ) )  34
nsCOMPtr < nsIInterfaceRequestor > uiContext = new PipUIContext 46
if ( ! uiContext )  47
PRBool bestOnly = PR_TRUE ; 53
PRBool validOnly = PR_TRUE ; 54
CERTCertList * certList = CERT_FindUserCertsByUsage ( CERT_GetDefaultCertDB ( ) , certUsageEmailSigner , bestOnly , validOnly , uiContext ) ; 55
PRUint32 numCAs = argc - 2 ; 59
if ( numCAs > 0 )  60
if ( ! caNames )  62
jsval * argv = nsnull ; 68
PRUint32 i ; 71
for (i = 2; i < argc; ++i) 72
JSString * caName = JS_ValueToString ( cx , argv [ i ] ) ; 73
if ( ! caName )  74
caNames [ i ] = JS_GetStringBytes ( caName ); 79
if ( certList && CERT_FilterCertListByCANames ( certList , numCAs , caNames , certUsageEmailSigner ) != SECSuccess )  82
if ( ! certList || CERT_LIST_EMPTY ( certList ) )  91
nsCOMPtr < nsIFormSigningDialog > fsd = do_CreateInstance ( NS_FORMSIGNINGDIALOG_CONTRACTID ) ; 97
if ( ! fsd )  99
nsCOMPtr < nsIProxyObjectManager > proxyman = do_GetService ( NS_XPCOMPROXY_CONTRACTID ) ; 105
if ( ! proxyman )  107
nsCOMPtr < nsIFormSigningDialog > proxied_fsd ; 113
nsresult rv = proxyman -> GetProxyForObject ( NS_UI_THREAD_EVENTQ , NS_GET_IID ( nsIFormSigningDialog ) , fsd , PROXY_SYNC , getter_AddRefs ( proxied_fsd ) ) ; 114
if ( NS_FAILED ( rv ) )  118
nsCOMPtr < nsIDocument > document ; 124
if ( ! document )  126
nsIURI * uri = document -> GetDocumentURI ( ) ; 133
if ( ! uri )  134
nsCString host ; 140
rv = uri -> GetHost ( host ); 141
if ( NS_FAILED ( rv ) )  142
CERTCertListNode * node ; 149
for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
node = CERT_LIST_NEXT(node)) 151
CERTCertNicknames * nicknames = CERT_NicknameStringsFromCertList ( certList , NICKNAME_EXPIRED_STRING , NICKNAME_NOT_YET_VALID_STRING ) ; 155
if ( ! nicknames )  158
if ( ! certNicknameList )  170
PRUnichar * * certDetailsList = certNicknameList . get ( ) + nicknames -> numnicknames ; 176
PRInt32 certsToUse ; 178
for (node = CERT_LIST_HEAD(certList), certsToUse = 0;
!CERT_LIST_END(node, certList) && certsToUse < nicknames->numnicknames;
node = CERT_LIST_NEXT(node)) 181
nsRefPtr < nsNSSCertificate > tempCert = new nsNSSCertificate ( node -> cert ) ; 182
if ( tempCert )  183
nsAutoString nickWithSerial , details ; 184
rv = tempCert -> FormatUIStrings ( NS_ConvertUTF8toUTF16 ( nicknames -> nicknames [ certsToUse ] ) , nickWithSerial , details ); 185
if ( NS_SUCCEEDED ( rv ) )  187
certNicknameList [ certsToUse ] = ToNewUnicode ( nickWithSerial ); 188
if ( certNicknameList [ certsToUse ] )  189
certDetailsList [ certsToUse ] = ToNewUnicode ( details ); 190
if ( ! certDetailsList [ certsToUse ] )  191
if ( certsToUse == 0 )  201
CERTCertificate * signingCert = nsnull ; 209
PRBool tryAgain , canceled ; 210
PRInt32 selectedIndex = - 1 ; 215
rv = proxied_fsd -> ConfirmSignText ( uiContext , utf16Host , aStringToSign ,
NS_CONST_CAST ( const PRUnichar * * , certNicknameList . get ( ) ) ,
NS_CONST_CAST ( const PRUnichar * * , certDetailsList ) ,
certsToUse , & selectedIndex , password ,
& canceled ) 220
if ( NS_FAILED ( rv ) || canceled )  221
PRInt32 j = 0 ; 225
for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
node = CERT_LIST_NEXT(node)) 227
if ( j == selectedIndex )  228
signingCert = CERT_DupCertificate ( node -> cert ); 229
if ( ! signingCert )  235
rv = NS_ERROR_FAILURE; 236
tryAgain =
PK11_CheckUserPassword ( signingCert -> slot ,
NS_CONST_CAST ( char * , pwUtf8 . get ( ) ) ) != SECSuccess 244
while ( tryAgain )  246
if ( NS_FAILED ( rv ) )  254
if ( canceled )  260
SECKEYPrivateKey * privKey = PK11_FindKeyByAnyCert ( signingCert , uiContext ) ; 266
if ( ! privKey )  267
nsCAutoString charset ( document -> GetDocumentCharacterSet ( ) ) ; 273
nsCOMPtr < nsISaveAsCharset > encoder = do_CreateInstance ( NS_SAVEASCHARSET_CONTRACTID ) ; 281
if ( encoder )  283
rv = encoder -> Init ( charset . get ( ) , ( nsISaveAsCharset :: attr_EntityAfterCharsetConv + nsISaveAsCharset :: attr_FallbackDecimalNCR ) , 0 ); 284
nsXPIDLCString buffer ; 290
if ( aStringToSign . Length ( ) > 0 )  291
if ( encoder && NS_SUCCEEDED ( rv ) )  292
rv = encoder -> Convert ( PromiseFlatString ( aStringToSign ) . get ( ) , getter_Copies ( buffer ) ); 293
if ( NS_FAILED ( rv ) )  295
HASHContext * hc = HASH_Create ( HASH_AlgSHA1 ) ; 306
if ( ! hc )  307
unsigned char hash [ SHA1_LENGTH ] ; 313
digest . data = hash; 316
HASH_End ( hc , digest . data , & digest . len , SHA1_LENGTH ); 321
SEC_PKCS7ContentInfo * ci = SEC_PKCS7CreateSignedData ( signingCert , certUsageEmailSigner , nsnull , SEC_OID_SHA1 , & digest , nsnull , uiContext ) ; 327
if ( ci )  331
srv = SEC_PKCS7IncludeCertChain ( ci , nsnull ); 332
if ( srv == SECSuccess )  333
srv = SEC_PKCS7AddSigningTime ( ci ); 334
if ( srv == SECSuccess )  335
srv = SEC_PKCS7Encode ( ci , signTextOutputCallback , & p7 , nsnull , nsnull , uiContext ); 336
SEC_PKCS7DestroyContentInfo ( ci ); 341
if ( srv != SECSuccess )  344
1
------------------------------
21 /home/speedy/test/source2slice/NVD/CVE_2006_2935_PATCHED_dvd_read_bca.c [u'buf'] 4
static int CVE_2006_2935_PATCHED_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
u_char buf [ 4 + 188 ] ; 4
init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ); 8
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
cdinfo ( CD_WARNING , "Received invalid BCA length (%d)\n" , s -> bca . len ); 18
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
0
------------------------------
22 /home/speedy/test/source2slice/NVD/CVE_2006_2935_VULN_dvd_read_bca.c [u'buf'] 4
static int CVE_2006_2935_VULN_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
u_char buf [ 4 + 188 ] ; 4
init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ); 8
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
cdinfo ( CD_WARNING , "Received invalid BCA length (%d)\n" , s -> bca . len ); 18
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
0
------------------------------
23 /home/speedy/test/source2slice/NVD/CVE_2006_4813_PATCHED___block_prepare_write.c [u'wait_bh', u'head', u'bh', u'wait'] 8
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
wait_on_buffer ( * -- wait_bh ); 77
if ( ! buffer_uptodate ( * wait_bh ) )  78
0
------------------------------
24 /home/speedy/test/source2slice/NVD/CVE_2006_4813_VULN___block_prepare_write.c [u'wait_bh', u'head', u'bh', u'wait'] 8
static int CVE_2006_4813_VULN___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
* wait_bh ++ = bh; 71
while ( wait_bh > wait )  77
wait_on_buffer ( * -- wait_bh ); 78
if ( ! buffer_uptodate ( * wait_bh ) )  79
0
------------------------------
25 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'todir'] 10
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char todir [ PATH_MAX ] ; 10
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
0
------------------------------
26 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'category'] 9
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char category [ 32 ] ; 9
ast_copy_string ( category , temp , sizeof ( category ) ); 97
category [ 0 ] = '\0'; 99
if ( ( ! res ) && ! ast_strlen_zero ( category ) )  106
res = play_message_category ( chan , category ); 107
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
27 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'duration'] 8
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char duration [ 16 ] ; 8
ast_copy_string ( duration , temp , sizeof ( duration ) ); 90
duration [ 0 ] = '\0'; 92
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
res = play_message_duration ( chan , vms , duration , vmu -> saydurationm ); 116
if ( ! res )  125
return res ; 131
0
------------------------------
28 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'origtime'] 7
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char origtime [ 32 ] ; 7
ast_copy_string ( origtime , temp , sizeof ( origtime ) ); 83
origtime [ 0 ] = '\0'; 85
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
res = play_message_datetime ( chan , vmu , origtime , "IMAP_STORAGE" ); 111
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
29 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'context'] 6
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char context [ 256 ] ; 6
ast_copy_string ( context , temp , sizeof ( context ) ); 76
context [ 0 ] = '\0'; 78
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
30 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c [u'cid'] 5
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char cid [ 256 ] ; 5
ast_copy_string ( cid , temp , sizeof ( cid ) ); 69
cid [ 0 ] = '\0'; 71
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
31 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'todir'] 10
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char todir [ PATH_MAX ] ; 10
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
0
------------------------------
32 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'category'] 9
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char category [ 32 ] ; 9
ast_copy_string ( category , temp , sizeof ( category ) ); 97
category [ 0 ] = '\0'; 99
if ( ( ! res ) && ! ast_strlen_zero ( category ) )  106
res = play_message_category ( chan , category ); 107
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
33 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'duration'] 8
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char duration [ 16 ] ; 8
ast_copy_string ( duration , temp , sizeof ( duration ) ); 90
duration [ 0 ] = '\0'; 92
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
res = play_message_duration ( chan , vms , duration , vmu -> saydurationm ); 116
if ( ! res )  125
return res ; 131
0
------------------------------
34 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'origtime'] 7
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char origtime [ 32 ] ; 7
ast_copy_string ( origtime , temp , sizeof ( origtime ) ); 83
origtime [ 0 ] = '\0'; 85
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
res = play_message_datetime ( chan , vmu , origtime , "IMAP_STORAGE" ); 111
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
35 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'context'] 6
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char context [ 256 ] ; 6
ast_copy_string ( context , temp , sizeof ( context ) ); 76
context [ 0 ] = '\0'; 78
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
36 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c [u'cid'] 5
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char cid [ 256 ] ; 5
ast_copy_string ( cid , temp , sizeof ( cid ) ); 69
cid [ 0 ] = '\0'; 71
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
0
------------------------------
37 /home/speedy/test/source2slice/NVD/CVE_2007_4571_PATCHED_snd_mem_proc_read.c [u'types'] 6
static int CVE_2007_4571_PATCHED_snd_mem_proc_read(struct seq_file *seq, void *offset) 1
static char * types [ ] = { "UNKNOWN" , "CONT" , "DEV" , "DEV-SG" , "SBUS" } ; 6
seq_printf ( seq , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 14
0
------------------------------
38 /home/speedy/test/source2slice/NVD/CVE_2007_4571_VULN_snd_mem_proc_read.c [u'types'] 8
static int CVE_2007_4571_VULN_snd_mem_proc_read(char *page, char **start, off_t off,
int count, int *eof, void *data) 2
static char * types [ ] = { "UNKNOWN" , "CONT" , "DEV" , "DEV-SG" , "SBUS" } ; 8
len += snprintf ( page + len , count - len , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 17
len += snprintf ( page + len , count - len , "  addr = 0x%lx, size = %d bytes\n" , ( unsigned long ) mem -> buffer . addr , ( int ) mem -> buffer . bytes ); 20
return len ; 25
1
------------------------------
39 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c [u'tmp'] 60
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
char tmp [ 80 ] ; 60
sprintf ( tmp , "%08lx" , s -> managerid ); 88
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 89
tmp = xml_translate ( s -> outputstr -> str , params ); 102
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
if ( tmp != s -> outputstr -> str )  116
free ( tmp ); 117
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
0
------------------------------
40 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c [u'cookie'] 6
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char cookie [ 128 ] ; 6
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 89
0
------------------------------
41 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c [u'workspace'] 5
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char workspace [ 512 ] ; 5
char * c = workspace ; 9
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
0
------------------------------
42 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c [u'tmp'] 55
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
char tmp [ 80 ] ; 55
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
1
------------------------------
43 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c [u'cookie'] 6
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char cookie [ 128 ] ; 6
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
0
------------------------------
44 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c [u'workspace'] 5
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char workspace [ 512 ] ; 5
char * c = workspace ; 9
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
45 /home/speedy/test/source2slice/NVD/CVE_2009_0746_PATCHED_make_indexed_dir.c [u'frame', u'frames'] 9
static int CVE_2009_0746_PATCHED_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct dx_frame frames [ 2 ] , * frame ; 9
frame = frames; 73
frame -> entries = entries; 74
frame -> at = entries; 75
frame -> bh = bh; 76
de = do_split ( handle , dir , & bh , frame , & hinfo , & retval ); 78
dx_release ( frames ); 79
if ( ! ( de ) )  80
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 83
0
------------------------------
46 /home/speedy/test/source2slice/NVD/CVE_2009_0746_VULN_make_indexed_dir.c [u'frame', u'frames'] 9
static int CVE_2009_0746_VULN_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct dx_frame frames [ 2 ] , * frame ; 9
frame = frames; 64
frame -> entries = entries; 65
frame -> at = entries; 66
frame -> bh = bh; 67
de = do_split ( handle , dir , & bh , frame , & hinfo , & retval ); 69
dx_release ( frames ); 70
if ( ! ( de ) )  71
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 74
0
------------------------------
47 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c [u'psz_server', u'psz_remote', u'psz_share'] 6
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
strlcpy ( psz_server , psz_path , sizeof ( psz_server ) ); 31
psz_share [ 0 ] = 0; 32
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
snprintf ( psz_remote , sizeof ( psz_remote ) , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
0
------------------------------
48 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c [u'psz_server', u'psz_remote', u'psz_share'] 6
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
strlcpy ( psz_server , psz_path , sizeof ( psz_server ) ); 31
psz_share [ 0 ] = 0; 32
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
sprintf ( psz_remote , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
1
------------------------------
49 /home/speedy/test/source2slice/NVD/CVE_2009_2768_PATCHED_load_flat_shared_library.c [u'buf'] 5
static int CVE_2009_2768_PATCHED_load_flat_shared_library(int id, struct lib_info *libs) 1
char buf [ 16 ] ; 5
sprintf ( buf , "/lib/lib%d.so" , id ); 8
bprm . filename = buf; 11
bprm . file = open_exec ( bprm . filename ); 12
res = PTR_ERR ( bprm . file ); 13
if ( IS_ERR ( bprm . file ) )  14
return res ; 15
bprm . cred = prepare_exec_creds ( ); 17
if ( ! bprm . cred )  19
res = prepare_binprm ( & bprm ); 22
if ( res <= ( unsigned long ) - 4096 )  24
res = load_flat_file ( & bprm , libs , id , NULL ); 25
abort_creds ( bprm . cred ); 27
allow_write_access ( bprm . file ); 30
fput ( bprm . file ); 31
return ( res ) ; 33
0
------------------------------
50 /home/speedy/test/source2slice/NVD/CVE_2009_2768_VULN_load_flat_shared_library.c [u'buf'] 5
static int CVE_2009_2768_VULN_load_flat_shared_library(int id, struct lib_info *libs) 1
char buf [ 16 ] ; 5
sprintf ( buf , "/lib/lib%d.so" , id ); 8
bprm . filename = buf; 11
bprm . file = open_exec ( bprm . filename ); 12
res = PTR_ERR ( bprm . file ); 13
if ( IS_ERR ( bprm . file ) )  14
return res ; 15
res = prepare_binprm ( & bprm ); 17
if ( res <= ( unsigned long ) - 4096 )  19
res = load_flat_file ( & bprm , libs , id , NULL ); 20
if ( bprm . file )  21
allow_write_access ( bprm . file ); 22
fput ( bprm . file ); 23
bprm . file = NULL; 24
return ( res ) ; 26
1
------------------------------
51 /home/speedy/test/source2slice/NVD/CVE_2009_2909_PATCHED_ax25_setsockopt.c [u'devname'] 7
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
char devname [ IFNAMSIZ ] ; 7
if ( copy_from_user ( devname , optval , optlen ) )  110
dev = dev_get_by_name ( & init_net , devname ); 115
if ( dev == NULL )  116
dev_put ( dev ); 125
ax25 -> ax25_dev = ax25_dev_ax25dev ( dev ); 129
ax25_fillin_cb ( ax25 , ax25 -> ax25_dev ); 130
0
------------------------------
52 /home/speedy/test/source2slice/NVD/CVE_2009_2909_VULN_ax25_setsockopt.c [u'devname'] 7
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
char devname [ IFNAMSIZ ] ; 7
if ( copy_from_user ( devname , optval , optlen ) )  110
dev = dev_get_by_name ( & init_net , devname ); 115
if ( dev == NULL )  116
dev_put ( dev ); 125
ax25 -> ax25_dev = ax25_dev_ax25dev ( dev ); 129
ax25_fillin_cb ( ax25 , ax25 -> ax25_dev ); 130
0
------------------------------
53 /home/speedy/test/source2slice/NVD/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c [u'hop_by_hop_hdrs'] 20
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
static const char * hop_by_hop_hdrs [ ] = { "Keep-Alive" , "Proxy-Authenticate" , "TE" , "Trailer" , "Upgrade" , NULL } ; 20
for (i=0; hop_by_hop_hdrs[i]; ++i) 231
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 232
0
------------------------------
54 /home/speedy/test/source2slice/NVD/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c [u'buffer'] 8
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 42
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 45
ap_log_rerror ( APLOG_MARK , APLOG_ERR , rc , r ,
"proxy: error reading status line from remote "
"server %s" , backend -> hostname ) 50
if ( APR_STATUS_IS_TIMEUP ( rc ) )  51
if ( r -> proxyreq == PROXYREQ_REVERSE && c -> keepalives && ! APR_STATUS_IS_TIMEUP ( rc ) )  66
backend -> worker -> s -> read += len; 114
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  119
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  122
if ( ( buffer [ 5 ] != '1' ) || ( len >= sizeof ( buffer ) - 1 ) )  129
return ap_proxyerror ( r , HTTP_BAD_GATEWAY ,
apr_pstrcat ( p , "Corrupt status line returned by remote "
"server: " , buffer , NULL ) ) 132
keepchar = buffer [ 12 ]; 136
buffer [ 12 ] = '\0'; 137
r -> status = atoi ( & buffer [ 9 ] ); 138
if ( keepchar != '\0' )  140
buffer [ 12 ] = keepchar; 141
buffer [ 12 ] = ' '; 146
buffer [ 13 ] = '\0'; 147
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 149
save_table = apr_table_make ( r -> pool , 2 ); 157
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 158
ap_proxy_read_headers ( r , rp , buffer , sizeof ( buffer ) , origin , & pread_len ); 162
if ( r -> headers_out == NULL )  165
ap_log_error ( APLOG_MARK , APLOG_WARNING , 0 ,
r -> server , "proxy: bad HTTP/%d.%d header "
"returned by %s (%s)" , major , minor , r -> uri ,
r -> method ) 169
backend -> close += 1; 170
r -> headers_out = apr_table_make ( r -> pool , 1 ); 176
r -> status = HTTP_BAD_GATEWAY; 177
r -> status_line = "bad gateway"; 178
return r -> status ; 179
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 183
if ( ! apr_is_empty_table ( save_table ) )  187
apr_table_unset ( r -> headers_out , "Set-Cookie" ); 188
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 189
if ( apr_table_get ( r -> headers_out , "Transfer-Encoding" ) && apr_table_get ( r -> headers_out , "Content-Length" ) )  195
apr_table_unset ( r -> headers_out , "Content-Length" ); 206
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server ,
"proxy: server %s returned Transfer-Encoding"
" and Content-Length" , backend -> hostname ) 209
backend -> close += 1; 210
te = apr_table_get ( r -> headers_out , "Transfer-Encoding" ); 217
backend -> close += ap_proxy_liststr ( apr_table_get ( r -> headers_out , "Connection" ) , "close" ); 219
ap_proxy_clear_connection ( p , r -> headers_out ); 222
if ( buf = apr_table_get ( r -> headers_out , "Content-Type" ) )  223
ap_set_content_type ( r , apr_pstrdup ( p , buf ) ); 224
if ( ! ap_is_HTTP_INFO ( r -> status ) )  226
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 232
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 235
const char * server_name = ap_get_server_name ( r ) ; 239
if ( server_name == r -> hostname )  245
server_name = r -> server -> server_hostname; 246
apr_table_addn ( r -> headers_out , "Via" , ( conf -> viaopt == via_full ) ? apr_psprintf ( p , "%d.%d %s%s (%s)" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr , AP_SERVER_BASEVERSION ) : apr_psprintf ( p , "%d.%d %s%s" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr ) ); 248
backend -> close += 1; 266
backend -> close += 1; 274
if ( ap_is_HTTP_INFO ( r -> status ) )  277
const char * policy = apr_table_get ( r -> subprocess_env , "proxy-interim-response" ) ; 296
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , NULL , "proxy: HTTP: received interim %d response" , r -> status ); 298
if ( ! policy || ! strcasecmp ( policy , "RFC" ) )  301
if ( strcasecmp ( policy , "Suppress" ) )  307
if ( ( r -> status == 401 ) && ( conf -> error_override ) )  316
if ( buf = apr_table_get ( r -> headers_out , wa ) )  319
apr_table_set ( r -> err_headers_out , wa , buf ); 320
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server , "proxy: origin server sent 401 without WWW-Authenticate header" ); 322
ap_xlate_proto_to_ascii ( buffer , len ); 346
e = apr_bucket_heap_create ( buffer , cntr , NULL , c -> bucket_alloc ); 349
APR_BRIGADE_INSERT_TAIL ( bb , e ); 350
if ( ( ! r -> header_only ) && ! interim_response && ( r -> status != HTTP_NO_CONTENT ) && ( r -> status != HTTP_NOT_MODIFIED ) )  354
rp -> headers_in = apr_table_copy ( r -> pool , r -> headers_out ); 364
if ( te && ! apr_table_get ( rp -> headers_in , "Transfer-Encoding" ) )  370
apr_table_add ( rp -> headers_in , "Transfer-Encoding" , te ); 371
apr_table_unset ( r -> headers_out , "Transfer-Encoding" ); 374
if ( ! conf -> error_override || ! ap_is_HTTP_ERROR ( r -> status ) )  383
rv = ap_get_brigade ( rp -> input_filters , bb , AP_MODE_READBYTES , mode , conf -> io_buffer_size ); 392
if ( APR_STATUS_IS_EAGAIN ( rv ) || ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( bb ) ) )  398
APR_BRIGADE_INSERT_TAIL ( bb , e ); 402
backend -> close = 1; 405
if ( rv == APR_EOF )  412
if ( rv != APR_SUCCESS )  415
ap_log_cerror ( APLOG_MARK , APLOG_ERR , rv , c , "proxy: error reading response" ); 420
backend -> worker -> s -> read += readbytes; 432
APR_BRIGADE_INSERT_TAIL ( bb , e ); 474
if ( ! ap_is_HTTP_ERROR ( r -> status ) )  500
int status = r -> status ; 507
if ( ! r -> header_only && ( status != HTTP_NO_CONTENT ) && ( status != HTTP_NOT_MODIFIED ) )  510
ap_discard_request_body ( rp ); 513
return status ; 515
0
------------------------------
55 /home/speedy/test/source2slice/NVD/CVE_2010_2068_VULN_ap_proxy_http_process_response.c [u'hop_by_hop_hdrs'] 20
static
apr_status_t CVE_2010_2068_VULN_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
static const char * hop_by_hop_hdrs [ ] = { "Keep-Alive" , "Proxy-Authenticate" , "TE" , "Trailer" , "Upgrade" , NULL } ; 20
for (i=0; hop_by_hop_hdrs[i]; ++i) 229
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 230
0
------------------------------
56 /home/speedy/test/source2slice/NVD/CVE_2010_2068_VULN_ap_proxy_http_process_response.c [u'buffer'] 8
static
apr_status_t CVE_2010_2068_VULN_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 42
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 45
ap_log_rerror ( APLOG_MARK , APLOG_ERR , rc , r ,
"proxy: error reading status line from remote "
"server %s" , backend -> hostname ) 50
if ( rc == APR_TIMEUP )  51
if ( r -> proxyreq == PROXYREQ_REVERSE && c -> keepalives && rc != APR_TIMEUP )  66
backend -> worker -> s -> read += len; 112
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  117
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  120
if ( ( buffer [ 5 ] != '1' ) || ( len >= sizeof ( buffer ) - 1 ) )  127
return ap_proxyerror ( r , HTTP_BAD_GATEWAY ,
apr_pstrcat ( p , "Corrupt status line returned by remote "
"server: " , buffer , NULL ) ) 130
keepchar = buffer [ 12 ]; 134
buffer [ 12 ] = '\0'; 135
r -> status = atoi ( & buffer [ 9 ] ); 136
if ( keepchar != '\0' )  138
buffer [ 12 ] = keepchar; 139
buffer [ 12 ] = ' '; 144
buffer [ 13 ] = '\0'; 145
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 147
save_table = apr_table_make ( r -> pool , 2 ); 155
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 156
ap_proxy_read_headers ( r , rp , buffer , sizeof ( buffer ) , origin , & pread_len ); 160
if ( r -> headers_out == NULL )  163
ap_log_error ( APLOG_MARK , APLOG_WARNING , 0 ,
r -> server , "proxy: bad HTTP/%d.%d header "
"returned by %s (%s)" , major , minor , r -> uri ,
r -> method ) 167
backend -> close += 1; 168
r -> headers_out = apr_table_make ( r -> pool , 1 ); 174
r -> status = HTTP_BAD_GATEWAY; 175
r -> status_line = "bad gateway"; 176
return r -> status ; 177
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 181
if ( ! apr_is_empty_table ( save_table ) )  185
apr_table_unset ( r -> headers_out , "Set-Cookie" ); 186
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 187
if ( apr_table_get ( r -> headers_out , "Transfer-Encoding" ) && apr_table_get ( r -> headers_out , "Content-Length" ) )  193
apr_table_unset ( r -> headers_out , "Content-Length" ); 204
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server ,
"proxy: server %s returned Transfer-Encoding"
" and Content-Length" , backend -> hostname ) 207
backend -> close += 1; 208
te = apr_table_get ( r -> headers_out , "Transfer-Encoding" ); 215
backend -> close += ap_proxy_liststr ( apr_table_get ( r -> headers_out , "Connection" ) , "close" ); 217
ap_proxy_clear_connection ( p , r -> headers_out ); 220
if ( buf = apr_table_get ( r -> headers_out , "Content-Type" ) )  221
ap_set_content_type ( r , apr_pstrdup ( p , buf ) ); 222
if ( ! ap_is_HTTP_INFO ( r -> status ) )  224
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 230
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 233
const char * server_name = ap_get_server_name ( r ) ; 237
if ( server_name == r -> hostname )  243
server_name = r -> server -> server_hostname; 244
apr_table_addn ( r -> headers_out , "Via" , ( conf -> viaopt == via_full ) ? apr_psprintf ( p , "%d.%d %s%s (%s)" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr , AP_SERVER_BASEVERSION ) : apr_psprintf ( p , "%d.%d %s%s" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr ) ); 246
backend -> close += 1; 264
backend -> close += 1; 272
if ( ap_is_HTTP_INFO ( r -> status ) )  275
const char * policy = apr_table_get ( r -> subprocess_env , "proxy-interim-response" ) ; 294
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , NULL , "proxy: HTTP: received interim %d response" , r -> status ); 296
if ( ! policy || ! strcasecmp ( policy , "RFC" ) )  299
if ( strcasecmp ( policy , "Suppress" ) )  305
if ( ( r -> status == 401 ) && ( conf -> error_override ) )  314
if ( buf = apr_table_get ( r -> headers_out , wa ) )  317
apr_table_set ( r -> err_headers_out , wa , buf ); 318
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server , "proxy: origin server sent 401 without WWW-Authenticate header" ); 320
ap_xlate_proto_to_ascii ( buffer , len ); 344
e = apr_bucket_heap_create ( buffer , cntr , NULL , c -> bucket_alloc ); 347
APR_BRIGADE_INSERT_TAIL ( bb , e ); 348
if ( ( ! r -> header_only ) && ! interim_response && ( r -> status != HTTP_NO_CONTENT ) && ( r -> status != HTTP_NOT_MODIFIED ) )  352
rp -> headers_in = apr_table_copy ( r -> pool , r -> headers_out ); 362
if ( te && ! apr_table_get ( rp -> headers_in , "Transfer-Encoding" ) )  368
apr_table_add ( rp -> headers_in , "Transfer-Encoding" , te ); 369
apr_table_unset ( r -> headers_out , "Transfer-Encoding" ); 372
if ( ! conf -> error_override || ! ap_is_HTTP_ERROR ( r -> status ) )  381
rv = ap_get_brigade ( rp -> input_filters , bb , AP_MODE_READBYTES , mode , conf -> io_buffer_size ); 390
if ( APR_STATUS_IS_EAGAIN ( rv ) || ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( bb ) ) )  396
APR_BRIGADE_INSERT_TAIL ( bb , e ); 400
backend -> close = 1; 403
if ( rv == APR_EOF )  410
if ( rv != APR_SUCCESS )  413
ap_log_cerror ( APLOG_MARK , APLOG_ERR , rv , c , "proxy: error reading response" ); 418
backend -> worker -> s -> read += readbytes; 430
APR_BRIGADE_INSERT_TAIL ( bb , e ); 472
if ( ! ap_is_HTTP_ERROR ( r -> status ) )  498
int status = r -> status ; 505
if ( ! r -> header_only && ( status != HTTP_NO_CONTENT ) && ( status != HTTP_NOT_MODIFIED ) )  508
ap_discard_request_body ( rp ); 511
return status ; 513
1
------------------------------
57 /home/speedy/test/source2slice/NVD/CVE_2010_2431_PATCHED_cupsFileOpen.c [u'portname', u'hostname'] 9
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_PATCHED_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
strlcpy ( hostname , filename , sizeof ( hostname ) ); 56
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  57
* portname ++ = '\0'; 58
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  66
if ( ! httpAddrConnect ( addrlist , & fd ) )  73
httpAddrFreeList ( addrlist ); 75
httpAddrFreeList ( addrlist ); 79
0
------------------------------
58 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c [u'portname', u'hostname'] 9
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
strlcpy ( hostname , filename , sizeof ( hostname ) ); 45
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
httpAddrFreeList ( addrlist ); 64
httpAddrFreeList ( addrlist ); 68
0
------------------------------
59 /home/speedy/test/source2slice/NVD/CVE_2010_2495_PATCHED_pppol2tp_sendmsg.c [u'ppph'] 4
static int CVE_2010_2495_PATCHED_pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
size_t total_len) 2
static const unsigned char ppph [ 2 ] = { 0xff , 0x03 } ; 4
skb -> data [ 0 ] = ppph [ 0 ]; 66
skb -> data [ 1 ] = ppph [ 1 ]; 67
skb_put ( skb , 2 ); 68
error = memcpy_fromiovec ( skb -> data , m -> msg_iov , total_len ); 71
if ( error < 0 )  72
kfree_skb ( skb ); 73
skb_put ( skb , total_len ); 76
skb -> ip_summed = CHECKSUM_NONE; 80
unsigned char * datap = skb -> data ; 110
printk ( " %02X" , * datap ++ ); 114
len = skb -> len; 124
if ( error >= 0 )  128
tunnel -> stats . tx_bytes += len; 130
session -> stats . tx_bytes += len; 132
return error ; 138
return error ; 145
0
------------------------------
60 /home/speedy/test/source2slice/NVD/CVE_2010_2495_VULN_pppol2tp_sendmsg.c [u'ppph'] 4
static int CVE_2010_2495_VULN_pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
size_t total_len) 2
static const unsigned char ppph [ 2 ] = { 0xff , 0x03 } ; 4
skb -> data [ 0 ] = ppph [ 0 ]; 66
skb -> data [ 1 ] = ppph [ 1 ]; 67
skb_put ( skb , 2 ); 68
error = memcpy_fromiovec ( skb -> data , m -> msg_iov , total_len ); 71
if ( error < 0 )  72
kfree_skb ( skb ); 73
skb_put ( skb , total_len ); 76
skb -> ip_summed = CHECKSUM_NONE; 80
unsigned char * datap = skb -> data ; 109
printk ( " %02X" , * datap ++ ); 113
len = skb -> len; 123
tunnel -> stats . tx_bytes += len; 129
session -> stats . tx_bytes += len; 131
return error ; 144
0
------------------------------
61 /home/speedy/test/source2slice/NVD/CVE_2010_2803_PATCHED_drm_ioctl.c [u'stack_kdata'] 10
long CVE_2010_2803_PATCHED_drm_ioctl(struct file *filp,
unsigned int cmd, unsigned long arg) 2
char stack_kdata [ 128 ] ; 10
kdata = stack_kdata; 52
if ( copy_from_user ( kdata , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) != 0 )  63
memset ( kdata , 0 , _IOC_SIZE ( cmd ) ); 69
retcode = func ( dev , kdata , file_priv ); 72
retcode = func ( dev , kdata , file_priv ); 75
if ( copy_to_user ( ( void __user * ) arg , kdata , _IOC_SIZE ( cmd ) ) != 0 )  80
if ( kdata != stack_kdata )  87
kfree ( kdata ); 88
if ( retcode )  90
DRM_DEBUG ( "ret = %x\n" , retcode ); 91
return retcode ; 92
0
------------------------------
62 /home/speedy/test/source2slice/NVD/CVE_2010_2803_VULN_drm_ioctl.c [u'stack_kdata'] 10
long CVE_2010_2803_VULN_drm_ioctl(struct file *filp,
unsigned int cmd, unsigned long arg) 2
char stack_kdata [ 128 ] ; 10
kdata = stack_kdata; 52
if ( copy_from_user ( kdata , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) != 0 )  63
retcode = func ( dev , kdata , file_priv ); 70
retcode = func ( dev , kdata , file_priv ); 73
if ( copy_to_user ( ( void __user * ) arg , kdata , _IOC_SIZE ( cmd ) ) != 0 )  78
if ( kdata != stack_kdata )  85
kfree ( kdata ); 86
if ( retcode )  88
DRM_DEBUG ( "ret = %x\n" , retcode ); 89
return retcode ; 90
0
------------------------------
63 /home/speedy/test/source2slice/NVD/CVE_2010_3848_PATCHED_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3848_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ 2 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 191
iov [ 0 ] . iov_len = size; 192
iov [ 1 ] . iov_base = userbuf; 200
iov [ 1 ] . iov_len = len; 201
udpmsg . msg_iov = & iov [ 0 ]; 225
udpmsg . msg_iovlen = 2; 226
udpmsg . msg_control = NULL; 227
udpmsg . msg_controllen = 0; 228
udpmsg . msg_flags = 0; 229
err = sock_sendmsg ( udpsock , & udpmsg , size ); 232
return err ; 243
0
------------------------------
64 /home/speedy/test/source2slice/NVD/CVE_2010_3848_VULN_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3848_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ msg -> msg_iovlen + 1 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 194
iov [ 0 ] . iov_len = size; 195
void __user * base = msg -> msg_iov [ i ] . iov_base ; 197
size_t iov_len = msg -> msg_iov [ i ] . iov_len ; 198
if ( ! access_ok ( VERIFY_READ , base , iov_len ) )  200
iov [ i + 1 ] . iov_base = base; 204
iov [ i + 1 ] . iov_len = iov_len; 205
size += iov_len; 206
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
1
------------------------------
65 /home/speedy/test/source2slice/NVD/CVE_2013_4932_PATCHED_elem_tv_short.c [u'buf'] 12
guint16 CVE_2013_4932_PATCHED_elem_tv_short(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar *name_add) 1
char buf [ 10 + 1 ] ; 12
other_decode_bitfield_value ( buf , oct , 0xf0 , 8 ); 37
proto_tree_add_text ( subtree , tvb , curr_offset , 1 , "%s = Element ID: 0x%1x-" , buf , oct >> 4 ); 38
0
------------------------------
66 /home/speedy/test/source2slice/NVD/CVE_2013_4932_VULN_elem_tv_short.c [u'buf'] 11
guint16 CVE_2013_4932_VULN_elem_tv_short(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar *name_add) 1
char buf [ 10 + 1 ] ; 11
other_decode_bitfield_value ( buf , oct , 0xf0 , 8 ); 31
proto_tree_add_text ( subtree , tvb , curr_offset , 1 , "%s = Element ID: 0x%1x-" , buf , oct >> 4 ); 32
0
------------------------------
67 /home/speedy/test/source2slice/NVD/CVE_2013_4933_PATCHED_netmon_open.c [u'magic'] 4
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
if ( bytes_read != sizeof hdr )  36
if ( ( guint32 ) bytes_read != frame_table_length )  174
0
------------------------------
68 /home/speedy/test/source2slice/NVD/CVE_2013_4933_VULN_netmon_open.c [u'magic'] 4
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
if ( bytes_read != sizeof hdr )  36
if ( ( guint32 ) bytes_read != frame_table_length )  170
0
------------------------------
69 /home/speedy/test/source2slice/NVD/CVE_2013_4936_PATCHED_IsDFP_Frame.c [u'virtualFramebuffer'] 11
static gboolean
CVE_2013_4936_PATCHED_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
memcpy ( & virtualFramebuffer [ 0 ] , pinfo -> dst . data , 6 ); 24
memcpy ( & virtualFramebuffer [ 6 ] , pinfo -> src . data , 6 ); 25
virtualFramebuffer [ 12 ] = 0x88; 26
virtualFramebuffer [ 13 ] = 0x92; 27
virtualFramebuffer [ 15 ] = ( unsigned char ) ( u16FrameID & 0xff ); 28
virtualFramebuffer [ 14 ] = ( unsigned char ) ( u16FrameID >> 8 ); 29
crc = crc16_plain_update ( crc , & virtualFramebuffer [ 0 ] , 16 ); 31
crc = crc16_plain_finalize ( crc ); 32
if ( u16SFCRC16 != crc )  37
proto_item_append_text ( tree , ", no packed frame: SFCRC16 is 0x%x should be 0x%x" , u16SFCRC16 , crc ); 39
if ( crc != u16SFCRC16 )  74
0
------------------------------
70 /home/speedy/test/source2slice/NVD/CVE_2013_4936_VULN_IsDFP_Frame.c [u'virtualFramebuffer'] 11
static gboolean
CVE_2013_4936_VULN_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
memcpy ( & virtualFramebuffer [ 0 ] , pinfo -> dst . data , 6 ); 18
memcpy ( & virtualFramebuffer [ 6 ] , pinfo -> src . data , 6 ); 19
virtualFramebuffer [ 12 ] = 0x88; 20
virtualFramebuffer [ 13 ] = 0x92; 21
virtualFramebuffer [ 15 ] = ( unsigned char ) ( u16FrameID & 0xff ); 22
virtualFramebuffer [ 14 ] = ( unsigned char ) ( u16FrameID >> 8 ); 23
crc = crc16_plain_update ( crc , & virtualFramebuffer [ 0 ] , 16 ); 25
crc = crc16_plain_finalize ( crc ); 26
if ( u16SFCRC16 != crc )  31
proto_item_append_text ( tree , ", no packed frame: SFCRC16 is 0x%x should be 0x%x" , u16SFCRC16 , crc ); 33
if ( crc != u16SFCRC16 )  68
0
------------------------------
71 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c [u'totag'] 184
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( sip_cfg . pedanticsipchecking )  170
if ( ! p -> initreq . headers && req -> has_to_tag )  175
if ( ! req -> ignore && req -> method == SIP_INVITE )  177
char totag [ 128 ] ; 184
gettag ( req , "To" , totag , sizeof ( totag ) ); 185
ast_string_field_set ( p , tag , totag ); 186
0
------------------------------
72 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c [u'tag'] 163
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
if ( ast_strlen_zero ( p -> theirtag ) )  162
char tag [ 128 ] ; 163
gettag ( req , "From" , tag , sizeof ( tag ) ); 165
ast_string_field_set ( p , theirtag , tag ); 166
ast_string_field_set ( p , tag , totag ); 186
0
------------------------------
73 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c [u'seconds'] 129
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
0
------------------------------
74 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c [u'totag'] 184
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( sip_cfg . pedanticsipchecking )  170
if ( ! p -> initreq . headers && req -> has_to_tag )  175
if ( ! req -> ignore && req -> method == SIP_INVITE )  177
char totag [ 128 ] ; 184
gettag ( req , "To" , totag , sizeof ( totag ) ); 185
ast_string_field_set ( p , tag , totag ); 186
0
------------------------------
75 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c [u'tag'] 163
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
if ( ast_strlen_zero ( p -> theirtag ) )  162
char tag [ 128 ] ; 163
gettag ( req , "From" , tag , sizeof ( tag ) ); 165
ast_string_field_set ( p , theirtag , tag ); 166
ast_string_field_set ( p , tag , totag ); 186
0
------------------------------
76 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c [u'seconds'] 129
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
0
------------------------------
77 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c [u's2', u's1'] 699
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tsa && tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_format_cap_has_type ( p -> jointcaps , AST_FORMAT_TYPE_AUDIO ) )  697
if ( debug )  698
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] ; 699
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
0
------------------------------
78 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c [u's5', u's4', u's3', u's2', u's1'] 505
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
if ( debug )  503
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] , s3 [ SIPBUFSIZE ] , s4 [ SIPBUFSIZE ] , s5 [ SIPBUFSIZE ] ; 505
ast_verbose ( "Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> caps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , peercapability ) , ast_getformatname_multiple ( s3 , SIPBUFSIZE , vpeercapability ) , ast_getformatname_multiple ( s4 , SIPBUFSIZE , tpeercapability ) , ast_getformatname_multiple ( s5 , SIPBUFSIZE , newjointcapability ) ); 507
ast_verbose ( "Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n" , ast_rtp_lookup_mime_multiple2 ( s1 , NULL , p -> noncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s2 , NULL , peernoncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s3 , NULL , newnoncodeccapability , 0 , 0 ) ); 519
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
0
------------------------------
79 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c [u'buf'] 62
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char buf [ SIPBUFSIZE ] ; 62
ast_debug ( 2 , "We're settling with these formats: %s\n" , ast_getformatname_multiple ( buf , SIPBUFSIZE , p -> jointcaps ) ); 689
0
------------------------------
80 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c [u'red_fmtp'] 58
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char red_fmtp [ 100 ] = "empty" ; 58
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
0
------------------------------
81 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c [u'red_data_pt'] 56
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int red_data_pt [ 10 ] ; 56
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
ast_rtp_red_init ( p -> trtp , 300 , red_data_pt , 2 ); 614
0
------------------------------
82 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c [u's2', u's1'] 699
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_format_cap_has_type ( p -> jointcaps , AST_FORMAT_TYPE_AUDIO ) )  697
if ( debug )  698
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] ; 699
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
1
------------------------------
83 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c [u's5', u's4', u's3', u's2', u's1'] 505
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
if ( debug )  503
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] , s3 [ SIPBUFSIZE ] , s4 [ SIPBUFSIZE ] , s5 [ SIPBUFSIZE ] ; 505
ast_verbose ( "Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> caps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , peercapability ) , ast_getformatname_multiple ( s3 , SIPBUFSIZE , vpeercapability ) , ast_getformatname_multiple ( s4 , SIPBUFSIZE , tpeercapability ) , ast_getformatname_multiple ( s5 , SIPBUFSIZE , newjointcapability ) ); 507
ast_verbose ( "Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n" , ast_rtp_lookup_mime_multiple2 ( s1 , NULL , p -> noncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s2 , NULL , peernoncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s3 , NULL , newnoncodeccapability , 0 , 0 ) ); 519
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
0
------------------------------
84 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c [u'buf'] 62
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char buf [ SIPBUFSIZE ] ; 62
ast_debug ( 2 , "We're settling with these formats: %s\n" , ast_getformatname_multiple ( buf , SIPBUFSIZE , p -> jointcaps ) ); 689
0
------------------------------
85 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c [u'red_fmtp'] 58
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char red_fmtp [ 100 ] = "empty" ; 58
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
0
------------------------------
86 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c [u'red_data_pt'] 56
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int red_data_pt [ 10 ] ; 56
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
ast_rtp_red_init ( p -> trtp , 300 , red_data_pt , 2 ); 614
0
------------------------------
87 /home/speedy/test/source2slice/NVD/CVE_2013_6380_PATCHED_aac_send_raw_srb.c [u'sg_list'] 15
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void * sg_list [ 32 ] ; 15
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  238
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 247
if ( ! p )  248
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 254
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 255
sg_user [ i ] = ( void __user * ) addr; 256
sg_list [ i ] = p; 257
sg_indx = i; 258
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  261
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 267
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 269
byte_count += usg -> sg [ i ] . count; 270
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 271
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  277
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 285
if ( ! p )  286
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 292
sg_list [ i ] = p; 293
sg_indx = i; 294
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  297
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 304
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 307
byte_count += upsg -> sg [ i ] . count; 308
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 309
srbcmd -> count = cpu_to_le32 ( byte_count ); 312
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 313
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
0
------------------------------
88 /home/speedy/test/source2slice/NVD/CVE_2013_6380_PATCHED_aac_send_raw_srb.c [u'sg_user'] 14
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void __user * sg_user [ 32 ] ; 14
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  238
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 247
if ( ! p )  248
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 254
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 255
sg_user [ i ] = ( void __user * ) addr; 256
sg_list [ i ] = p; 257
sg_indx = i; 258
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  261
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 267
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 269
byte_count += usg -> sg [ i ] . count; 270
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 271
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  277
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 285
if ( ! p )  286
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 292
sg_list [ i ] = p; 293
sg_indx = i; 294
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  297
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 304
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 307
byte_count += upsg -> sg [ i ] . count; 308
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 309
srbcmd -> count = cpu_to_le32 ( byte_count ); 312
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 313
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
0
------------------------------
89 /home/speedy/test/source2slice/NVD/CVE_2013_6380_VULN_aac_send_raw_srb.c [u'sg_list'] 15
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void * sg_list [ 32 ] ; 15
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  237
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 246
if ( ! p )  247
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 253
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 254
sg_user [ i ] = ( void __user * ) addr; 255
sg_list [ i ] = p; 256
sg_indx = i; 257
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  260
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 266
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 268
byte_count += usg -> sg [ i ] . count; 269
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 270
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  276
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 284
if ( ! p )  285
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 291
sg_list [ i ] = p; 292
sg_indx = i; 293
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  296
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 303
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 306
byte_count += upsg -> sg [ i ] . count; 307
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 308
srbcmd -> count = cpu_to_le32 ( byte_count ); 311
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 312
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
0
------------------------------
90 /home/speedy/test/source2slice/NVD/CVE_2013_6380_VULN_aac_send_raw_srb.c [u'sg_user'] 14
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void __user * sg_user [ 32 ] ; 14
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  237
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 246
if ( ! p )  247
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 253
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 254
sg_user [ i ] = ( void __user * ) addr; 255
sg_list [ i ] = p; 256
sg_indx = i; 257
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  260
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 266
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 268
byte_count += usg -> sg [ i ] . count; 269
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 270
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  276
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 284
if ( ! p )  285
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 291
sg_list [ i ] = p; 292
sg_indx = i; 293
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  296
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 303
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 306
byte_count += upsg -> sg [ i ] . count; 307
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 308
srbcmd -> count = cpu_to_le32 ( byte_count ); 311
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 312
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
0
------------------------------
91 /home/speedy/test/source2slice/NVD/CVE_2013_6671_PATCHED_nsHtml5TreeOperation__Perform.c [u'params'] 562
nsresult
CVE_2013_6671_PATCHED_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
if ( atom )  561
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) } ; 562
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 563
NS_ENSURE_SUCCESS ( rv , rv ); 565
return rv ; 581
return rv ; 587
0
------------------------------
92 /home/speedy/test/source2slice/NVD/CVE_2013_6671_PATCHED_nsHtml5TreeOperation__Perform.c [u'params'] 556
nsresult
CVE_2013_6671_PATCHED_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) , otherAtom -> GetUTF16String ( ) } ; 556
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 558
NS_ENSURE_SUCCESS ( rv , rv ); 560
return rv ; 581
return rv ; 587
0
------------------------------
93 /home/speedy/test/source2slice/NVD/CVE_2013_6671_VULN_nsHtml5TreeOperation__Perform.c [u'params'] 562
nsresult
CVE_2013_6671_VULN_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
if ( atom )  561
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) } ; 562
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 563
NS_ENSURE_SUCCESS ( rv , rv ); 565
return rv ; 581
return rv ; 587
0
------------------------------
94 /home/speedy/test/source2slice/NVD/CVE_2013_6671_VULN_nsHtml5TreeOperation__Perform.c [u'params'] 556
nsresult
CVE_2013_6671_VULN_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) , otherAtom -> GetUTF16String ( ) } ; 556
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 558
NS_ENSURE_SUCCESS ( rv , rv ); 560
return rv ; 581
return rv ; 587
0
------------------------------
95 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c [u'id_list'] 638
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
h -> list_count = 1; 479
h -> list_count = 0; 481
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & h -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
h -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & h -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
for (j = 0; j < 2; j++) 637
int id_list [ 16 ] ; 638
id_list [ i ] = 60; 641
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
id_list [ i ] = k; 647
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
0
------------------------------
96 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c [u'max'] 454
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
av_log ( h -> avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 471
0
------------------------------
97 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c [u'id_list'] 638
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
h -> list_count = 1; 479
h -> list_count = 0; 481
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & h -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
h -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & h -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
for (j = 0; j < 2; j++) 637
int id_list [ 16 ] ; 638
id_list [ i ] = 60; 641
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
id_list [ i ] = k; 647
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
for (i = 0; i < 16; i++) 660
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
0
------------------------------
98 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c [u'max'] 454
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
av_log ( h -> avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 471
0
------------------------------
99 /home/speedy/test/source2slice/NVD/CVE_2013_7009_PATCHED_rpza_decode_stream.c [u'color4'] 11
static void CVE_2013_7009_PATCHED_rpza_decode_stream(RpzaContext *s) 1
unsigned short color4 [ 4 ] ; 11
color4 [ 0 ] = colorB; 94
color4 [ 1 ] = 0; 95
color4 [ 2 ] = 0; 96
color4 [ 3 ] = colorA; 97
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10; 102
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10; 103
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5; 108
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5; 109
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ); 114
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ); 115
pixels [ block_ptr ] = color4 [ idx ]; 126
block_ptr ++; 127
block_ptr += row_inc; 129
pixels [ block_ptr ] = colorA; 147
block_ptr ++; 148
block_ptr += row_inc; 150
0
------------------------------
100 /home/speedy/test/source2slice/NVD/CVE_2013_7009_VULN_rpza_decode_stream.c [u'color4'] 11
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s) 1
unsigned short color4 [ 4 ] ; 11
color4 [ 0 ] = colorB; 94
color4 [ 1 ] = 0; 95
color4 [ 2 ] = 0; 96
color4 [ 3 ] = colorA; 97
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10; 102
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10; 103
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5; 108
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5; 109
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ); 114
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ); 115
pixels [ block_ptr ] = color4 [ idx ]; 125
block_ptr ++; 126
block_ptr += row_inc; 128
pixels [ block_ptr ] = colorA; 146
block_ptr ++; 147
block_ptr += row_inc; 149
0
------------------------------
101 /home/speedy/test/source2slice/NVD/CVE_2013_7011_PATCHED_read_header.c [u'state'] 3
static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 11
if ( v >= 2 )  12
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 13
f -> version = v; 16
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 17
if ( f -> ac > 1 )  18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 20
f -> colorspace = get_symbol ( c , state , 0 ); 23
if ( f -> version > 0 )  25
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 26
chroma_planes = get_rac ( c , state ); 28
chroma_h_shift = get_symbol ( c , state , 0 ); 29
chroma_v_shift = get_symbol ( c , state , 0 ); 30
transparency = get_rac ( c , state ); 31
if ( f -> plane_count )  33
if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  34
av_log ( f -> avctx , AV_LOG_ERROR , "Invalid change of global parameters\n" ); 38
f -> chroma_planes = chroma_planes; 43
f -> chroma_h_shift = chroma_h_shift; 44
f -> chroma_v_shift = chroma_v_shift; 45
f -> transparency = transparency; 46
f -> plane_count = 2 + f -> transparency; 48
if ( f -> colorspace == 0 )  51
if ( ! f -> transparency && ! f -> chroma_planes )  52
if ( f -> avctx -> bits_per_raw_sample <= 8 )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 56
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  57
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  58
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 59
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 60
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 61
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 62
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 64
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 66
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  69
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  70
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 71
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 72
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 73
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 75
if ( f -> avctx -> bits_per_raw_sample == 9 )  78
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  80
if ( f -> avctx -> bits_per_raw_sample == 10 )  88
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  90
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 100
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 101
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 102
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 104
if ( f -> colorspace == 1 )  108
if ( f -> chroma_h_shift || f -> chroma_v_shift )  109
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 110
if ( f -> avctx -> bits_per_raw_sample == 9 )  114
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 115
if ( f -> avctx -> bits_per_raw_sample == 10 )  116
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 117
if ( f -> avctx -> bits_per_raw_sample == 12 )  118
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 119
if ( f -> avctx -> bits_per_raw_sample == 14 )  120
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 121
if ( f -> transparency )  123
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 123
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 124
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 126
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 130
if ( f -> version < 2 )  132
context_count = read_quant_tables ( c , f -> quant_table ); 133
if ( context_count < 0 )  134
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 135
if ( f -> version < 3 )  138
f -> slice_count = get_symbol ( c , state , 0 ); 139
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  152
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 153
for (j = 0; j < f->slice_count; j++) 157
FFV1Context * fs = f -> slice_context [ j ] ; 158
fs -> ac = f -> ac; 159
fs -> packed_at_lsb = f -> packed_at_lsb; 160
fs -> slice_damaged = 0; 162
if ( f -> version == 2 )  164
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 165
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 166
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 167
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 168
fs -> slice_x /= f -> num_h_slices; 170
fs -> slice_y /= f -> num_v_slices; 171
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 172
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 173
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  174
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  177
for (i = 0; i < f->plane_count; i++) 182
PlaneContext * const p = & fs -> plane [ i ] 183
if ( f -> version == 2 )  185
int idx = get_symbol ( c , state , 0 ) ; 186
if ( idx > ( unsigned ) f -> quant_table_count )  187
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 188
p -> quant_table_index = idx; 192
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 193
context_count = f -> context_count [ idx ]; 195
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 197
if ( f -> version <= 2 )  200
av_assert0 ( context_count >= 0 ); 201
if ( p -> context_count < context_count )  202
av_freep ( & p -> state ); 203
av_freep ( & p -> vlc_state ); 204
p -> context_count = context_count; 206
0
------------------------------
102 /home/speedy/test/source2slice/NVD/CVE_2013_7011_VULN_read_header.c [u'state'] 3
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 12
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 49
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 58
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 87
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 93
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 109
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 113
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 118
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 136
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 171
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
av_assert0 ( context_count >= 0 ); 184
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
1
------------------------------
103 /home/speedy/test/source2slice/NVD/CVE_2014_0221_PATCHED_dtls1_get_message_fragment.c [u'wire'] 4
static long
CVE_2014_0221_PATCHED_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 18
if ( i <= 0 )  20
return i ; 24
if ( i != DTLS1_HM_HEADER_LENGTH )  27
dtls1_get_message_header ( wire , & msg_hdr ); 35
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  53
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  60
s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , s , s -> msg_callback_arg ); 63
0
------------------------------
104 /home/speedy/test/source2slice/NVD/CVE_2014_0221_VULN_dtls1_get_message_fragment.c [u'wire'] 4
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
return i ; 23
if ( i != DTLS1_HM_HEADER_LENGTH )  26
dtls1_get_message_header ( wire , & msg_hdr ); 34
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  59
s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , s , s -> msg_callback_arg ); 62
if ( i <= 0 )  91
return i ; 95
if ( i != ( int ) frag_len )  103
0
------------------------------
105 /home/speedy/test/source2slice/NVD/CVE_2014_1497_PATCHED_WaveReader__LoadFormatChunk.c [u'chunkExtension'] 63
bool
CVE_2014_1497_PATCHED_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
p += 4; 32
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
nsAutoArrayPtr < char > chunkExtension ( new char [ extra ] ) ; 63
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
0
------------------------------
106 /home/speedy/test/source2slice/NVD/CVE_2014_1497_PATCHED_WaveReader__LoadFormatChunk.c [u'extLength'] 44
bool
CVE_2014_1497_PATCHED_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
const char * p = extLength ; 45
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
0
------------------------------
107 /home/speedy/test/source2slice/NVD/CVE_2014_1497_PATCHED_WaveReader__LoadFormatChunk.c [u'waveFormat'] 5
bool
CVE_2014_1497_PATCHED_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
p += 4; 32
frameSize = ReadUint16LE ( & p ); 34
sampleFormat = ReadUint16LE ( & p ); 36
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
unsigned int actualFrameSize = ( sampleFormat == 8 ? 1 : 2 ) * channels ; 78
if ( rate < 100 || rate > 96000 || ( ( ( channels < 1 || channels > MAX_CHANNELS ) || ( frameSize != 1 && frameSize != 2 && frameSize != 4 ) ) && ! mIgnoreAudioOutputFormat ) || ( sampleFormat != 8 && sampleFormat != 16 ) || frameSize != actualFrameSize )  79
mFrameSize = frameSize; 92
if ( sampleFormat == 8 )  93
0
------------------------------
108 /home/speedy/test/source2slice/NVD/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'chunkExtension'] 63
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
p += 4; 32
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
nsAutoArrayPtr < char > chunkExtension ( new char [ extra ] ) ; 63
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
0
------------------------------
109 /home/speedy/test/source2slice/NVD/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'extLength'] 44
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
const char * p = extLength ; 45
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
0
------------------------------
110 /home/speedy/test/source2slice/NVD/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'waveFormat'] 5
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
p += 4; 32
frameSize = ReadUint16LE ( & p ); 34
sampleFormat = ReadUint16LE ( & p ); 36
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
unsigned int actualFrameSize = sampleFormat == 8 ? 1 : 2 * channels ; 78
if ( rate < 100 || rate > 96000 || ( ( ( channels < 1 || channels > MAX_CHANNELS ) || ( frameSize != 1 && frameSize != 2 && frameSize != 4 ) ) && ! mIgnoreAudioOutputFormat ) || ( sampleFormat != 8 && sampleFormat != 16 ) || frameSize != actualFrameSize )  79
mFrameSize = frameSize; 92
if ( sampleFormat == 8 )  93
1
------------------------------
111 /home/speedy/test/source2slice/NVD/CVE_2014_1508_PATCHED_nsDisplayNotation__Paint.c [u'p'] 60
void CVE_2014_1508_PATCHED_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , MOZ_ARRAY_LENGTH ( p ) ); 67
0
------------------------------
112 /home/speedy/test/source2slice/NVD/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c [u'p'] 60
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
1
------------------------------
113 /home/speedy/test/source2slice/NVD/CVE_2014_1690_PATCHED_help.c [u'buffer'] 8
static unsigned int CVE_2014_1690_PATCHED_help(struct sk_buff *skb,
enum ip_conntrack_info ctinfo,
unsigned int protoff,
unsigned int matchoff,
unsigned int matchlen,
struct nf_conntrack_expect *exp) 6
char buffer [ sizeof ( "4294967296 65635" ) ] ; 8
snprintf ( buffer , sizeof ( buffer ) , "%u %u" , ntohl ( newaddr . ip ) , port ); 54
pr_debug ( "nf_nat_irc: inserting '%s' == %pI4, port %u\n" , buffer , & newaddr . ip , port ); 55
ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ); 58
if ( ret != NF_ACCEPT )  60
return ret ; 65
0
------------------------------
114 /home/speedy/test/source2slice/NVD/CVE_2014_1690_VULN_help.c [u'buffer'] 8
static unsigned int CVE_2014_1690_VULN_help(struct sk_buff *skb,
enum ip_conntrack_info ctinfo,
unsigned int protoff,
unsigned int matchoff,
unsigned int matchlen,
struct nf_conntrack_expect *exp) 6
char buffer [ sizeof ( "4294967296 65635" ) ] ; 8
ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ); 36
if ( ret != NF_ACCEPT )  39
return ret ; 43
1
------------------------------
115 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_httpd_helper_thread.c [u'header_line'] 4
static void *CVE_2014_2286_PATCHED_httpd_helper_thread(void *data) 1
char header_line [ 4096 ] ; 4
while ( fgets ( header_line , sizeof ( header_line ) , ser -> f ) )  52
ast_trim_blanks ( header_line ); 56
if ( ast_strlen_zero ( header_line ) )  57
value = header_line; 61
name = strsep ( & value , ":" ); 62
if ( ! value )  63
value = ast_skip_blanks ( value ); 67
if ( ast_strlen_zero ( value ) || ast_strlen_zero ( name ) )  68
ast_trim_blanks ( name ); 72
if ( ! headers )  79
headers = ast_variable_new ( name , value , __FILE__ ); 80
tail = headers; 81
tail -> next = ast_variable_new ( name , value , __FILE__ ); 83
tail = tail -> next; 84
if ( ! tail )  86
ast_variables_destroy ( headers ); 91
handle_uri ( ser , uri , http_method , headers ); 99
ast_variables_destroy ( headers ); 105
0
------------------------------
116 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_httpd_helper_thread.c [u'buf'] 3
static void *CVE_2014_2286_PATCHED_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  16
method = ast_skip_blanks ( buf ); 21
uri = ast_skip_nonblanks ( method ); 22
if ( * uri )  23
* uri ++ = '\0'; 24
if ( ! strcasecmp ( method , "GET" ) )  27
if ( ! strcasecmp ( method , "POST" ) )  29
if ( ! strcasecmp ( method , "HEAD" ) )  31
if ( ! strcasecmp ( method , "PUT" ) )  33
uri = ast_skip_blanks ( uri ); 37
if ( * uri )  39
char * c = ast_skip_nonblanks ( uri ) ; 40
if ( * c )  42
* c = '\0'; 43
handle_uri ( ser , uri , http_method , headers ); 99
0
------------------------------
117 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_httpd_helper_thread.c [u'header_line'] 4
static void *CVE_2014_2286_VULN_httpd_helper_thread(void *data) 1
char header_line [ 4096 ] ; 4
while ( fgets ( header_line , sizeof ( header_line ) , ser -> f ) )  47
ast_trim_blanks ( header_line ); 51
if ( ast_strlen_zero ( header_line ) )  52
value = header_line; 56
name = strsep ( & value , ":" ); 57
if ( ! value )  58
value = ast_skip_blanks ( value ); 62
if ( ast_strlen_zero ( value ) || ast_strlen_zero ( name ) )  63
ast_trim_blanks ( name ); 67
if ( ! headers )  69
headers = ast_variable_new ( name , value , __FILE__ ); 70
tail = headers; 71
tail -> next = ast_variable_new ( name , value , __FILE__ ); 73
tail = tail -> next; 74
handle_uri ( ser , uri , http_method , headers ); 83
if ( headers )  89
ast_variables_destroy ( headers ); 90
1
------------------------------
118 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_httpd_helper_thread.c [u'buf'] 3
static void *CVE_2014_2286_VULN_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  15
method = ast_skip_blanks ( buf ); 20
uri = ast_skip_nonblanks ( method ); 21
if ( * uri )  22
* uri ++ = '\0'; 23
if ( ! strcasecmp ( method , "GET" ) )  26
if ( ! strcasecmp ( method , "POST" ) )  28
if ( ! strcasecmp ( method , "HEAD" ) )  30
if ( ! strcasecmp ( method , "PUT" ) )  32
uri = ast_skip_blanks ( uri ); 36
if ( * uri )  38
char * c = ast_skip_nonblanks ( uri ) ; 39
if ( * c )  41
* c = '\0'; 42
if ( ! * uri )  78
handle_uri ( ser , uri , http_method , headers ); 83
1
------------------------------
119 /home/speedy/test/source2slice/NVD/CVE_2014_2739_VULN_cma_req_handler.c [u'alt_smac'] 7
static int CVE_2014_2739_VULN_cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event) 1
u8 alt_smac [ ETH_ALEN ] ; 7
u8 * palt_smac = alt_smac ; 9
rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ); 67
ib_update_cm_av ( cm_id , psmac , palt_smac ); 79
1
------------------------------
120 /home/speedy/test/source2slice/NVD/CVE_2014_2739_VULN_cma_req_handler.c [u'smac'] 6
static int CVE_2014_2739_VULN_cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event) 1
u8 smac [ ETH_ALEN ] ; 6
u8 * psmac = smac ; 8
rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ); 61
ib_update_cm_av ( cm_id , psmac , palt_smac ); 79
1
------------------------------
121 /home/speedy/test/source2slice/NVD/CVE_2014_2889_PATCHED_bpf_jit_compile.c [u'temp'] 3
void CVE_2014_2889_PATCHED_bpf_jit_compile(struct sk_filter *fp) 1
u8 temp [ 64 ] ; 3
0
------------------------------
122 /home/speedy/test/source2slice/NVD/CVE_2014_2889_VULN_bpf_jit_compile.c [u'temp'] 3
void CVE_2014_2889_VULN_bpf_jit_compile(struct sk_filter *fp) 1
u8 temp [ 64 ] ; 3
0
------------------------------
123 /home/speedy/test/source2slice/NVD/CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device.c [u'tmpstr'] 14
static void CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
unsigned char tmpstr [ 3 ] ; 14
snprintf ( tmpstr , sizeof ( tmpstr ) , ":%d" , dj_report -> device_index ); 49
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 50
0
------------------------------
124 /home/speedy/test/source2slice/NVD/CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device.c [u'tmpstr'] 14
static void CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
unsigned char tmpstr [ 3 ] ; 14
snprintf ( tmpstr , sizeof ( tmpstr ) , ":%d" , dj_report -> device_index ); 56
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 57
0
------------------------------
125 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c [u'v'] 22
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
int v [ 2 ] ; 22
v [ 0 ] = v [ 1 ] = 0; 27
v [ 0 ] = p [ 3 ]; 45
v [ 1 ] = p [ 4 ]; 45
v [ 0 ] = p [ 3 ]; 52
v [ 1 ] = p [ 4 ]; 52
v [ 0 ] = p [ 1 ]; 107
v [ 1 ] = 0xff; 127
v [ 1 ] = p [ 10 ]; 129
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  130
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  132
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  138
v [ 0 ] = p [ 3 ]; 203
v [ 1 ] = p [ 4 ]; 204
* ( d ++ ) = v [ 1 ]; 262
memset ( d , 0 , SSL3_RANDOM_SIZE ); 267
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 268
d += SSL3_RANDOM_SIZE; 269
* ( d ++ ) = 0; 272
dd = d; 276
d += 2; 277
* ( d ++ ) = p [ i + 1 ]; 281
* ( d ++ ) = p [ i + 2 ]; 282
s2n ( j , dd ); 285
* ( d ++ ) = 1; 288
* ( d ++ ) = 0; 289
while ( p < s -> packet + s -> packet_length )  294
* ( d ++ ) = * ( p ++ ); 296
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 300
l2n3 ( ( long ) i , d_len ); 301
s -> s3 -> tmp . message_size = i; 306
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  364
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 367
s -> rstate = SSL_ST_READ_HEADER; 373
s -> packet_length = n; 374
if ( s -> s3 -> rbuf . buf == NULL )  375
if ( ! ssl3_setup_read_buffer ( s ) )  376
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 379
memcpy ( s -> packet , buf , n ); 380
s -> s3 -> rbuf . left = n; 381
s -> s3 -> rbuf . offset = 0; 382
s -> s3 -> rbuf . left = 0; 387
s -> s3 -> rbuf . offset = 0; 388
if ( s -> version == TLS1_2_VERSION )  390
s -> method = TLSv1_2_server_method ( ); 391
if ( s -> version == TLS1_1_VERSION )  392
if ( s -> version == TLS1_VERSION )  394
s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ]; 399
s -> handshake_func = s -> method -> ssl_accept; 401
s -> init_num = 0; 410
return ( SSL_accept ( s ) ) ; 413
0
------------------------------
126 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c [u'buf_space'] 3
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
return ( n ) ; 32
memcpy ( buf , p , n ); 36
s -> packet_length = n; 374
if ( s -> s3 -> rbuf . buf == NULL )  375
if ( ! ssl3_setup_read_buffer ( s ) )  376
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 379
memcpy ( s -> packet , buf , n ); 380
s -> s3 -> rbuf . left = n; 381
s -> s3 -> rbuf . offset = 0; 382
if ( s -> version == TLS1_2_VERSION )  390
if ( s -> version == TLS1_1_VERSION )  392
if ( s -> version == TLS1_VERSION )  394
s -> handshake_func = s -> method -> ssl_accept; 401
s -> init_num = 0; 410
if ( buf != buf_space )  412
OPENSSL_free ( buf ); 412
return ( SSL_accept ( s ) ) ; 413
if ( buf != buf_space )  415
OPENSSL_free ( buf ); 415
0
------------------------------
127 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c [u'v'] 22
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
int v [ 2 ] ; 22
v [ 0 ] = v [ 1 ] = 0; 27
v [ 0 ] = p [ 3 ]; 45
v [ 1 ] = p [ 4 ]; 45
v [ 0 ] = p [ 3 ]; 52
v [ 1 ] = p [ 4 ]; 52
v [ 0 ] = p [ 1 ]; 107
v [ 1 ] = 0xff; 131
v [ 1 ] = p [ 10 ]; 133
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  134
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  136
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  142
v [ 0 ] = p [ 3 ]; 207
v [ 1 ] = p [ 4 ]; 208
* ( d ++ ) = v [ 1 ]; 246
memset ( d , 0 , SSL3_RANDOM_SIZE ); 251
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 252
d += SSL3_RANDOM_SIZE; 253
* ( d ++ ) = 0; 256
dd = d; 260
d += 2; 261
* ( d ++ ) = p [ i + 1 ]; 265
* ( d ++ ) = p [ i + 2 ]; 266
s2n ( j , dd ); 269
* ( d ++ ) = 1; 272
* ( d ++ ) = 0; 273
while ( p < s -> packet + s -> packet_length )  278
* ( d ++ ) = * ( p ++ ); 280
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 284
l2n3 ( ( long ) i , d_len ); 285
s -> s3 -> tmp . message_size = i; 290
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  348
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 351
s -> rstate = SSL_ST_READ_HEADER; 357
s -> packet_length = n; 358
if ( s -> s3 -> rbuf . buf == NULL )  359
if ( ! ssl3_setup_read_buffer ( s ) )  360
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 363
memcpy ( s -> packet , buf , n ); 364
s -> s3 -> rbuf . left = n; 365
s -> s3 -> rbuf . offset = 0; 366
s -> s3 -> rbuf . left = 0; 371
s -> s3 -> rbuf . offset = 0; 372
if ( s -> version == TLS1_2_VERSION )  374
s -> method = TLSv1_2_server_method ( ); 375
if ( s -> version == TLS1_1_VERSION )  376
if ( s -> version == TLS1_VERSION )  378
s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ]; 383
s -> handshake_func = s -> method -> ssl_accept; 385
s -> init_num = 0; 394
return ( SSL_accept ( s ) ) ; 397
0
------------------------------
128 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c [u'buf_space'] 3
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
return ( n ) ; 32
memcpy ( buf , p , n ); 36
if ( n > ( 1024 * 4 ) )  211
j = ssl23_read_bytes ( s , n + 2 ); 217
if ( j <= 0 )  218
return ( j ) ; 218
j += 2; 267
s2n ( j , dd ); 269
s -> packet_length = n; 358
if ( s -> s3 -> rbuf . buf == NULL )  359
if ( ! ssl3_setup_read_buffer ( s ) )  360
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 363
memcpy ( s -> packet , buf , n ); 364
s -> s3 -> rbuf . left = n; 365
s -> s3 -> rbuf . offset = 0; 366
if ( s -> version == TLS1_2_VERSION )  374
if ( s -> version == TLS1_1_VERSION )  376
if ( s -> version == TLS1_VERSION )  378
s -> handshake_func = s -> method -> ssl_accept; 385
s -> init_num = 0; 394
if ( buf != buf_space )  396
OPENSSL_free ( buf ); 396
return ( SSL_accept ( s ) ) ; 397
if ( buf != buf_space )  399
OPENSSL_free ( buf ); 399
0
------------------------------
129 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c [u'events'] 28
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
HANDLE events [ 3 ] ; 28
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
CloseHandle ( events [ 2 ] ); 114
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
ap_log_error ( APLOG_MARK , APLOG_ERR , rv , ap_server_conf , APLOGNO ( 0033 9 )
"Child: Encountered too many AcceptEx "
"faults accepting client connections." )
ap_log_error ( APLOG_MARK , APLOG_NOTICE , rv , ap_server_conf , APLOGNO ( 00340 )
"winnt_mpm: falling back to "
"'AcceptFilter none'." ) 247
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
ap_log_error ( APLOG_MARK , APLOG_DEBUG ,
rv , ap_server_conf , APLOGNO ( 00343 )
"accept() failed, retrying." ) 373
ap_log_error ( APLOG_MARK , APLOG_WARNING ,
rv , ap_server_conf , APLOGNO ( 00344 )
"accept() failed." ) 380
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
ap_log_error ( APLOG_MARK , APLOG_ERR , rv , ap_server_conf , APLOGNO ( 00345 )
"Child: Encountered too many accept() "
"resource faults, aborting." ) 390
CloseHandle ( events [ 2 ] ); 448
0
------------------------------
130 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c [u'events'] 28
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
HANDLE events [ 3 ] ; 28
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
CloseHandle ( events [ 2 ] ); 114
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 341
while ( rv == WAIT_IO_COMPLETION )  342
if ( rv != WAIT_OBJECT_0 + 2 )  345
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  364
ap_log_error ( APLOG_MARK , APLOG_DEBUG ,
rv , ap_server_conf , APLOGNO ( 00343 )
"accept() failed, retrying." ) 369
ap_log_error ( APLOG_MARK , APLOG_WARNING ,
rv , ap_server_conf , APLOGNO ( 00344 )
"accept() failed." ) 376
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  378
ap_log_error ( APLOG_MARK , APLOG_ERR , rv , ap_server_conf , APLOGNO ( 00345 )
"Child: Encountered too many accept() "
"resource faults, aborting." ) 386
CloseHandle ( events [ 2 ] ); 444
0
------------------------------
131 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c [u'language'] 12
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
cupsdLogClient ( con , CUPSD_LOG_INFO , "Symlinks such as \"%s\" are not allowed." , filename ); 91
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
cupsdLogClient ( con , CUPSD_LOG_INFO , "Files/directories such as \"%s\" must be world-readable." , filename ); 102
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
if ( language [ 3 ] )  131
language [ 0 ] = '\0'; 132
language [ 0 ] = '\0'; 134
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
0
------------------------------
132 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c [u'language'] 12
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
if ( language [ 3 ] )  110
language [ 0 ] = '\0'; 111
language [ 0 ] = '\0'; 113
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
1
------------------------------
133 /home/speedy/test/source2slice/NVD/CVE_2014_3633_PATCHED_qemuDomainGetBlockIoTune.c [u'uuidstr'] 13
static int
CVE_2014_3633_PATCHED_qemuDomainGetBlockIoTune(virDomainPtr dom,
const char *disk,
virTypedParameterPtr params,
int *nparams,
unsigned int flags) 6
char uuidstr [ VIR_UUID_STRING_BUFLEN ] ; 13
virUUIDFormat ( dom -> uuid , uuidstr ); 26
virReportError ( VIR_ERR_NO_DOMAIN , _ ( "no domain with matching uuid '%s'" ) , uuidstr ); 29
0
------------------------------
134 /home/speedy/test/source2slice/NVD/CVE_2014_3633_VULN_qemuDomainGetBlockIoTune.c [u'uuidstr'] 13
static int
CVE_2014_3633_VULN_qemuDomainGetBlockIoTune(virDomainPtr dom,
const char *disk,
virTypedParameterPtr params,
int *nparams,
unsigned int flags) 6
char uuidstr [ VIR_UUID_STRING_BUFLEN ] ; 13
virUUIDFormat ( dom -> uuid , uuidstr ); 26
virReportError ( VIR_ERR_NO_DOMAIN , _ ( "no domain with matching uuid '%s'" ) , uuidstr ); 29
0
------------------------------
135 /home/speedy/test/source2slice/NVD/CVE_2014_5161_PATCHED_dissect_log.c [u'buf'] 14
static void CVE_2014_5161_PATCHED_dissect_log(tvbuff_t* tvb, packet_info* pinfo, proto_tree* root) 1
if ( pinfo -> pseudo_header -> irda . pkttype == IRDA_MISSED_MSG )  7
char buf [ 256 ] ; 14
tvb_memcpy ( tvb , buf , 0 , length ); 20
buf [ length ] = 0; 21
if ( length > 0 && buf [ length - 1 ] == '\n' )  22
buf [ length - 1 ] = 0; 23
if ( length > 1 && buf [ length - 2 ] == '\n' )  24
buf [ length - 2 ] = 0; 25
col_add_str ( pinfo -> cinfo , COL_INFO , buf ); 27
0
------------------------------
136 /home/speedy/test/source2slice/NVD/CVE_2014_5161_VULN_dissect_log.c [u'buf'] 14
static void CVE_2014_5161_VULN_dissect_log(tvbuff_t* tvb, packet_info* pinfo, proto_tree* root) 1
if ( pinfo -> pseudo_header -> irda . pkttype == IRDA_MISSED_MSG )  7
char buf [ 256 ] ; 14
tvb_memcpy ( tvb , buf , 0 , length ); 20
buf [ length ] = 0; 21
if ( buf [ length - 1 ] == '\n' )  22
buf [ length - 1 ] = 0; 23
if ( buf [ length - 2 ] == '\n' )  24
buf [ length - 2 ] = 0; 25
col_add_str ( pinfo -> cinfo , COL_INFO , buf ); 27
1
------------------------------
137 /home/speedy/test/source2slice/NVD/CVE_2014_5163_PATCHED_decode_apn.c [u'str'] 4
static void
CVE_2014_5163_PATCHED_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH + 1 ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
0
------------------------------
138 /home/speedy/test/source2slice/NVD/CVE_2014_5163_VULN_decode_apn.c [u'str'] 4
static void
CVE_2014_5163_VULN_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
1
------------------------------
139 /home/speedy/test/source2slice/NVD/CVE_2014_5271_PATCHED_encode_frame.c [u'sizes'] 9
static int CVE_2014_5271_PATCHED_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
const AVFrame *pic, int *got_packet) 2
int sizes [ 4 ] = { 0 } ; 9
picture_size_pos = buf + 1; 67
buf += 4; 69
bytestream_put_be16 ( & buf , ctx -> slices_per_picture ); 70
bytestream_put_byte ( & buf , av_log2 ( ctx -> mbs_per_slice ) << 4 ); 71
slice_sizes = buf; 74
buf += ctx -> slices_per_picture * 2; 75
bytestream_put_byte ( & buf , slice_hdr_size << 3 ); 94
slice_hdr = buf; 95
buf += slice_hdr_size - 1; 96
init_put_bits ( & pb , buf , ( pkt_size - ( buf - orig_buf ) ) * 8 ); 97
ret = encode_slice ( avctx , pic , & pb , sizes , x , y , q , mbs_per_slice ); 98
if ( ret < 0 )  99
return ret ; 100
bytestream_put_byte ( & slice_hdr , q ); 102
slice_size = slice_hdr_size + sizes [ ctx -> num_planes - 1 ]; 103
bytestream_put_be16 ( & slice_hdr , sizes [ i ] ); 105
slice_size += sizes [ i ]; 106
bytestream_put_be16 ( & slice_sizes , slice_size ); 108
buf += slice_size - slice_hdr_size; 109
picture_size = buf - ( picture_size_pos - 1 ); 113
bytestream_put_be32 ( & picture_size_pos , picture_size ); 114
frame_size = buf - orig_buf; 118
bytestream_put_be32 ( & orig_buf , frame_size ); 119
pkt -> size = frame_size; 121
pkt -> flags |= AV_PKT_FLAG_KEY; 122
0
------------------------------
140 /home/speedy/test/source2slice/NVD/CVE_2014_5271_VULN_encode_frame.c [u'sizes'] 9
static int CVE_2014_5271_VULN_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
const AVFrame *pic, int *got_packet) 2
int sizes [ 4 ] = { 0 } ; 9
picture_size_pos = buf + 1; 67
buf += 4; 69
bytestream_put_be16 ( & buf , ctx -> slices_per_picture ); 70
bytestream_put_byte ( & buf , av_log2 ( ctx -> mbs_per_slice ) << 4 ); 71
slice_sizes = buf; 74
buf += ctx -> slices_per_picture * 2; 75
bytestream_put_byte ( & buf , slice_hdr_size << 3 ); 94
slice_hdr = buf; 95
buf += slice_hdr_size - 1; 96
init_put_bits ( & pb , buf , ( pkt_size - ( buf - orig_buf ) ) * 8 ); 97
encode_slice ( avctx , pic , & pb , sizes , x , y , q , mbs_per_slice ); 98
bytestream_put_byte ( & slice_hdr , q ); 100
slice_size = slice_hdr_size + sizes [ ctx -> num_planes - 1 ]; 101
bytestream_put_be16 ( & slice_hdr , sizes [ i ] ); 103
slice_size += sizes [ i ]; 104
bytestream_put_be16 ( & slice_sizes , slice_size ); 106
buf += slice_size - slice_hdr_size; 107
picture_size = buf - ( picture_size_pos - 1 ); 111
bytestream_put_be32 ( & picture_size_pos , picture_size ); 112
frame_size = buf - orig_buf; 116
bytestream_put_be32 ( & orig_buf , frame_size ); 117
pkt -> size = frame_size; 119
pkt -> flags |= AV_PKT_FLAG_KEY; 120
1
------------------------------
141 /home/speedy/test/source2slice/NVD/CVE_2015_0228_PATCHED_lua_websocket_read.c [u'frame'] 146
static int CVE_2015_0228_PATCHED_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
int do_read = 1 ; 5
unsigned short payload_short = 0 ; 9
unsigned char * mask_bytes ; 11
char byte ; 12
int plaintext ; 13
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 16
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 17
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 20
sock = ap_get_conn_socket ( r -> connection ); 21
while ( do_read )  23
do_read = 0; 24
if ( plaintext )  26
rv = apr_socket_recv ( sock , & byte , & len ); 27
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 30
if ( rv == APR_SUCCESS )  32
unsigned char fin , opcode , mask , payload ; 33
opcode = ( byte << 4 ) >> 4; 35
if ( plaintext )  38
rv = apr_socket_recv ( sock , & byte , & len ); 39
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 42
if ( rv == APR_SUCCESS )  44
mask = byte >> 7; 45
payload = byte - 128; 46
plen = payload; 47
if ( payload == 126 )  50
len = 2; 51
if ( plaintext )  52
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 53
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 56
payload_short = ntohs ( payload_short ); 59
if ( rv == APR_SUCCESS )  61
plen = payload_short; 62
if ( payload == 127 )  69
len = 8; 70
if ( plaintext )  71
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 72
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 75
if ( rv == APR_SUCCESS )  78
plen = ap_ntoh64 ( & payload_long ); 79
if ( mask )  91
len = 4; 92
if ( plaintext )  93
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 94
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 97
if ( rv != APR_SUCCESS )  100
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  104
if ( opcode == 0x09 )  145
char frame [ 2 ] ; 146
frame [ 0 ] = 0x8A; 148
frame [ 1 ] = 0; 149
apr_socket_send ( sock , frame , & plen ); 150
do_read = 1; 151
0
------------------------------
142 /home/speedy/test/source2slice/NVD/CVE_2015_0228_VULN_lua_websocket_read.c [u'frame'] 143
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
char frame [ 2 ] ; 143
frame [ 0 ] = 0x8A; 145
frame [ 1 ] = 0; 146
apr_socket_send ( sock , frame , & plen ); 147
0
------------------------------
143 /home/speedy/test/source2slice/NVD/CVE_2015_0253_PATCHED_read_request_line.c [u'http'] 8
static int CVE_2015_0253_PATCHED_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
char http [ 5 ] ; 8
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
0
------------------------------
144 /home/speedy/test/source2slice/NVD/CVE_2015_0253_VULN_read_request_line.c [u'http'] 8
static int CVE_2015_0253_VULN_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
char http [ 5 ] ; 8
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
0
------------------------------
145 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'newDistDir'] 825
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
NS_tchar newDistDir [ MAXPATHLEN ] ; 825
NS_tsnprintf ( newDistDir , sizeof ( newDistDir ) / sizeof ( newDistDir [ 0 ] ) , NS_T ( "%s/Contents/Resources/distribution" ) , gInstallDirPath ); 826
rv = NS_taccess ( newDistDir , F_OK ); 828
if ( ! rv )  829
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
0
------------------------------
146 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'oldDistDir'] 820
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
NS_tsnprintf ( oldDistDir , sizeof ( oldDistDir ) / sizeof ( oldDistDir [ 0 ] ) , NS_T ( "%s/Contents/MacOS/distribution" ) , gInstallDirPath ); 821
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
LOG ( ( "New distribution directory already exists... removing old "
"distribution directory: " LOG_S , oldDistDir ) ) 831
rv = ensure_remove_recursive ( oldDistDir ); 832
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
0
------------------------------
147 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'oldPrecomplete'] 815
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldPrecomplete [ MAXPATHLEN ] ; 815
NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ); 816
NS_tremove ( oldPrecomplete ); 818
0
------------------------------
148 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'installDir'] 643
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
if ( sReplaceRequest )  624
NS_tchar installDir [ MAXPATHLEN ] ; 643
NS_tstrcpy ( installDir , gInstallDirPath ); 644
size_t callbackPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , installDir , nullptr ) ; 645
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
0
------------------------------
149 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'buffer'] 622
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
NS_tchar * p = buffer ; 630
NS_tstrncpy ( p , argv [ callbackIndex ] , commonPrefixLength ); 631
p += commonPrefixLength; 632
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
p += len; 637
* p = NS_T ( '\\' ); 639
* p = NS_T ( '\0' ); 642
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
LOG ( ( "CVE_2015_0833_PATCHED_NS_main: unable to find callback file: " LOG_S , targetPath ) ) 653
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
LOG ( ( "CVE_2015_0833_PATCHED_NS_main: callback app file open attempt %d failed. "
"File: " LOG_S ". Last error: %d" , retries ,
targetPath , lastWriteError ) ) 719
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( callbackFile != INVALID_HANDLE_VALUE )  776
CloseHandle ( callbackFile ); 777
0
------------------------------
150 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'callbackLongPath'] 619
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ); 620
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
NS_tchar * s = callbackLongPath ; 669
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
0
------------------------------
151 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'applyDirLongPath'] 598
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
int len = NS_tstrlen ( applyDirLongPath ) ; 668
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
0
------------------------------
152 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'maintenanceServiceKey'] 370
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
0
------------------------------
153 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'installDir'] 259
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
if ( sStagedUpdate )  250
if ( sReplaceRequest )  256
NS_tchar installDir [ MAXPATHLEN ] ; 259
NS_tstrcpy ( installDir , gInstallDirPath ); 260
NS_tchar * slash = ( NS_tchar * ) NS_tstrrchr ( installDir , NS_SLASH ) ; 261
* slash = NS_T ( '\0' ); 262
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tstrcpy ( installDir , gInstallDirPath ); 644
0
------------------------------
154 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'updateLockFilePath'] 249
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s/updated.update_in_progress.lock" ) , gInstallDirPath ); 253
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 269
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  442
CloseHandle ( updateLockFileHandle ); 443
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  514
CloseHandle ( updateLockFileHandle ); 515
CloseHandle ( updateLockFileHandle ); 524
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
0
------------------------------
155 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'MAXPATHLEN', u'elevatedLockFilePath'] 246
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ); 298
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; 303
if ( startedFromUnelevatedUpdater )  312
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
CloseHandle ( elevatedFileHandle ); 342
CloseHandle ( elevatedFileHandle ); 503
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
size_t bufferLeft = MAXPATHLEN * 2 ; 623
bufferLeft -= commonPrefixLength; 633
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
bufferLeft -= len; 638
bufferLeft --; 641
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
0
------------------------------
156 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c [u'tmpDir'] 221
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
if ( sReplaceRequest )  217
NS_tchar tmpDir [ MAXPATHLEN ] ; 221
if ( GetTempPathW ( MAXPATHLEN , tmpDir ) )  222
NS_tchdir ( tmpDir ); 223
0
------------------------------
157 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_UpdateThreadFunc.c [u'updatingDir'] 81
static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 42
if ( rv == OK )  55
if ( rv == OK )  56
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 57
MARChannelStringTable MARStrings ; 61
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  62
MARStrings . MARChannelID [ 0 ] = '\0'; 65
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 68
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  74
rv = CopyInstallDirToDestDir ( ); 75
if ( rv == OK )  78
NS_tchar updatingDir [ MAXPATHLEN ] ; 81
NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ); 82
ensure_remove_recursive ( updatingDir ); 84
0
------------------------------
158 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_UpdateThreadFunc.c [u'updateSettingsPath'] 57
static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 42
if ( rv == OK )  55
if ( rv == OK )  56
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 57
NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , gWorkingDirPath ); 58
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  62
0
------------------------------
159 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_UpdateThreadFunc.c [u'path'] 26
static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
wchar_t path [ MAX_PATH + 1 ] ; 26
if ( RegQueryValueExW ( baseKey , valueName , 0 , & type , ( LPBYTE ) path , & size ) == ERROR_SUCCESS )  29
if ( type == REG_SZ && wcscmp ( path , rasenh ) == 0 )  31
0
------------------------------
160 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_UpdateThreadFunc.c [u'dataFile'] 9
static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
if ( rv == OK )  55
if ( rv == OK )  56
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  74
if ( rv == OK )  78
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  89
if ( rv )  108
LOG ( ( "failed: %d" , rv ) ); 109
WriteStatusFile ( rv ); 123
0
------------------------------
161 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'newDistDir'] 825
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
NS_tchar newDistDir [ MAXPATHLEN ] ; 825
NS_tsnprintf ( newDistDir , sizeof ( newDistDir ) / sizeof ( newDistDir [ 0 ] ) , NS_T ( "%s/Contents/Resources/distribution" ) , gInstallDirPath ); 826
rv = NS_taccess ( newDistDir , F_OK ); 828
if ( ! rv )  829
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
0
------------------------------
162 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'oldDistDir'] 820
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
NS_tsnprintf ( oldDistDir , sizeof ( oldDistDir ) / sizeof ( oldDistDir [ 0 ] ) , NS_T ( "%s/Contents/MacOS/distribution" ) , gInstallDirPath ); 821
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
LOG ( ( "New distribution directory already exists... removing old "
"distribution directory: " LOG_S , oldDistDir ) ) 831
rv = ensure_remove_recursive ( oldDistDir ); 832
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
0
------------------------------
163 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'oldPrecomplete'] 815
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldPrecomplete [ MAXPATHLEN ] ; 815
NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ); 816
NS_tremove ( oldPrecomplete ); 818
0
------------------------------
164 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'installDir'] 643
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
if ( sReplaceRequest )  624
NS_tchar installDir [ MAXPATHLEN ] ; 643
NS_tstrcpy ( installDir , gInstallDirPath ); 644
size_t callbackPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , installDir , nullptr ) ; 645
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
0
------------------------------
165 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'buffer'] 622
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
NS_tchar * p = buffer ; 630
NS_tstrncpy ( p , argv [ callbackIndex ] , commonPrefixLength ); 631
p += commonPrefixLength; 632
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
p += len; 637
* p = NS_T ( '\\' ); 639
* p = NS_T ( '\0' ); 642
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
LOG ( ( "CVE_2015_0833_VULN_NS_main: unable to find callback file: " LOG_S , targetPath ) ) 653
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( callbackFile != INVALID_HANDLE_VALUE )  776
CloseHandle ( callbackFile ); 777
0
------------------------------
166 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'callbackLongPath'] 619
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ); 620
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
NS_tchar * s = callbackLongPath ; 669
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
0
------------------------------
167 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'applyDirLongPath'] 598
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
int len = NS_tstrlen ( applyDirLongPath ) ; 668
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
0
------------------------------
168 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'maintenanceServiceKey'] 370
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
0
------------------------------
169 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'installDir'] 259
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
if ( sStagedUpdate )  250
if ( sReplaceRequest )  256
NS_tchar installDir [ MAXPATHLEN ] ; 259
NS_tstrcpy ( installDir , gInstallDirPath ); 260
NS_tchar * slash = ( NS_tchar * ) NS_tstrrchr ( installDir , NS_SLASH ) ; 261
* slash = NS_T ( '\0' ); 262
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tstrcpy ( installDir , gInstallDirPath ); 644
0
------------------------------
170 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'updateLockFilePath'] 249
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s/updated.update_in_progress.lock" ) , gInstallDirPath ); 253
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 269
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  442
CloseHandle ( updateLockFileHandle ); 443
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  514
CloseHandle ( updateLockFileHandle ); 515
CloseHandle ( updateLockFileHandle ); 524
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
0
------------------------------
171 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'MAXPATHLEN', u'elevatedLockFilePath'] 246
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ); 298
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; 303
if ( startedFromUnelevatedUpdater )  312
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
CloseHandle ( elevatedFileHandle ); 342
CloseHandle ( elevatedFileHandle ); 503
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
size_t bufferLeft = MAXPATHLEN * 2 ; 623
bufferLeft -= commonPrefixLength; 633
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
bufferLeft -= len; 638
bufferLeft --; 641
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
1
------------------------------
172 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c [u'tmpDir'] 221
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
if ( sReplaceRequest )  217
NS_tchar tmpDir [ MAXPATHLEN ] ; 221
if ( GetTempPathW ( MAXPATHLEN , tmpDir ) )  222
NS_tchdir ( tmpDir ); 223
0
------------------------------
173 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'updatingDir'] 46
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
MARChannelStringTable MARStrings ; 26
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
MARStrings . MARChannelID [ 0 ] = '\0'; 30
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 33
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
rv = CopyInstallDirToDestDir ( ); 40
if ( rv == OK )  43
NS_tchar updatingDir [ MAXPATHLEN ] ; 46
NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ); 47
ensure_remove_recursive ( updatingDir ); 49
0
------------------------------
174 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'updateSettingsPath'] 22
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , gWorkingDirPath ); 23
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
0
------------------------------
175 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'dataFile'] 9
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
if ( rv == OK )  20
if ( rv == OK )  21
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
if ( rv == OK )  43
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  54
if ( rv )  73
LOG ( ( "failed: %d" , rv ) ); 74
WriteStatusFile ( rv ); 88
0
------------------------------
176 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c [u'mimetype'] 149
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
0
------------------------------
177 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c [u'job_uri'] 15
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
char job_uri [ HTTP_MAX_URI ] ; 15
httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , job -> id ); 672
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ); 674
0
------------------------------
178 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_authenticate_job.c [u'username', u'scheme', u'resource', u'host'] 11
static void
CVE_2015_1158_PATCHED_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 57
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 85
if ( job -> state_value != IPP_JOB_HELD )  93
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held for authentication." ) , jobid ); 99
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
send_http_error ( con , HTTP_UNAUTHORIZED , printer ); 124
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  135
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 137
save_auth_info ( con , job , auth_info ); 146
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  152
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 154
if ( attr )  156
ippSetValueTag ( job -> attrs , & attr , IPP_TAG_KEYWORD ); 158
ippSetString ( job -> attrs , & attr , 0 , "no-hold" ); 159
cupsdReleaseJob ( job ); 166
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , NULL , job , "Job authenticated by user" ); 168
cupsdLogJob ( job , CUPSD_LOG_INFO , "Authenticated by \"%s\"." , con -> username ); 170
0
------------------------------
179 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c [u'super', u'mimetype', u'type'] 13
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
strlcpy ( super , "application" , sizeof ( super ) ); 123
strlcpy ( type , "octet-stream" , sizeof ( type ) ); 124
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
filetype = mimeType ( MimeDatabase , super , type ); 144
cupsdLogMessage ( CUPSD_LOG_INFO , "[Job ???] Request file type is %s/%s." , filetype -> super , filetype -> type ); 146
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
ippSetString ( con -> request , & format , 0 , mimetype ); 165
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 167
if ( ! filetype )  170
if ( ! _cups_strcasecmp ( filetype -> super , "application" ) && ( ! _cups_strcasecmp ( filetype -> type , "postscript" ) || ! _cups_strcasecmp ( filetype -> type , "pdf" ) ) )  190
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  199
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 211
job -> koctets += kbytes; 213
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  215
attr -> values [ 0 ] . integer += kbytes; 216
if ( add_file ( con , job , filetype , compression ) )  222
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
if ( cupsdTimeoutJob ( job ) )  234
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 241
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "hold_until=%d" , ( int ) job -> hold_until ); 244
cupsdLogJob ( job , CUPSD_LOG_INFO , "Queued on \"%s\" by \"%s\"." , job -> dest , job -> username ); 245
0
------------------------------
180 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c [u'filename'] 11
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char filename [ 1024 ] ; 11
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
0
------------------------------
181 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_release_job.c [u'username', u'scheme', u'resource', u'host'] 9
static void
CVE_2015_1158_PATCHED_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 9
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 46
if ( strncmp ( resource , "/jobs/" , 6 ) )  50
jobid = atoi ( resource + 6 ); 61
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  68
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 74
if ( job -> state_value != IPP_JOB_HELD )  82
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held." ) , jobid ); 88
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  96
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 98
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  107
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 109
if ( attr )  111
ippSetValueTag ( job -> attrs , & attr , IPP_TAG_KEYWORD ); 113
ippSetString ( job -> attrs , & attr , 0 , "no-hold" ); 114
cupsdAddEvent ( CUPSD_EVENT_JOB_CONFIG_CHANGED , cupsdFindDest ( job -> dest ) , job , "Job job-hold-until value changed by user." ); 116
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 118
cupsdReleaseJob ( job ); 125
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , cupsdFindDest ( job -> dest ) , job , "Job released by user." ); 127
cupsdLogJob ( job , CUPSD_LOG_INFO , "Released by \"%s\"." , username ); 130
0
------------------------------
182 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c [u'filename'] 31
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char filename [ 1024 ] ; 31
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 304
rename ( con -> filename , filename ); 306
0
------------------------------
183 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c [u'super', u'mimetype', u'type'] 25
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
strlcpy ( super , "application" , sizeof ( super ) ); 208
strlcpy ( type , "octet-stream" , sizeof ( type ) ); 209
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
filetype = mimeType ( MimeDatabase , super , type ); 229
if ( filetype )  231
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Request file type is %s/%s." , filetype -> super , filetype -> type ); 232
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
ippSetString ( job -> attrs , & jformat , 0 , mimetype ); 250
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 252
if ( ! filetype )  255
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s/%s\"." ) , super , type ); 257
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 271
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 274
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 277
if ( add_file ( con , job , filetype , compression ) )  289
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 310
0
------------------------------
184 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c [u'username', u'job_uri', u'resource', u'host', u'scheme'] 13
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 68
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 96
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 108
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Bad document-format-default \"%s\"." ) , default_format ); 197
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Auto-typing file..." ); 221
filetype = mimeType ( MimeDatabase , super , type ); 229
if ( filetype )  231
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Request file type is %s/%s." , filetype -> super , filetype -> type ); 232
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
if ( ( jformat = ippFindAttribute ( job -> attrs , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  248
ippSetString ( job -> attrs , & jformat , 0 , mimetype ); 250
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 252
if ( ! filetype )  255
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s/%s\"." ) , super , type ); 257
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 271
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 274
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 277
cupsdLoadJob ( job ); 287
if ( add_file ( con , job , filetype , compression ) )  289
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 297
job -> koctets += kbytes; 299
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  301
attr -> values [ 0 ] . integer += kbytes; 302
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 304
rename ( con -> filename , filename ); 306
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 310
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  319
if ( cupsdTimeoutJob ( job ) )  327
if ( job -> state_value == IPP_JOB_STOPPED )  330
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 332
job -> state_value = IPP_JOB_PENDING; 333
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 335
if ( job -> state_value == IPP_JOB_HELD )  337
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  339
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 341
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  343
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 345
job -> state_value = IPP_JOB_PENDING; 346
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 348
ippSetString ( job -> attrs , & job -> reasons , 0 , "job-hold-until-specified" ); 351
job -> dirty = 1; 354
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  361
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 363
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  365
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 367
job -> state_value = IPP_JOB_HELD; 368
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 369
ippSetString ( job -> attrs , & job -> reasons , 0 , "job-incoming" ); 371
job -> dirty = 1; 373
httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , jobid ); 384
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ); 386
ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-id" , jobid ); 389
ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , job -> state_value ); 391
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , job -> reasons -> values [ 0 ] . string . text ); 393
0
------------------------------
185 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c [u'mimetype'] 149
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
0
------------------------------
186 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c [u'job_uri'] 15
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
char job_uri [ HTTP_MAX_URI ] ; 15
httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , job -> id ); 710
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ); 712
0
------------------------------
187 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_authenticate_job.c [u'username', u'scheme', u'resource', u'host'] 11
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 57
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 85
if ( job -> state_value != IPP_JOB_HELD )  93
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held for authentication." ) , jobid ); 99
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
send_http_error ( con , HTTP_UNAUTHORIZED , printer ); 124
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  135
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 137
save_auth_info ( con , job , auth_info ); 146
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  152
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 154
if ( attr )  156
attr -> value_tag = IPP_TAG_KEYWORD; 158
cupsdSetString ( & ( attr -> values [ 0 ] . string . text ) , "no-hold" ); 159
cupsdReleaseJob ( job ); 166
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , NULL , job , "Job authenticated by user" ); 168
cupsdLogJob ( job , CUPSD_LOG_INFO , "Authenticated by \"%s\"." , con -> username ); 170
1
------------------------------
188 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c [u'super', u'mimetype', u'type'] 13
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
strlcpy ( super , "application" , sizeof ( super ) ); 123
strlcpy ( type , "octet-stream" , sizeof ( type ) ); 124
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
filetype = mimeType ( MimeDatabase , super , type ); 144
cupsdLogMessage ( CUPSD_LOG_INFO , "[Job ???] Request file type is %s/%s." , filetype -> super , filetype -> type ); 146
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
format -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ); 168
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 171
if ( ! filetype )  174
if ( ! _cups_strcasecmp ( filetype -> super , "application" ) && ( ! _cups_strcasecmp ( filetype -> type , "postscript" ) || ! _cups_strcasecmp ( filetype -> type , "pdf" ) ) )  194
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  203
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 215
job -> koctets += kbytes; 217
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  219
attr -> values [ 0 ] . integer += kbytes; 220
if ( add_file ( con , job , filetype , compression ) )  226
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 229
rename ( con -> filename , filename ); 231
if ( cupsdTimeoutJob ( job ) )  238
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 245
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "hold_until=%d" , ( int ) job -> hold_until ); 248
cupsdLogJob ( job , CUPSD_LOG_INFO , "Queued on \"%s\" by \"%s\"." , job -> dest , job -> username ); 249
1
------------------------------
189 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c [u'filename'] 11
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char filename [ 1024 ] ; 11
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 229
rename ( con -> filename , filename ); 231
0
------------------------------
190 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_release_job.c [u'username', u'scheme', u'resource', u'host'] 9
static void
CVE_2015_1158_VULN_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 9
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 46
if ( strncmp ( resource , "/jobs/" , 6 ) )  50
jobid = atoi ( resource + 6 ); 61
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  68
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 74
if ( job -> state_value != IPP_JOB_HELD )  82
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held." ) , jobid ); 88
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  96
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 98
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  107
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 109
if ( attr )  111
_cupsStrFree ( attr -> values [ 0 ] . string . text ); 113
attr -> value_tag = IPP_TAG_KEYWORD; 115
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( "no-hold" ); 116
cupsdAddEvent ( CUPSD_EVENT_JOB_CONFIG_CHANGED , cupsdFindDest ( job -> dest ) , job , "Job job-hold-until value changed by user." ); 118
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 120
cupsdReleaseJob ( job ); 127
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , cupsdFindDest ( job -> dest ) , job , "Job released by user." ); 129
cupsdLogJob ( job , CUPSD_LOG_INFO , "Released by \"%s\"." , username ); 132
1
------------------------------
191 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c [u'filename'] 31
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char filename [ 1024 ] ; 31
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 308
rename ( con -> filename , filename ); 310
0
------------------------------
192 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c [u'super', u'mimetype', u'type'] 25
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
strlcpy ( super , "application" , sizeof ( super ) ); 208
strlcpy ( type , "octet-stream" , sizeof ( type ) ); 209
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
filetype = mimeType ( MimeDatabase , super , type ); 229
if ( filetype )  231
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Request file type is %s/%s." , filetype -> super , filetype -> type ); 232
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
jformat -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ); 253
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 256
if ( ! filetype )  259
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s/%s\"." ) , super , type ); 261
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 275
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 278
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 281
if ( add_file ( con , job , filetype , compression ) )  293
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 314
1
------------------------------
193 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c [u'username', u'job_uri', u'resource', u'host', u'scheme'] 13
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 68
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 96
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 108
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Bad document-format-default \"%s\"." ) , default_format ); 197
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Auto-typing file..." ); 221
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Request file type is %s/%s." , filetype -> super , filetype -> type ); 232
if ( ( jformat = ippFindAttribute ( job -> attrs , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  248
_cupsStrFree ( jformat -> values [ 0 ] . string . text ); 251
jformat -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ); 253
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 256
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
cupsdLoadJob ( job ); 291
if ( add_file ( con , job , filetype , compression ) )  293
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 301
job -> koctets += kbytes; 303
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  305
attr -> values [ 0 ] . integer += kbytes; 306
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 308
rename ( con -> filename , filename ); 310
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 314
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  323
if ( cupsdTimeoutJob ( job ) )  331
if ( job -> state_value == IPP_JOB_STOPPED )  334
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 336
job -> state_value = IPP_JOB_PENDING; 337
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 339
if ( job -> state_value == IPP_JOB_HELD )  341
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  343
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 345
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  347
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 349
job -> state_value = IPP_JOB_PENDING; 350
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 352
ippSetString ( job -> attrs , & job -> reasons , 0 , "job-hold-until-specified" ); 355
job -> dirty = 1; 358
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  365
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 367
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  369
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 371
job -> state_value = IPP_JOB_HELD; 372
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 373
ippSetString ( job -> attrs , & job -> reasons , 0 , "job-incoming" ); 375
job -> dirty = 1; 377
httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , jobid ); 388
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ); 390
ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-id" , jobid ); 393
ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , job -> state_value ); 395
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , job -> reasons -> values [ 0 ] . string . text ); 397
1
------------------------------
194 /home/speedy/test/source2slice/NVD/CVE_2015_2666_PATCHED_get_matching_model_microcode.c [u'mc_saved_tmp'] 13
static enum ucode_state __init
CVE_2015_2666_PATCHED_get_matching_model_microcode(int cpu, unsigned long start,
void *data, size_t size,
struct mc_saved_data *mc_saved_data,
unsigned long *mc_saved_in_initrd,
struct ucode_cpu_info *uci) 6
struct microcode_intel * mc_saved_tmp [ MAX_UCODE_COUNT ] ; 13
while ( leftover && mc_saved_count < ARRAY_SIZE ( mc_saved_tmp ) )  17
_save_mc ( mc_saved_tmp , ucode_ptr , & mc_saved_count ); 38
mc_saved_in_initrd [ i ] = ( unsigned long ) mc_saved_tmp [ i ] - start; 54
0
------------------------------
195 /home/speedy/test/source2slice/NVD/CVE_2015_2666_VULN_get_matching_model_microcode.c [u'mc_saved_tmp'] 13
static enum ucode_state __init
CVE_2015_2666_VULN_get_matching_model_microcode(int cpu, unsigned long start,
void *data, size_t size,
struct mc_saved_data *mc_saved_data,
unsigned long *mc_saved_in_initrd,
struct ucode_cpu_info *uci) 6
struct microcode_intel * mc_saved_tmp [ MAX_UCODE_COUNT ] ; 13
_save_mc ( mc_saved_tmp , ucode_ptr , & mc_saved_count ); 38
mc_saved_in_initrd [ i ] = ( unsigned long ) mc_saved_tmp [ i ] - start; 54
0
------------------------------
196 /home/speedy/test/source2slice/NVD/CVE_2015_3008_PATCHED_handle_tcptls_connection.c [u'err'] 7
static void *CVE_2015_3008_PATCHED_handle_tcptls_connection(void *data) 1
char err [ 256 ] ; 7
ast_verb ( 2 , "Problem setting up ssl connection: %s\n" , ERR_error_string ( ERR_get_error ( ) , err ) ); 45
0
------------------------------
197 /home/speedy/test/source2slice/NVD/CVE_2015_3008_VULN_handle_tcptls_connection.c [u'err'] 7
static void *CVE_2015_3008_VULN_handle_tcptls_connection(void *data) 1
char err [ 256 ] ; 7
ast_verb ( 2 , "Problem setting up ssl connection: %s\n" , ERR_error_string ( ERR_get_error ( ) , err ) ); 45
0
------------------------------
198 /home/speedy/test/source2slice/NVD/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c [u'iv_and_authTag'] 12
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
* ( iv + i ) = ctx -> nonce [ i ]; 30
for (i = 0; i < 8; i++) 31
* ( iv + 4 + i ) = req -> iv [ i ]; 32
* ( ( __be32 * ) ( iv + 12 ) ) = counter; 33
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
0
------------------------------
199 /home/speedy/test/source2slice/NVD/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c [u'iv_and_authTag'] 12
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
* ( iv + i ) = ctx -> nonce [ i ]; 30
for (i = 0; i < 8; i++) 31
* ( iv + 4 + i ) = req -> iv [ i ]; 32
* ( ( __be32 * ) ( iv + 12 ) ) = counter; 33
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
0
------------------------------
200 /home/speedy/test/source2slice/NVD/CVE_2015_3811_PATCHED_wcp_uncompress.c [u'src_buf'] 13
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
if ( data_offset + 1 > buf_ptr -> initialized )  109
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data offset exceeds valid window size (%d > %d)" , data_offset + 1 , buf_ptr -> initialized ); 110
if ( data_offset + 1 < data_cnt )  116
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data count exceeds offset (%d > %d)" , data_cnt , data_offset + 1 ); 117
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
* dst = * src; 153
if ( dst ++ == buf_end )  154
comp_flag_bits <<= 1; 164
comp_flag_bits = * src ++; 172
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 174
buf_ptr -> buf_cur = dst; 200
0
------------------------------
201 /home/speedy/test/source2slice/NVD/CVE_2015_3811_VULN_wcp_uncompress.c [u'src_buf'] 13
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
* dst = * src; 140
if ( dst ++ == buf_end )  141
comp_flag_bits <<= 1; 149
comp_flag_bits = * src ++; 157
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 159
buf_ptr -> buf_cur = dst; 185
0
------------------------------
202 /home/speedy/test/source2slice/NVD/CVE-2015-4504_VULN_lut_inverse_interp16.c [u'LutTable'] 1
uint16_fract_t lut_inverse_interp16(uint16_t Value, uint16_t LutTable[], int length) 1
while ( LutTable [ NumZeroes ] == 0 && NumZeroes < length - 1 )  18
while ( LutTable [ length - 1 - NumPoles ] == 0xFFFF && NumPoles < length - 1 )  28
res = ( int ) lut_interp_linear16 ( ( uint16_fract_t ) ( x - 1 ) , LutTable , length ); 56
if ( res == Value )  58
if ( res > Value )  65
y0 = LutTable [ cell0 ]; 81
y1 = LutTable [ cell1 ]; 84
a = ( y1 - y0 ) / ( x1 - x0 ); 87
b = y0 - a * x0; 88
if ( fabs ( a ) < 0.01 )  90
f = ( ( Value - b ) / a ); 92
if ( f < 0.0 )  94
if ( f >= 65535.0 )  95
return ( uint16_fract_t ) floor ( f + 0.5 ) ; 97
0
------------------------------
203 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'dstStride'] 2
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
1
------------------------------
204 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'dst'] 2
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
1
------------------------------
205 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'srcStride'] 1
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
srcPtr += 2 * srcStride [ 0 ]; 34
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
srcPtr += 2 * srcStride [ 0 ]; 41
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
1
------------------------------
206 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'src'] 1
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
void ( * copy ) ( const uint8_t * src , int src_stride , uint8_t * dstY , uint8_t * dstU , uint8_t * dstV , int luma_stride , int width , int32_t * rgb2yuv )
void ( * interpolate ) ( const uint8_t * src , int src_stride , uint8_t * dstY , uint8_t * dstU , uint8_t * dstV , int luma_stride , int width , int32_t * rgb2yuv ) 10
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
srcPtr += 2 * srcStride [ 0 ]; 34
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
srcPtr += 2 * srcStride [ 0 ]; 41
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
1
------------------------------
207 /home/speedy/test/source2slice/NVD/CVE_2009_4308_PATCHED_ext4_decode_error.c [u'nbuf'] 2
static const char *CVE_2009_4308_PATCHED_ext4_decode_error(struct super_block *sb, int errno,
char nbuf[16]) 2
if ( nbuf )  24
if ( snprintf ( nbuf , 16 , "error %d" , - errno ) >= 0 )  26
errstr = nbuf; 27
return errstr ; 32
0
------------------------------
208 /home/speedy/test/source2slice/NVD/CVE_2009_4308_VULN_ext4_decode_error.c [u'nbuf'] 2
static const char *CVE_2009_4308_VULN_ext4_decode_error(struct super_block *sb, int errno,
char nbuf[16]) 2
if ( nbuf )  23
if ( snprintf ( nbuf , 16 , "error %d" , - errno ) >= 0 )  25
errstr = nbuf; 26
return errstr ; 31
0
------------------------------
209 /home/speedy/test/source2slice/NVD/CVE_2014_5271_PATCHED_encode_slice.c [u'sizes'] 3
static int CVE_2014_5271_PATCHED_encode_slice(AVCodecContext *avctx, const AVFrame *pic,
PutBitContext *pb,
int sizes[4], int x, int y, int quant,
int mbs_per_slice) 4
linesize = pic -> linesize [ i ] * ctx -> pictures_per_frame; 47
src = ( const uint16_t * ) ( pic -> data [ i ] + yp * linesize + line_add * pic -> linesize [ i ] ) + xp; 48
get_slice_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , ctx -> emu_buf , mbs_per_slice , num_cblocks , is_chroma ); 52
sizes [ i ] = encode_slice_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , num_cblocks , plane_factor , qmat ); 56
get_alpha_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , mbs_per_slice , ctx -> alpha_bits ); 61
sizes [ i ] = encode_alpha_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , quant ); 64
total_size += sizes [ i ]; 68
return total_size ; 75
0
------------------------------
210 /home/speedy/test/source2slice/NVD/CVE_2014_5271_VULN_encode_slice.c [u'sizes'] 3
static int CVE_2014_5271_VULN_encode_slice(AVCodecContext *avctx, const AVFrame *pic,
PutBitContext *pb,
int sizes[4], int x, int y, int quant,
int mbs_per_slice) 4
linesize = pic -> linesize [ i ] * ctx -> pictures_per_frame; 47
src = ( const uint16_t * ) ( pic -> data [ i ] + yp * linesize + line_add * pic -> linesize [ i ] ) + xp; 48
get_slice_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , ctx -> emu_buf , mbs_per_slice , num_cblocks , is_chroma ); 52
sizes [ i ] = encode_slice_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , num_cblocks , plane_factor , qmat ); 56
get_alpha_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , mbs_per_slice , ctx -> alpha_bits ); 61
sizes [ i ] = encode_alpha_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , quant ); 64
total_size += sizes [ i ]; 68
return total_size ; 70
0
------------------------------
