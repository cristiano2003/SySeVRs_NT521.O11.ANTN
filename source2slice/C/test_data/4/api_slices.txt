1 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_httpd_helper_thread.c fclose 108
static void *CVE_2014_2286_PATCHED_httpd_helper_thread(void *data) 1
struct ast_tcptls_session_instance * ser = data ; 5
if ( ser -> f )  107
fclose ( ser -> f ); 108
------------------------------
2 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_httpd_helper_thread.c fclose 94
static void *CVE_2014_2286_VULN_httpd_helper_thread(void *data) 1
struct ast_tcptls_session_instance * ser = data ; 5
if ( ser -> f )  93
fclose ( ser -> f ); 94
------------------------------
3 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c fclose 185
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
4 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c fclose 185
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
5 /home/speedy/test/source2slice/NVD/CVE_2007_4521_PATCHED_play_message.c snprintf 30
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char * header_content ; 4
char todir [ PATH_MAX ] ; 10
vms -> starting = 0; 15
if ( vms -> msgArray [ vms -> curmsg ] == 0 )  18
header_content = mail_fetchheader ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] ); 24
if ( ast_strlen_zero ( header_content ) )  26
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
------------------------------
6 /home/speedy/test/source2slice/NVD/CVE_2007_4521_VULN_play_message.c snprintf 30
static int CVE_2007_4521_VULN_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char * header_content ; 4
char todir [ PATH_MAX ] ; 10
vms -> starting = 0; 15
if ( vms -> msgArray [ vms -> curmsg ] == 0 )  18
header_content = mail_fetchheader ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] ); 24
if ( ast_strlen_zero ( header_content ) )  26
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
------------------------------
7 /home/speedy/test/source2slice/NVD/CVE_2007_4571_VULN_snd_mem_proc_read.c snprintf 20
static int CVE_2007_4571_VULN_snd_mem_proc_read(char *page, char **start, off_t off,
int count, int *eof, void *data) 2
int len = 0 ; 4
long pages = snd_allocated_pages >> ( PAGE_SHIFT - 12 ) ; 5
struct snd_mem_list * mem ; 6
int devno ; 7
static char * types [ ] = { "UNKNOWN" , "CONT" , "DEV" , "DEV-SG" , "SBUS" } ; 8
len += snprintf ( page + len , count - len , "pages  : %li bytes (%li pages per %likB)\n" , pages * PAGE_SIZE , pages , PAGE_SIZE / 1024 ); 11
devno = 0; 14
devno ++; 16
len += snprintf ( page + len , count - len , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 17
len += snprintf ( page + len , count - len , "  addr = 0x%lx, size = %d bytes\n" , ( unsigned long ) mem -> buffer . addr , ( int ) mem -> buffer . bytes ); 20
return len ; 25
------------------------------
8 /home/speedy/test/source2slice/NVD/CVE_2007_4571_VULN_snd_mem_proc_read.c snprintf 17
static int CVE_2007_4571_VULN_snd_mem_proc_read(char *page, char **start, off_t off,
int count, int *eof, void *data) 2
int len = 0 ; 4
long pages = snd_allocated_pages >> ( PAGE_SHIFT - 12 ) ; 5
struct snd_mem_list * mem ; 6
int devno ; 7
static char * types [ ] = { "UNKNOWN" , "CONT" , "DEV" , "DEV-SG" , "SBUS" } ; 8
len += snprintf ( page + len , count - len , "pages  : %li bytes (%li pages per %likB)\n" , pages * PAGE_SIZE , pages , PAGE_SIZE / 1024 ); 11
devno = 0; 14
devno ++; 16
len += snprintf ( page + len , count - len , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 17
len += snprintf ( page + len , count - len , "  addr = 0x%lx, size = %d bytes\n" , ( unsigned long ) mem -> buffer . addr , ( int ) mem -> buffer . bytes ); 20
return len ; 25
------------------------------
9 /home/speedy/test/source2slice/NVD/CVE_2007_4571_VULN_snd_mem_proc_read.c snprintf 11
static int CVE_2007_4571_VULN_snd_mem_proc_read(char *page, char **start, off_t off,
int count, int *eof, void *data) 2
int len = 0 ; 4
long pages = snd_allocated_pages >> ( PAGE_SHIFT - 12 ) ; 5
len += snprintf ( page + len , count - len , "pages  : %li bytes (%li pages per %likB)\n" , pages * PAGE_SIZE , pages , PAGE_SIZE / 1024 ); 11
len += snprintf ( page + len , count - len , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 17
len += snprintf ( page + len , count - len , "  addr = 0x%lx, size = %d bytes\n" , ( unsigned long ) mem -> buffer . addr , ( int ) mem -> buffer . bytes ); 20
return len ; 25
------------------------------
10 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c snprintf 379
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
* p = 0; 412
------------------------------
11 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c snprintf 67
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
------------------------------
12 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c snprintf 62
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
------------------------------
13 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c snprintf 41
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_share [ 0 ] = 0; 32
snprintf ( psz_remote , sizeof ( psz_remote ) , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
------------------------------
14 /home/speedy/test/source2slice/NVD/CVE_2009_4308_PATCHED_ext4_decode_error.c snprintf 26
static const char *CVE_2009_4308_PATCHED_ext4_decode_error(struct super_block *sb, int errno,
char nbuf[16]) 2
switch ( errno )  6
if ( nbuf )  24
if ( snprintf ( nbuf , 16 , "error %d" , - errno ) >= 0 )  26
errstr = nbuf; 27
return errstr ; 32
------------------------------
15 /home/speedy/test/source2slice/NVD/CVE_2009_4308_VULN_ext4_decode_error.c snprintf 25
static const char *CVE_2009_4308_VULN_ext4_decode_error(struct super_block *sb, int errno,
char nbuf[16]) 2
switch ( errno )  6
if ( nbuf )  23
if ( snprintf ( nbuf , 16 , "error %d" , - errno ) >= 0 )  25
errstr = nbuf; 26
return errstr ; 31
------------------------------
16 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 168
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( ! p -> initreq . headers && req -> has_to_tag )  175
ast_string_field_set ( p , tag , totag ); 186
p -> pendinginvite = p -> icseq; 187
transmit_response_reliable ( p , "481 Call/Transaction Does Not Exist" , req ); 188
------------------------------
17 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 130
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
unsigned int ran = ( ast_random ( ) % 10 ) + 1 ; 128
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
------------------------------
18 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 100
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
------------------------------
19 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c snprintf 168
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( ! p -> initreq . headers && req -> has_to_tag )  175
ast_string_field_set ( p , tag , totag ); 186
p -> pendinginvite = p -> icseq; 187
transmit_response_reliable ( p , "481 Call/Transaction Does Not Exist" , req ); 188
------------------------------
20 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c snprintf 130
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
unsigned int ran = ( ast_random ( ) % 10 ) + 1 ; 128
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
------------------------------
21 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c snprintf 100
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
------------------------------
22 /home/speedy/test/source2slice/NVD/CVE_2014_1690_PATCHED_help.c snprintf 54
static unsigned int CVE_2014_1690_PATCHED_help(struct sk_buff *skb,
enum ip_conntrack_info ctinfo,
unsigned int protoff,
unsigned int matchoff,
unsigned int matchlen,
struct nf_conntrack_expect *exp) 6
char buffer [ sizeof ( "4294967296 65635" ) ] ; 8
struct nf_conn * ct = exp -> master ; 9
union nf_inet_addr newaddr ; 10
u_int16_t port ; 11
unsigned int ret ; 12
newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3; 15
exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port; 17
exp -> dir = IP_CT_DIR_REPLY; 18
exp -> expectfn = nf_nat_follow_master; 19
for (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) 22
int ret ; 23
exp -> tuple . dst . u . tcp . port = htons ( port ); 25
ret = nf_ct_expect_related ( exp ); 26
if ( ret == 0 )  27
if ( ret != - EBUSY )  29
port = 0; 30
if ( port == 0 )  35
snprintf ( buffer , sizeof ( buffer ) , "%u %u" , ntohl ( newaddr . ip ) , port ); 54
pr_debug ( "nf_nat_irc: inserting '%s' == %pI4, port %u\n" , buffer , & newaddr . ip , port ); 55
ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ); 58
if ( ret != NF_ACCEPT )  60
return ret ; 65
------------------------------
23 /home/speedy/test/source2slice/NVD/CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device.c snprintf 49
static void CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
struct hid_device * dj_hiddev ; 8
unsigned char tmpstr [ 3 ] ; 14
if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY )  16
if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )  23
dj_hiddev = hid_allocate_device ( ); 29
if ( IS_ERR ( dj_hiddev ) )  30
snprintf ( tmpstr , sizeof ( tmpstr ) , ":%d" , dj_report -> device_index ); 49
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 50
------------------------------
24 /home/speedy/test/source2slice/NVD/CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device.c snprintf 43
static void CVE_2014_3182_PATCHED_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; 5
struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; 6
struct usb_device * usbdev = interface_to_usbdev ( intf ) ; 7
struct hid_device * dj_hiddev ; 8
if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY )  16
if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )  23
dj_hiddev = hid_allocate_device ( ); 29
if ( IS_ERR ( dj_hiddev ) )  30
dj_hiddev -> ll_driver = & logi_dj_ll_driver; 36
dj_hiddev -> hid_output_raw_report = logi_dj_output_hidraw_report; 37
dj_hiddev -> dev . parent = & djrcv_hdev -> dev; 39
dj_hiddev -> bus = BUS_USB; 40
dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ); 41
dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ); 42
snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , "Logitech Unifying Device. Wireless PID:%02x%02x" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ); 43
usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ); 48
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 50
dj_dev -> hdev = dj_hiddev; 62
dj_dev -> dj_receiver_dev = djrcv_dev; 63
dj_dev -> device_index = dj_report -> device_index; 64
dj_hiddev -> driver_data = dj_dev; 65
djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev; 67
if ( hid_add_device ( dj_hiddev ) )  69
------------------------------
25 /home/speedy/test/source2slice/NVD/CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device.c snprintf 56
static void CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
struct hid_device * dj_hiddev ; 8
unsigned char tmpstr [ 3 ] ; 14
if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY )  16
if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) )  23
if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )  30
dj_hiddev = hid_allocate_device ( ); 36
if ( IS_ERR ( dj_hiddev ) )  37
snprintf ( tmpstr , sizeof ( tmpstr ) , ":%d" , dj_report -> device_index ); 56
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 57
------------------------------
26 /home/speedy/test/source2slice/NVD/CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device.c snprintf 50
static void CVE_2014_3182_VULN_logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report) 2
struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; 5
struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; 6
struct usb_device * usbdev = interface_to_usbdev ( intf ) ; 7
struct hid_device * dj_hiddev ; 8
if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY )  16
if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) )  23
if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )  30
dj_hiddev = hid_allocate_device ( ); 36
if ( IS_ERR ( dj_hiddev ) )  37
dj_hiddev -> ll_driver = & logi_dj_ll_driver; 43
dj_hiddev -> hid_output_raw_report = logi_dj_output_hidraw_report; 44
dj_hiddev -> dev . parent = & djrcv_hdev -> dev; 46
dj_hiddev -> bus = BUS_USB; 47
dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ); 48
dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ); 49
snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , "Logitech Unifying Device. Wireless PID:%02x%02x" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ); 50
usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ); 55
strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ); 57
dj_dev -> hdev = dj_hiddev; 69
dj_dev -> dj_receiver_dev = djrcv_dev; 70
dj_dev -> device_index = dj_report -> device_index; 71
dj_hiddev -> driver_data = dj_dev; 72
djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev; 74
if ( hid_add_device ( dj_hiddev ) )  76
------------------------------
27 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 141
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
if ( language [ 3 ] )  131
language [ 0 ] = '\0'; 132
language [ 0 ] = '\0'; 134
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
------------------------------
28 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 76
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
cupsdLogClient ( con , CUPSD_LOG_INFO , "Symlinks such as \"%s\" are not allowed." , filename ); 91
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
cupsdLogClient ( con , CUPSD_LOG_INFO , "Files/directories such as \"%s\" must be world-readable." , filename ); 102
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
------------------------------
29 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 64
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
cupsdLogClient ( con , CUPSD_LOG_INFO , "Symlinks such as \"%s\" are not allowed." , filename ); 91
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
cupsdLogClient ( con , CUPSD_LOG_INFO , "Files/directories such as \"%s\" must be world-readable." , filename ); 102
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
------------------------------
30 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 44
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  46
* ptr = '\0'; 47
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
cupsdLogClient ( con , CUPSD_LOG_INFO , "Symlinks such as \"%s\" are not allowed." , filename ); 91
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
cupsdLogClient ( con , CUPSD_LOG_INFO , "Files/directories such as \"%s\" must be world-readable." , filename ); 102
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
------------------------------
31 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 41
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
------------------------------
32 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 40
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
cupsdLogClient ( con , CUPSD_LOG_INFO , "Symlinks such as \"%s\" are not allowed." , filename ); 91
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
cupsdLogClient ( con , CUPSD_LOG_INFO , "Files/directories such as \"%s\" must be world-readable." , filename ); 102
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
if ( language [ 3 ] )  131
language [ 0 ] = '\0'; 132
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_PATCHED_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 197
if ( status )  199
return ( filename ) ; 202
------------------------------
33 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 26
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
snprintf ( filename , len , "%s%s" , ServerRoot , con -> uri + 11 ); 26
------------------------------
34 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 24
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
snprintf ( filename , len , "%s/rss/%s" , CacheDir , con -> uri + 5 ); 24
------------------------------
35 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c snprintf 22
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
snprintf ( filename , len , "%s%s" , ServerRoot , con -> uri ); 22
------------------------------
36 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 120
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
if ( language [ 3 ] )  110
language [ 0 ] = '\0'; 111
language [ 0 ] = '\0'; 113
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
------------------------------
37 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 76
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
------------------------------
38 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 64
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
------------------------------
39 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 44
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  46
* ptr = '\0'; 47
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
------------------------------
40 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 41
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
------------------------------
41 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 40
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 41
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
if ( language [ 3 ] )  110
language [ 0 ] = '\0'; 111
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
cupsdLogMessage ( CUPSD_LOG_DEBUG2 ,
"CVE_2014_3537_VULN_get_file(con=%p(%d), filestats=%p, filename=%p, len=%d) = "
"%s" , con , con -> http . fd , filestats , filename , len ,
status ? "(null)" : filename ) 176
if ( status )  178
return ( filename ) ; 181
------------------------------
42 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 26
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
snprintf ( filename , len , "%s%s" , ServerRoot , con -> uri + 11 ); 26
------------------------------
43 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 24
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
snprintf ( filename , len , "%s/rss/%s" , CacheDir , con -> uri + 5 ); 24
------------------------------
44 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c snprintf 22
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
snprintf ( filename , len , "%s%s" , ServerRoot , con -> uri ); 22
------------------------------
45 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c snprintf 153
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
------------------------------
46 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c snprintf 225
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
cupsd_job_t * job ; 10
char filename [ 1024 ] ; 11
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
struct stat fileinfo ; 18
int kbytes ; 19
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
if ( ! filetype )  170
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  199
if ( stat ( con -> filename , & fileinfo ) )  206
kbytes = 0; 207
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 209
job -> koctets += kbytes; 213
if ( add_file ( con , job , filetype , compression ) )  222
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
------------------------------
47 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c snprintf 161
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
ippSetString ( con -> request , & format , 0 , mimetype ); 165
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 167
------------------------------
48 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c snprintf 304
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
char filename [ 1024 ] ; 31
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  255
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
if ( add_file ( con , job , filetype , compression ) )  289
if ( stat ( con -> filename , & fileinfo ) )  292
kbytes = 0; 293
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 295
job -> koctets += kbytes; 299
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 304
rename ( con -> filename , filename ); 306
------------------------------
49 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c snprintf 271
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
if ( ! filetype )  255
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 271
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 274
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 277
------------------------------
50 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c snprintf 245
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
ippSetString ( job -> attrs , & jformat , 0 , mimetype ); 250
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 252
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 271
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 274
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 277
------------------------------
51 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c snprintf 153
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
------------------------------
52 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c snprintf 229
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
cupsd_job_t * job ; 10
char filename [ 1024 ] ; 11
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
struct stat fileinfo ; 18
int kbytes ; 19
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
if ( ! filetype )  174
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  203
if ( stat ( con -> filename , & fileinfo ) )  210
kbytes = 0; 211
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 213
job -> koctets += kbytes; 217
if ( add_file ( con , job , filetype , compression ) )  226
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 229
rename ( con -> filename , filename ); 231
------------------------------
53 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c snprintf 161
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
format -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ); 168
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 171
------------------------------
54 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c snprintf 308
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
char filename [ 1024 ] ; 31
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  259
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
if ( add_file ( con , job , filetype , compression ) )  293
if ( stat ( con -> filename , & fileinfo ) )  296
kbytes = 0; 297
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 299
job -> koctets += kbytes; 303
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 308
rename ( con -> filename , filename ); 310
------------------------------
55 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c snprintf 275
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
if ( ! filetype )  259
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 275
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 278
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 281
------------------------------
56 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c snprintf 245
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
jformat -> values [ 0 ] . string . text = _cupsStrAlloc ( mimetype ); 253
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 256
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 275
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 278
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 281
------------------------------
57 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 373
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
58 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 66
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
memset ( v_count , 0 , sizeof ( v_count ) ); 66
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
if ( s -> bits <= 8 )  324
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
if ( ret < 0 )  4
av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ); 5
return ret ; 6
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
59 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 65
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
memset ( h_count , 0 , sizeof ( h_count ) ); 65
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
if ( s -> bits <= 8 )  324
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
if ( ret < 0 )  4
av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ); 5
return ret ; 6
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
60 /home/speedy/test/source2slice/NVD/CVE-2015-3456_VULN_fdctrl_read_data.c memset 28
static uint32_t fdctrl_read_data(FDCtrl *fdctrl) 1
FDrive * cur_drv ; 3
int pos ; 5
cur_drv = get_cur_drv ( fdctrl ); 7
fdctrl -> dsr &= ~FD_DSR_PWRDOWN; 8
if ( ! ( fdctrl -> msr & FD_MSR_RQM ) || ! ( fdctrl -> msr & FD_MSR_DIO ) )  9
pos = fdctrl -> data_pos; 13
if ( fdctrl -> msr & FD_MSR_NONDMA )  14
pos %= FD_SECTOR_LEN; 15
if ( pos == 0 )  16
if ( fdctrl -> data_pos != 0 )  17
if ( ! fdctrl_seek_to_next_sect ( fdctrl , cur_drv ) )  18
if ( blk_read ( cur_drv -> blk , fd_sector ( cur_drv ) , fdctrl -> fifo , 1 ) < 0 )  23
memset ( fdctrl -> fifo , 0 , FD_SECTOR_LEN ); 28
retval = fdctrl -> fifo [ pos ]; 32
if ( ++ fdctrl -> data_pos == fdctrl -> data_len )  33
fdctrl -> data_pos = 0; 34
if ( fdctrl -> msr & FD_MSR_NONDMA )  38
fdctrl_stop_transfer ( fdctrl , 0x00 , 0x00 , 0x00 ); 39
fdctrl_reset_fifo ( fdctrl ); 41
fdctrl_reset_irq ( fdctrl ); 42
FLOPPY_DPRINTF ( "data register: 0x%02x\n" , retval ); 45
return retval ; 47
------------------------------
61 /home/speedy/test/source2slice/NVD/CVE-2016-2327_VULN_apng_encode_frame.c memset 67
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
unsigned int y ; 6
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
if ( last_fctl_chunk . dispose_op == APNG_DISPOSE_OP_BACKGROUND )  64
for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) 65
size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
------------------------------
62 /home/speedy/test/source2slice/NVD/CVE-2016-4082_VULN_dissect_schedule_message.c memset 44
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 1
guint len , offset = 0 ; 3
guint8 sched_begin , sched_end , new_slots [ 48 ] ; 5
gboolean valid_message = TRUE ; 6
guint16 other_slots [ 48 ] ; 7
schedule_item = proto_tree_add_protocol_format ( top_tree , proto_cbch , tvb , 0 , - 1 , "GSM CBCH Schedule Message" ); 15
sched_tree = proto_item_add_subtree ( schedule_item , ett_schedule_msg ); 18
octet1 = tvb_get_guint8 ( tvb , offset ); 21
if ( 0 == ( octet1 & 0xC0 ) )  22
sched_begin = octet1 & 0x3F; 25
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_begin_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 26
if ( ( sched_begin < 1 ) || ( sched_begin > 48 ) )  27
valid_message = FALSE; 29
sched_end = tvb_get_guint8 ( tvb , offset ); 32
if ( sched_end < sched_begin )  34
valid_message = FALSE; 37
if ( valid_message )  40
memset ( & other_slots , 0xFF , sizeof ( other_slots ) ); 44
octet1 = tvb_get_guint8 ( tvb , offset ); 67
if ( ( octet1 & 0x80 ) == 0x80 )  68
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 74
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 75
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , new_slots [ i ] , "%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 76
offset += 2; 79
other_slots [ new_slots [ i ] - 1 ] = msg_id; 80
if ( ( octet1 & 0xC0 ) == 0 )  82
if ( octet1 == 0 )  85
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Repeat of non-existant slot %d" , new_slots [ i ] , octet1 ); 87
if ( octet1 < new_slots [ i ] )  91
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 93
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 96
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 100
if ( octet1 == 0x40 )  105
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, optional reading" , new_slots [ k ] ); 108
if ( octet1 == 0x41 )  112
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, reading advised" , new_slots [ k ] ); 115
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , new_slots [ k ] , "%d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
proto_item_set_end ( item , tvb , offset ); 127
sched_subtree = proto_tree_add_subtree ( sched_tree , tvb , offset , 0 , ett_schedule_new_msg , & item , "Other message slots in this schedule" ); 130
for (k=0; offset < len; ) 132
while ( ( k < sched_end ) && ( other_slots [ k ] != 0xFFFF ) )  140
k ++; 142
if ( k >= sched_end )  144
octet1 = tvb_get_guint8 ( tvb , offset ); 147
if ( ( octet1 & 0x80 ) == 0x80 )  148
if ( ( offset + 1 ) < len )  150
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 156
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 157
other_slots [ k ] = msg_id; 158
k ++; 159
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , k , "%d, Message: %d, First transmission of an SMSCB within the Schedule Period" , k , msg_id ); 160
offset += 2; 163
if ( octet1 && ( ( octet1 & 0xC0 ) == 0 ) )  176
if ( octet1 < k )  179
other_slots [ k ] = other_slots [ octet1 - 1 ]; 181
k ++; 182
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Message ID: %d, Repeat of Slot %d" , k , other_slots [ octet1 - 1 ] , octet1 ); 183
k ++; 189
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Apparent forward reference to slot %d" , k , octet1 ); 190
if ( octet1 == 0x40 )  195
k ++; 198
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, optional reading" , k ); 199
if ( octet1 == 0x41 )  202
k ++; 205
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, reading advised" , k ); 206
k ++; 212
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , k , "%d reserved MDT: %x" , k , octet1 ); 213
proto_item_set_end ( item , tvb , offset ); 217
proto_tree_add_item ( sched_tree , hf_gsm_cbch_padding , tvb , offset , - 1 , ENC_NA ); 218
------------------------------
63 /home/speedy/test/source2slice/NVD/CVE-2016-4082_VULN_dissect_schedule_message.c memset 43
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 1
guint len , offset = 0 ; 3
guint8 sched_begin , sched_end , new_slots [ 48 ] ; 5
gboolean valid_message = TRUE ; 6
schedule_item = proto_tree_add_protocol_format ( top_tree , proto_cbch , tvb , 0 , - 1 , "GSM CBCH Schedule Message" ); 15
sched_tree = proto_item_add_subtree ( schedule_item , ett_schedule_msg ); 18
octet1 = tvb_get_guint8 ( tvb , offset ); 21
if ( 0 == ( octet1 & 0xC0 ) )  22
sched_begin = octet1 & 0x3F; 25
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_begin_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 26
if ( ( sched_begin < 1 ) || ( sched_begin > 48 ) )  27
valid_message = FALSE; 29
sched_end = tvb_get_guint8 ( tvb , offset ); 32
if ( sched_end < sched_begin )  34
valid_message = FALSE; 37
if ( valid_message )  40
memset ( & new_slots , 0xFF , sizeof ( new_slots ) ); 43
new_slots [ k ++ ] = ( i << 3 ) + j + 1; 57
sched_subtree = proto_tree_add_subtree_format ( sched_tree , tvb , offset - 6 , 6 , ett_schedule_new_msg , & item , "This schedule contains %d slots with new messages" , k ); 62
for (i=0; i<k; i++) 64
DISSECTOR_ASSERT ( new_slots [ i ] <= 48 ); 66
octet1 = tvb_get_guint8 ( tvb , offset ); 67
if ( ( octet1 & 0x80 ) == 0x80 )  68
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 74
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 75
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , new_slots [ i ] , "%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 76
offset += 2; 79
other_slots [ new_slots [ i ] - 1 ] = msg_id; 80
if ( ( octet1 & 0xC0 ) == 0 )  82
if ( octet1 == 0 )  85
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Repeat of non-existant slot %d" , new_slots [ i ] , octet1 ); 87
if ( octet1 < new_slots [ i ] )  91
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 93
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 96
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ i ] , "%d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 100
if ( octet1 == 0x40 )  105
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, optional reading" , new_slots [ k ] ); 108
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 110
if ( octet1 == 0x41 )  112
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , new_slots [ k ] , "%d Free Message Slot, reading advised" , new_slots [ k ] ); 115
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , new_slots [ k ] , "%d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 124
proto_item_set_end ( item , tvb , offset ); 127
sched_subtree = proto_tree_add_subtree ( sched_tree , tvb , offset , 0 , ett_schedule_new_msg , & item , "Other message slots in this schedule" ); 130
for (k=0; offset < len; ) 132
while ( ( k < sched_end ) && ( other_slots [ k ] != 0xFFFF ) )  140
k ++; 142
if ( k >= sched_end )  144
octet1 = tvb_get_guint8 ( tvb , offset ); 147
if ( ( octet1 & 0x80 ) == 0x80 )  148
if ( ( offset + 1 ) < len )  150
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 156
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 157
other_slots [ k ] = msg_id; 158
k ++; 159
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 2 , k , "%d, Message: %d, First transmission of an SMSCB within the Schedule Period" , k , msg_id ); 160
offset += 2; 163
if ( octet1 && ( ( octet1 & 0xC0 ) == 0 ) )  176
if ( octet1 < k )  179
other_slots [ k ] = other_slots [ octet1 - 1 ]; 181
k ++; 182
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Message ID: %d, Repeat of Slot %d" , k , other_slots [ octet1 - 1 ] , octet1 ); 183
k ++; 189
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d, Apparent forward reference to slot %d" , k , octet1 ); 190
if ( octet1 == 0x40 )  195
k ++; 198
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, optional reading" , k ); 199
if ( octet1 == 0x41 )  202
k ++; 205
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset ++ , 1 , k , "%d Free Message Slot, reading advised" , k ); 206
k ++; 212
proto_tree_add_uint_format_value ( sched_subtree , hf_gsm_cbch_slot , tvb , offset , 1 , k , "%d reserved MDT: %x" , k , octet1 ); 213
proto_item_set_end ( item , tvb , offset ); 217
proto_tree_add_item ( sched_tree , hf_gsm_cbch_padding , tvb , offset , - 1 , ENC_NA ); 218
------------------------------
64 /home/speedy/test/source2slice/NVD/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memset 168
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; 5
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 6
const struct brcmf_tlv * ssid_ie ; 7
const struct brcmf_tlv * country_ie ; 8
const struct brcmf_tlv * rsn_ie ; 11
const struct brcmf_vs_tlv * wpa_ie ; 12
struct brcmf_join_params join_params ; 13
enum nl80211_iftype dev_role ; 14
u16 chanspec ; 16
bool mbss ; 17
int is_11d ; 18
dev_role = ifp -> vif -> wdev . iftype; 27
mbss = ifp -> vif -> mbss; 28
country_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_COUNTRY ); 32
is_11d = country_ie ? 1 : 0; 35
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); 61
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); 65
if ( wpa_ie != NULL || rsn_ie != NULL )  68
if ( wpa_ie != NULL )  70
err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); 72
if ( err < 0 )  73
struct brcmf_vs_tlv * tmp_ie ; 76
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; 78
err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); 81
if ( err < 0 )  82
if ( ! mbss )  92
chanspec = chandef_to_chanspec ( & cfg -> d11inf , & settings -> chandef ); 93
err = brcmf_fil_iovar_int_set ( ifp , "chanspec" , chanspec ); 95
if ( err < 0 )  96
if ( is_11d != ifp -> vif -> is_11d )  102
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_REGULATORY , is_11d ); 103
if ( err < 0 )  105
if ( settings -> beacon_interval )  110
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_BCNPRD , settings -> beacon_interval ); 111
if ( err < 0 )  113
if ( settings -> dtim_period )  119
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_DTIMPRD , settings -> dtim_period ); 120
if ( err < 0 )  122
if ( ( dev_role == NL80211_IFTYPE_AP ) && ( ( ifp -> ifidx == 0 ) || ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_RSDB ) ) )  128
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_DOWN , 1 ); 131
if ( err < 0 )  132
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_INFRA , 1 ); 139
if ( err < 0 )  140
if ( WARN_ON ( is_11d != ifp -> vif -> is_11d ) )  144
if ( dev_role == NL80211_IFTYPE_AP )  149
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_AP , 1 ); 153
if ( err < 0 )  154
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_UP , 1 ); 158
if ( err < 0 )  159
memset ( & join_params , 0 , sizeof ( join_params ) ); 168
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
------------------------------
65 /home/speedy/test/source2slice/NVD/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memset 37
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
struct brcmf_ssid_le ssid_le ; 9
memset ( & ssid_le , 0 , sizeof ( ssid_le ) ); 37
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
------------------------------
66 /home/speedy/test/source2slice/NVD/CVE_2005_2617_PATCHED_syscall32_setup_pages.c memset 16
int CVE_2005_2617_PATCHED_syscall32_setup_pages(struct linux_binprm *bprm, int exstack) 1
int npages = ( VSYSCALL32_END - VSYSCALL32_BASE ) >> PAGE_SHIFT ; 3
struct vm_area_struct * vma ; 4
vma = kmem_cache_alloc ( vm_area_cachep , SLAB_KERNEL ); 8
if ( ! vma )  9
if ( security_vm_enough_memory ( npages ) )  11
memset ( vma , 0 , sizeof ( struct vm_area_struct ) ); 16
vma -> vm_start = VSYSCALL32_BASE; 18
vma -> vm_end = VSYSCALL32_END; 19
vma -> vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC | VM_MAYEXEC | VM_MAYWRITE; 21
vma -> vm_flags |= mm -> def_flags; 22
vma -> vm_page_prot = protection_map [ vma -> vm_flags & 7 ]; 23
vma -> vm_ops = & syscall32_vm_ops; 24
vma -> vm_mm = mm; 25
if ( ret = insert_vm_struct ( mm , vma ) )  28
kmem_cache_free ( vm_area_cachep , vma ); 30
return ret ; 31
------------------------------
67 /home/speedy/test/source2slice/NVD/CVE_2005_2617_VULN_syscall32_setup_pages.c memset 15
int CVE_2005_2617_VULN_syscall32_setup_pages(struct linux_binprm *bprm, int exstack) 1
int npages = ( VSYSCALL32_END - VSYSCALL32_BASE ) >> PAGE_SHIFT ; 3
struct vm_area_struct * vma ; 4
vma = kmem_cache_alloc ( vm_area_cachep , SLAB_KERNEL ); 7
if ( ! vma )  8
if ( security_vm_enough_memory ( npages ) )  10
memset ( vma , 0 , sizeof ( struct vm_area_struct ) ); 15
vma -> vm_start = VSYSCALL32_BASE; 17
vma -> vm_end = VSYSCALL32_END; 18
vma -> vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC | VM_MAYEXEC | VM_MAYWRITE; 20
vma -> vm_flags |= mm -> def_flags; 21
vma -> vm_page_prot = protection_map [ vma -> vm_flags & 7 ]; 22
vma -> vm_ops = & syscall32_vm_ops; 23
vma -> vm_mm = mm; 24
insert_vm_struct ( mm , vma ); 27
------------------------------
68 /home/speedy/test/source2slice/NVD/CVE_2006_2448_PATCHED_restore_sigcontext.c memset 58
static long CVE_2006_2448_PATCHED_restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,
struct sigcontext __user *sc) 2
elf_vrreg_t __user * v_regs ; 5
unsigned long err = 0 ; 7
elf_greg_t * gregs = ( elf_greg_t * ) regs ; 9
unsigned long msr ; 11
int i ; 13
err |= __copy_from_user ( regs , & sc -> gp_regs , PT_MSR * sizeof ( unsigned long ) ); 20
for (i = PT_MSR+1; i <= PT_RESULT; i++) 24
if ( i == PT_SOFTE )  25
err |= __get_user ( gregs [ i ] , & sc -> gp_regs [ i ] ); 27
if ( set != NULL )  32
err |= __get_user ( set -> sig [ 0 ] , & sc -> oldmask ); 33
err |= __copy_from_user ( & current -> thread . fpr , & sc -> fp_regs , FP_REGS_SIZE ); 44
err |= __get_user ( v_regs , & sc -> v_regs ); 47
err |= __get_user ( msr , & sc -> gp_regs [ PT_MSR ] ); 48
if ( err )  49
if ( v_regs && ! access_ok ( VERIFY_READ , v_regs , 34 * sizeof ( vector128 ) ) )  51
if ( v_regs != 0 && ( msr & MSR_VEC ) != 0 )  54
if ( current -> thread . used_vr )  57
memset ( current -> thread . vr , 0 , 33 * sizeof ( vector128 ) ); 58
err |= __get_user ( current -> thread . vrsave , ( u32 __user * ) & v_regs [ 33 ] ); 61
current -> thread . vrsave = 0; 63
return err ; 69
------------------------------
69 /home/speedy/test/source2slice/NVD/CVE_2006_2448_VULN_restore_sigcontext.c memset 56
static long CVE_2006_2448_VULN_restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,
struct sigcontext __user *sc) 2
elf_vrreg_t __user * v_regs ; 5
unsigned long err = 0 ; 7
elf_greg_t * gregs = ( elf_greg_t * ) regs ; 9
unsigned long msr ; 11
int i ; 13
err |= __copy_from_user ( regs , & sc -> gp_regs , PT_MSR * sizeof ( unsigned long ) ); 20
for (i = PT_MSR+1; i <= PT_RESULT; i++) 24
if ( i == PT_SOFTE )  25
err |= __get_user ( gregs [ i ] , & sc -> gp_regs [ i ] ); 27
if ( set != NULL )  32
err |= __get_user ( set -> sig [ 0 ] , & sc -> oldmask ); 33
err |= __copy_from_user ( & current -> thread . fpr , & sc -> fp_regs , FP_REGS_SIZE ); 44
err |= __get_user ( v_regs , & sc -> v_regs ); 47
err |= __get_user ( msr , & sc -> gp_regs [ PT_MSR ] ); 48
if ( err )  49
if ( v_regs != 0 && ( msr & MSR_VEC ) != 0 )  52
if ( current -> thread . used_vr )  55
memset ( current -> thread . vr , 0 , 33 * sizeof ( vector128 ) ); 56
err |= __get_user ( current -> thread . vrsave , ( u32 __user * ) & v_regs [ 33 ] ); 59
current -> thread . vrsave = 0; 61
return err ; 67
------------------------------
70 /home/speedy/test/source2slice/NVD/CVE_2006_4813_PATCHED___block_prepare_write.c memset 108
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
int err = 0 ; 6
unsigned blocksize , bbits ; 7
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
if ( PageUptodate ( page ) )  62
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  67
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
if ( ! buffer_uptodate ( * wait_bh ) )  78
err = - EIO; 79
if ( ! err )  81
bh = head; 95
block_start = 0; 96
block_end = block_start + blocksize; 98
if ( block_end <= from )  99
if ( block_start >= to )  101
if ( buffer_new ( bh ) )  103
void * kaddr ; 104
kaddr = kmap_atomic ( page , KM_USER0 ); 107
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
block_start = block_end; 114
bh = bh -> b_this_page; 115
while ( bh != head )  116
------------------------------
71 /home/speedy/test/source2slice/NVD/CVE_2006_4813_PATCHED___block_prepare_write.c memset 54
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( PageUptodate ( page ) )  62
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
------------------------------
72 /home/speedy/test/source2slice/NVD/CVE_2006_4813_PATCHED___block_prepare_write.c memset 51
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( PageUptodate ( page ) )  62
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
------------------------------
73 /home/speedy/test/source2slice/NVD/CVE_2006_4813_VULN___block_prepare_write.c memset 104
static int CVE_2006_4813_VULN___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
int err = 0 ; 6
unsigned blocksize , bbits ; 7
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  43
if ( block_end > to || block_start < from )  47
void * kaddr ; 48
kaddr = kmap_atomic ( page , KM_USER0 ); 50
if ( block_end > to )  51
memset ( kaddr + to , 0 , block_end - to ); 52
if ( block_start < from )  54
memset ( kaddr + block_start , 0 , from - block_start ); 55
if ( PageUptodate ( page ) )  63
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  68
* wait_bh ++ = bh; 71
while ( wait_bh > wait )  77
if ( ! buffer_uptodate ( * wait_bh ) )  79
err = - EIO; 80
if ( ! err )  82
bh = head; 91
block_start = 0; 92
block_end = block_start + blocksize; 94
if ( block_end <= from )  95
if ( block_start >= to )  97
if ( buffer_new ( bh ) )  99
void * kaddr ; 100
kaddr = kmap_atomic ( page , KM_USER0 ); 103
memset ( kaddr + block_start , 0 , bh -> b_size ); 104
kunmap_atomic ( kaddr , KM_USER0 ); 105
block_start = block_end; 110
bh = bh -> b_this_page; 111
while ( bh != head )  112
------------------------------
74 /home/speedy/test/source2slice/NVD/CVE_2006_4813_VULN___block_prepare_write.c memset 55
static int CVE_2006_4813_VULN___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  43
if ( block_end > to || block_start < from )  47
void * kaddr ; 48
kaddr = kmap_atomic ( page , KM_USER0 ); 50
if ( block_end > to )  51
memset ( kaddr + to , 0 , block_end - to ); 52
if ( block_start < from )  54
memset ( kaddr + block_start , 0 , from - block_start ); 55
kunmap_atomic ( kaddr , KM_USER0 ); 58
if ( PageUptodate ( page ) )  63
memset ( kaddr + block_start , 0 , bh -> b_size ); 104
kunmap_atomic ( kaddr , KM_USER0 ); 105
------------------------------
75 /home/speedy/test/source2slice/NVD/CVE_2006_4813_VULN___block_prepare_write.c memset 52
static int CVE_2006_4813_VULN___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  43
if ( block_end > to || block_start < from )  47
void * kaddr ; 48
kaddr = kmap_atomic ( page , KM_USER0 ); 50
if ( block_end > to )  51
memset ( kaddr + to , 0 , block_end - to ); 52
memset ( kaddr + block_start , 0 , from - block_start ); 55
kunmap_atomic ( kaddr , KM_USER0 ); 58
if ( PageUptodate ( page ) )  63
memset ( kaddr + block_start , 0 , bh -> b_size ); 104
kunmap_atomic ( kaddr , KM_USER0 ); 105
------------------------------
76 /home/speedy/test/source2slice/NVD/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c memset 109
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
if ( skb -> len < CAPI_MSG_BASELEN + 10 )  12
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 15
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 16
switch ( func )  18
msgnum = CAPIMSG_MSGID ( skb -> data ); 20
if ( skb -> len < CAPI_MSG_BASELEN + 11 + sizeof ( capi_profile ) )  45
msgnum = CAPIMSG_MSGID ( skb -> data ); 49
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  51
if ( ! info && ctrl )  57
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 58
if ( skb -> len < CAPI_MSG_BASELEN + 15 )  68
if ( ! info && ctrl )  73
int len = min_t ( uint , CAPI_MANUFACTURER_LEN , skb -> data [ CAPI_MSG_BASELEN + 14 ] ) ; 74
memset ( ctrl -> manu , 0 , CAPI_MANUFACTURER_LEN ); 77
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , len ); 78
if ( skb -> len < CAPI_MSG_BASELEN + 32 )  85
if ( ! info && ctrl )  90
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 91
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 92
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 93
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 94
if ( skb -> len < CAPI_MSG_BASELEN + 17 )  100
if ( ! info && ctrl )  105
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 109
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , len ); 110
------------------------------
77 /home/speedy/test/source2slice/NVD/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c memset 77
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
if ( skb -> len < CAPI_MSG_BASELEN + 10 )  12
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 15
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 16
switch ( func )  18
msgnum = CAPIMSG_MSGID ( skb -> data ); 20
if ( skb -> len < CAPI_MSG_BASELEN + 11 + sizeof ( capi_profile ) )  45
msgnum = CAPIMSG_MSGID ( skb -> data ); 49
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  51
if ( ! info && ctrl )  57
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 58
if ( skb -> len < CAPI_MSG_BASELEN + 15 )  68
if ( ! info && ctrl )  73
memset ( ctrl -> manu , 0 , CAPI_MANUFACTURER_LEN ); 77
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , len ); 78
if ( ! info && ctrl )  90
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 91
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 92
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 93
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 94
if ( ! info && ctrl )  105
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 109
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , len ); 110
------------------------------
78 /home/speedy/test/source2slice/NVD/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c memset 88
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
------------------------------
79 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 329
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
------------------------------
80 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 281
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
------------------------------
81 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 55
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
------------------------------
82 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memset 325
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 64
mCurLine = real_height; 69
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aBuffer ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aBuffer += toCopy; 126
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aBuffer ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  229
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  230
if ( ! mAlpha )  236
PRUint32 alpha ; 237
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 241
if ( ! mAlpha )  242
mAlphaPtr = mAlpha; 244
if ( ! mDecoded )  247
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 248
if ( ! mDecoded )  249
while ( aCount > 0 )  254
PRUint8 byte ; 255
switch ( mState )  257
mStateData = ( PRUint8 ) * aBuffer ++; 259
aCount --; 260
mState = eRLEStateNeedSecondEscapeByte; 262
byte = * aBuffer ++; 266
aCount --; 267
if ( mStateData != RLE_ESCAPE )  268
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  275
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 276
memset ( mAlphaPtr , 0xFF , mStateData ); 277
mAlphaPtr += mStateData; 278
if ( mBIH . compression == BI_RLE8 )  279
while ( mStateData > 0 )  280
mStateData --; 282
while ( mStateData > 0 )  285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 286
mState = eRLEStateInitial; 290
switch ( byte )  294
mAlphaPtr = mAlpha; 300
mState = eRLEStateInitial; 303
mState = eRLEStateNeedXDelta; 312
mStateData = byte; 317
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  318
mStateData -= mBIH . width & 1; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
memset ( mAlphaPtr , 0xFF , mStateData ); 325
mAlphaPtr += mStateData; 326
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  337
mState = eRLEStateAbsoluteMode; 338
mState = eRLEStateAbsoluteModePadded; 340
byte = * aBuffer ++; 347
aCount --; 348
mAlphaPtr += byte; 349
if ( mAlphaPtr > mAlpha + mBIH . width )  350
mAlphaPtr = mAlpha + mBIH . width; 351
mState = eRLEStateNeedYDelta; 354
byte = * aBuffer ++; 359
aCount --; 360
mState = eRLEStateInitial; 361
if ( byte == 0 )  362
if ( mBIH . compression == BI_RLE8 )  375
while ( aCount > 0 && mStateData > 0 )  376
byte = * aBuffer ++; 377
aCount --; 378
mStateData --; 380
while ( aCount > 0 && mStateData > 0 )  383
byte = * aBuffer ++; 384
aCount --; 385
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 386
if ( mStateData == 0 )  390
if ( mState == eRLEStateAbsoluteMode )  394
mState = eRLEStateInitial; 395
if ( aCount > 0 )  396
aBuffer ++; 399
aCount --; 400
mState = eRLEStateInitial; 401
if ( mCurLine == 0 )  413
------------------------------
83 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memset 277
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 64
mCurLine = real_height; 69
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aBuffer ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aBuffer += toCopy; 126
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aBuffer ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  229
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  230
if ( ! mAlpha )  236
PRUint32 alpha ; 237
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 241
if ( ! mAlpha )  242
mAlphaPtr = mAlpha; 244
if ( ! mDecoded )  247
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 248
if ( ! mDecoded )  249
while ( aCount > 0 )  254
PRUint8 byte ; 255
switch ( mState )  257
mStateData = ( PRUint8 ) * aBuffer ++; 259
aCount --; 260
mState = eRLEStateNeedSecondEscapeByte; 262
byte = * aBuffer ++; 266
aCount --; 267
if ( mStateData != RLE_ESCAPE )  268
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  275
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 276
memset ( mAlphaPtr , 0xFF , mStateData ); 277
mAlphaPtr += mStateData; 278
if ( mBIH . compression == BI_RLE8 )  279
while ( mStateData > 0 )  280
mStateData --; 282
while ( mStateData > 0 )  285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 286
mState = eRLEStateInitial; 290
switch ( byte )  294
mAlphaPtr = mAlpha; 300
mState = eRLEStateInitial; 303
mState = eRLEStateNeedXDelta; 312
mStateData = byte; 317
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  318
mStateData -= mBIH . width & 1; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
memset ( mAlphaPtr , 0xFF , mStateData ); 325
mAlphaPtr += mStateData; 326
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  337
mState = eRLEStateAbsoluteMode; 338
mState = eRLEStateAbsoluteModePadded; 340
byte = * aBuffer ++; 347
aCount --; 348
mAlphaPtr += byte; 349
if ( mAlphaPtr > mAlpha + mBIH . width )  350
mAlphaPtr = mAlpha + mBIH . width; 351
mState = eRLEStateNeedYDelta; 354
byte = * aBuffer ++; 359
aCount --; 360
mState = eRLEStateInitial; 361
if ( byte == 0 )  362
if ( mBIH . compression == BI_RLE8 )  375
while ( aCount > 0 && mStateData > 0 )  376
byte = * aBuffer ++; 377
aCount --; 378
mStateData --; 380
while ( aCount > 0 && mStateData > 0 )  383
byte = * aBuffer ++; 384
aCount --; 385
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 386
if ( mStateData == 0 )  390
if ( mState == eRLEStateAbsoluteMode )  394
mState = eRLEStateInitial; 395
if ( aCount > 0 )  396
aBuffer ++; 399
aCount --; 400
mState = eRLEStateInitial; 401
if ( mCurLine == 0 )  413
------------------------------
84 /home/speedy/test/source2slice/NVD/CVE_2008_3915_PATCHED_init_state.c memset 6
static int
CVE_2008_3915_PATCHED_init_state(struct posix_acl_state *state, int cnt) 2
memset ( state , 0 , sizeof ( struct posix_acl_state ) ); 6
state -> empty = 1; 7
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
------------------------------
85 /home/speedy/test/source2slice/NVD/CVE_2008_3915_VULN_init_state.c memset 6
static int
CVE_2008_3915_VULN_init_state(struct posix_acl_state *state, int cnt) 2
memset ( state , 0 , sizeof ( struct posix_acl_state ) ); 6
state -> empty = 1; 7
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
------------------------------
86 /home/speedy/test/source2slice/NVD/CVE_2009_0675_PATCHED_skfp_ioctl.c memset 21
static int CVE_2009_0675_PATCHED_skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) 1
struct s_smc * smc = netdev_priv ( dev ) ; 3
skfddi_priv * lp = & smc -> os ; 4
struct s_skfp_ioctl ioc ; 5
if ( copy_from_user ( & ioc , rq -> ifr_data , sizeof ( struct s_skfp_ioctl ) ) )  8
switch ( ioc . cmd )  11
if ( ! capable ( CAP_NET_ADMIN ) )  18
memset ( & lp -> MacStat , 0 , sizeof ( lp -> MacStat ) ); 21
------------------------------
87 /home/speedy/test/source2slice/NVD/CVE_2009_0675_VULN_skfp_ioctl.c memset 19
static int CVE_2009_0675_VULN_skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) 1
struct s_smc * smc = netdev_priv ( dev ) ; 3
skfddi_priv * lp = & smc -> os ; 4
struct s_skfp_ioctl ioc ; 5
if ( copy_from_user ( & ioc , rq -> ifr_data , sizeof ( struct s_skfp_ioctl ) ) )  8
switch ( ioc . cmd )  11
if ( ! capable ( CAP_NET_ADMIN ) )  18
memset ( & lp -> MacStat , 0 , sizeof ( lp -> MacStat ) ); 19
------------------------------
88 /home/speedy/test/source2slice/NVD/CVE_2009_0746_PATCHED_make_indexed_dir.c memset 61
static int CVE_2009_0746_PATCHED_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct inode * dir = dentry -> d_parent -> d_inode ; 4
struct buffer_head * bh2 ; 7
struct dx_root * root ; 8
struct ext4_dir_entry_2 * de , * de2 ; 11
int retval ; 14
unsigned blocksize ; 15
struct fake_dirent * fde ; 18
blocksize = dir -> i_sb -> s_blocksize; 20
retval = ext4_journal_get_write_access ( handle , bh ); 22
if ( retval )  23
root = ( struct dx_root * ) bh -> b_data; 28
fde = & root -> dotdot; 31
de = ( struct ext4_dir_entry_2 * ) ( ( char * ) fde + ext4_rec_len_from_disk ( fde -> rec_len ) ); 32
if ( ( char * ) de >= ( ( ( char * ) root ) + blocksize ) )  34
bh2 = ext4_append ( handle , dir , & block , & retval ); 44
if ( ! ( bh2 ) )  45
memset ( & root -> info , 0 , sizeof ( root -> info ) ); 61
root -> info . info_length = sizeof ( root -> info ); 62
root -> info . hash_version = EXT4_SB ( dir -> i_sb ) -> s_def_hash_version; 63
entries = root -> entries; 64
dx_set_block ( entries , 1 ); 65
dx_set_count ( entries , 1 ); 66
dx_set_limit ( entries , dx_root_limit ( dir , sizeof ( root -> info ) ) ); 67
hinfo . hash_version = root -> info . hash_version; 70
hinfo . seed = EXT4_SB ( dir -> i_sb ) -> s_hash_seed; 71
ext4fs_dirhash ( name , namelen , & hinfo ); 72
frame -> entries = entries; 74
frame -> at = entries; 75
frame -> bh = bh; 76
de = do_split ( handle , dir , & bh , frame , & hinfo , & retval ); 78
if ( ! ( de ) )  80
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 83
------------------------------
89 /home/speedy/test/source2slice/NVD/CVE_2009_0746_VULN_make_indexed_dir.c memset 52
static int CVE_2009_0746_VULN_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct inode * dir = dentry -> d_parent -> d_inode ; 4
struct buffer_head * bh2 ; 7
struct dx_root * root ; 8
int retval ; 14
retval = ext4_journal_get_write_access ( handle , bh ); 22
if ( retval )  23
root = ( struct dx_root * ) bh -> b_data; 28
bh2 = ext4_append ( handle , dir , & block , & retval ); 30
if ( ! ( bh2 ) )  31
memset ( & root -> info , 0 , sizeof ( root -> info ) ); 52
root -> info . info_length = sizeof ( root -> info ); 53
root -> info . hash_version = EXT4_SB ( dir -> i_sb ) -> s_def_hash_version; 54
entries = root -> entries; 55
dx_set_block ( entries , 1 ); 56
dx_set_count ( entries , 1 ); 57
dx_set_limit ( entries , dx_root_limit ( dir , sizeof ( root -> info ) ) ); 58
hinfo . hash_version = root -> info . hash_version; 61
hinfo . seed = EXT4_SB ( dir -> i_sb ) -> s_hash_seed; 62
ext4fs_dirhash ( name , namelen , & hinfo ); 63
frame -> entries = entries; 65
frame -> at = entries; 66
frame -> bh = bh; 67
de = do_split ( handle , dir , & bh , frame , & hinfo , & retval ); 69
if ( ! ( de ) )  71
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 74
------------------------------
90 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c memset 27
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
NETRESOURCE net_resource ; 7
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
memset ( & net_resource , 0 , sizeof ( net_resource ) ); 27
net_resource . dwType = RESOURCETYPE_DISK; 28
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
------------------------------
91 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c memset 27
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
NETRESOURCE net_resource ; 7
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
memset ( & net_resource , 0 , sizeof ( net_resource ) ); 27
net_resource . dwType = RESOURCETYPE_DISK; 28
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
------------------------------
92 /home/speedy/test/source2slice/NVD/CVE_2009_4307_PATCHED_ext4_fill_flex_info.c memset 28
static int CVE_2009_4307_PATCHED_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_inodes , ext4_free_inodes_count ( sb , gdp ) ); 40
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_blocks , ext4_free_blks_count ( sb , gdp ) ); 42
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . used_dirs , ext4_used_dirs_count ( sb , gdp ) ); 44
------------------------------
93 /home/speedy/test/source2slice/NVD/CVE_2009_4307_VULN_ext4_fill_flex_info.c memset 28
static int CVE_2009_4307_VULN_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
if ( ! sbi -> s_es -> s_log_groups_per_flex )  11
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 16
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 17
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_inodes , ext4_free_inodes_count ( sb , gdp ) ); 40
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_blocks , ext4_free_blks_count ( sb , gdp ) ); 42
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . used_dirs , ext4_used_dirs_count ( sb , gdp ) ); 44
------------------------------
94 /home/speedy/test/source2slice/NVD/CVE_2010_0437_PATCHED_ip6_dst_lookup_tail.c memset 50
static int CVE_2010_0437_PATCHED_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ( * dst ) -> neighbour && ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
------------------------------
95 /home/speedy/test/source2slice/NVD/CVE_2010_0437_VULN_ip6_dst_lookup_tail.c memset 50
static int CVE_2010_0437_VULN_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
------------------------------
96 /home/speedy/test/source2slice/NVD/CVE_2010_2803_PATCHED_drm_ioctl.c memset 69
long CVE_2010_2803_PATCHED_drm_ioctl(struct file *filp,
unsigned int cmd, unsigned long arg) 2
struct drm_file * file_priv = filp -> private_data ; 4
struct drm_device * dev ; 5
struct drm_ioctl_desc * ioctl ; 6
drm_ioctl_t * func ; 7
unsigned int nr = DRM_IOCTL_NR ( cmd ) ; 8
char stack_kdata [ 128 ] ; 10
char * kdata = NULL ; 11
dev = file_priv -> minor -> dev; 13
if ( ( nr >= DRM_CORE_IOCTL_COUNT ) && ( ( nr < DRM_COMMAND_BASE ) || ( nr >= DRM_COMMAND_END ) ) )  23
if ( ( nr >= DRM_COMMAND_BASE ) && ( nr < DRM_COMMAND_END ) && ( nr < DRM_COMMAND_BASE + dev -> driver -> num_ioctls ) )  26
ioctl = & dev -> driver -> ioctls [ nr - DRM_COMMAND_BASE ]; 28
if ( ( nr >= DRM_COMMAND_END ) || ( nr < DRM_COMMAND_BASE ) )  29
ioctl = & drm_ioctls [ nr ]; 30
cmd = ioctl -> cmd; 31
func = ioctl -> func; 36
if ( ( nr == DRM_IOCTL_NR ( DRM_IOCTL_DMA ) ) && dev -> driver -> dma_ioctl )  38
func = dev -> driver -> dma_ioctl; 39
if ( ! func )  41
if ( ( ( ioctl -> flags & DRM_ROOT_ONLY ) && ! capable ( CAP_SYS_ADMIN ) ) || ( ( ioctl -> flags & DRM_AUTH ) && ! file_priv -> authenticated ) || ( ( ioctl -> flags & DRM_MASTER ) && ! file_priv -> is_master ) || ( ! ( ioctl -> flags & DRM_CONTROL_ALLOW ) && ( file_priv -> minor -> type == DRM_MINOR_CONTROL ) ) )  44
if ( cmd & ( IOC_IN | IOC_OUT ) )  50
if ( _IOC_SIZE ( cmd ) <= sizeof ( stack_kdata ) )  51
kdata = stack_kdata; 52
kdata = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ); 54
if ( ! kdata )  55
if ( cmd & IOC_IN )  62
memset ( kdata , 0 , _IOC_SIZE ( cmd ) ); 69
retcode = func ( dev , kdata , file_priv ); 72
retcode = func ( dev , kdata , file_priv ); 75
if ( copy_to_user ( ( void __user * ) arg , kdata , _IOC_SIZE ( cmd ) ) != 0 )  80
if ( kdata != stack_kdata )  87
kfree ( kdata ); 88
if ( retcode )  90
DRM_DEBUG ( "ret = %x\n" , retcode ); 91
return retcode ; 92
------------------------------
97 /home/speedy/test/source2slice/NVD/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c memset 119
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 81
for (i = 0; i < line_packets; i++) 82
pixel_skip = buf [ stream_ptr ++ ]; 84
pixel_ptr += ( pixel_skip * 2 ); 85
pixel_countdown -= pixel_skip; 86
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 87
if ( byte_run < 0 )  88
byte_run = - byte_run; 89
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 90
stream_ptr += 2; 91
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 93
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 94
pixel_ptr += 2; 95
for (j = 0; j < byte_run; j++, pixel_countdown--) 99
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 100
stream_ptr += 2; 101
pixel_ptr += 2; 102
y_ptr += s -> frame . linesize [ 0 ]; 107
stream_ptr = stream_ptr + chunk_size - 6; 114
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 119
y_ptr = 0; 124
for (lines = 0; lines < s->avctx->height; lines++) 125
stream_ptr ++; 129
pixel_countdown = ( s -> avctx -> width * 2 ); 130
while ( pixel_countdown > 0 )  132
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 133
if ( byte_run > 0 )  134
palette_idx1 = buf [ stream_ptr ++ ]; 135
for (j = 0; j < byte_run; j++) 137
pixels [ pixel_ptr ++ ] = palette_idx1; 138
pixel_countdown --; 139
byte_run = - byte_run; 145
for (j = 0; j < byte_run; j++) 147
palette_idx1 = buf [ stream_ptr ++ ]; 148
pixels [ pixel_ptr ++ ] = palette_idx1; 149
pixel_countdown --; 150
pixel_countdown = s -> avctx -> width; 165
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 167
pixel_ptr += 2; 168
y_ptr += s -> frame . linesize [ 0 ]; 171
y_ptr = 0; 176
for (lines = 0; lines < s->avctx->height; lines++) 177
stream_ptr ++; 181
pixel_countdown = s -> avctx -> width; 182
while ( pixel_countdown > 0 )  184
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 185
if ( byte_run > 0 )  186
stream_ptr += 2; 188
for (j = 0; j < byte_run; j++) 190
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 191
pixel_ptr += 2; 192
pixel_countdown --; 193
byte_run = - byte_run; 199
for (j = 0; j < byte_run; j++) 201
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 202
stream_ptr += 2; 203
pixel_ptr += 2; 204
pixel_countdown --; 205
y_ptr += s -> frame . linesize [ 0 ]; 213
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  220
stream_ptr += chunk_size - 6; 223
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 227
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 232
pixel_ptr += 2; 233
stream_ptr += s -> avctx -> width * 2; 236
stream_ptr += chunk_size - 6; 243
frame_size -= chunk_size; 251
num_chunks --; 252
------------------------------
98 /home/speedy/test/source2slice/NVD/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memset 212
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_ptr = y_ptr; 135
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_ptr += pixel_skip; 141
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
pixels [ pixel_ptr ++ ] = palette_idx1; 150
pixels [ pixel_ptr ++ ] = palette_idx2; 151
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
pixels [ pixel_ptr ++ ] = palette_idx1; 157
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_ptr = y_ptr; 177
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_ptr += pixel_skip; 185
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
pixels [ pixel_ptr ++ ] = palette_idx1; 192
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
pixels [ pixel_ptr ++ ] = palette_idx1; 199
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 212
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixels [ pixel_ptr ++ ] = palette_idx1; 232
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixels [ pixel_ptr ++ ] = palette_idx1; 243
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 265
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
------------------------------
99 /home/speedy/test/source2slice/NVD/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c memset 118
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 80
for (i = 0; i < line_packets; i++) 81
pixel_skip = buf [ stream_ptr ++ ]; 83
pixel_ptr += ( pixel_skip * 2 ); 84
pixel_countdown -= pixel_skip; 85
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 86
if ( byte_run < 0 )  87
byte_run = - byte_run; 88
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 89
stream_ptr += 2; 90
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 92
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 93
pixel_ptr += 2; 94
for (j = 0; j < byte_run; j++, pixel_countdown--) 98
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 99
stream_ptr += 2; 100
pixel_ptr += 2; 101
y_ptr += s -> frame . linesize [ 0 ]; 106
stream_ptr = stream_ptr + chunk_size - 6; 113
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 118
y_ptr = 0; 123
for (lines = 0; lines < s->avctx->height; lines++) 124
stream_ptr ++; 128
pixel_countdown = ( s -> avctx -> width * 2 ); 129
while ( pixel_countdown > 0 )  131
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 132
if ( byte_run > 0 )  133
palette_idx1 = buf [ stream_ptr ++ ]; 134
for (j = 0; j < byte_run; j++) 136
pixels [ pixel_ptr ++ ] = palette_idx1; 137
pixel_countdown --; 138
byte_run = - byte_run; 144
for (j = 0; j < byte_run; j++) 146
palette_idx1 = buf [ stream_ptr ++ ]; 147
pixels [ pixel_ptr ++ ] = palette_idx1; 148
pixel_countdown --; 149
pixel_countdown = s -> avctx -> width; 164
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 166
pixel_ptr += 2; 167
y_ptr += s -> frame . linesize [ 0 ]; 170
y_ptr = 0; 175
for (lines = 0; lines < s->avctx->height; lines++) 176
stream_ptr ++; 180
pixel_countdown = s -> avctx -> width; 181
while ( pixel_countdown > 0 )  183
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 184
if ( byte_run > 0 )  185
stream_ptr += 2; 187
for (j = 0; j < byte_run; j++) 189
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 190
pixel_ptr += 2; 191
pixel_countdown --; 192
byte_run = - byte_run; 198
for (j = 0; j < byte_run; j++) 200
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 201
stream_ptr += 2; 202
pixel_ptr += 2; 203
pixel_countdown --; 204
y_ptr += s -> frame . linesize [ 0 ]; 212
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  219
stream_ptr += chunk_size - 6; 222
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 226
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 231
pixel_ptr += 2; 232
stream_ptr += s -> avctx -> width * 2; 235
stream_ptr += chunk_size - 6; 242
frame_size -= chunk_size; 250
num_chunks --; 251
------------------------------
100 /home/speedy/test/source2slice/NVD/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memset 208
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_ptr = y_ptr; 133
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_ptr += pixel_skip; 138
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
pixels [ pixel_ptr ++ ] = palette_idx1; 147
pixels [ pixel_ptr ++ ] = palette_idx2; 148
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
pixels [ pixel_ptr ++ ] = palette_idx1; 154
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_ptr = y_ptr; 174
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_ptr += pixel_skip; 181
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
pixels [ pixel_ptr ++ ] = palette_idx1; 188
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
pixels [ pixel_ptr ++ ] = palette_idx1; 195
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 208
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixels [ pixel_ptr ++ ] = palette_idx1; 228
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixels [ pixel_ptr ++ ] = palette_idx1; 239
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 261
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
------------------------------
101 /home/speedy/test/source2slice/NVD/CVE_2010_3848_PATCHED_econet_sendmsg.c memset 162
static int CVE_2010_3848_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( dev -> type == ARPHRD_ECONET )  68
if ( udpsock == NULL )  150
if ( len > 32768 )  155
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 162
udpdest . sin_family = AF_INET; 163
udpdest . sin_port = htons ( AUN_PORT ); 164
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 181
------------------------------
102 /home/speedy/test/source2slice/NVD/CVE_2010_3848_VULN_econet_sendmsg.c memset 157
static int CVE_2010_3848_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( len + 15 > dev -> mtu )  68
if ( dev -> type == ARPHRD_ECONET )  73
if ( udpsock == NULL )  150
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 157
udpdest . sin_family = AF_INET; 158
udpdest . sin_port = htons ( AUN_PORT ); 159
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 176
udpmsg . msg_name = ( void * ) & udpdest; 228
udpmsg . msg_namelen = sizeof ( udpdest ); 229
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
------------------------------
103 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c memset 336
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
------------------------------
104 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c memset 85
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
if ( ! process_sdp_o ( value , p ) )  103
res = ( p -> session_modify == FALSE ) ? 0 : - 1; 104
if ( process_sdp_a_audio ( value , p , & newaudiortp , & last_rtpmap_codec ) )  122
if ( process_sdp_a_video ( value , p , & newvideortp , & last_rtpmap_codec ) )  124
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_image ( value , p ) )  128
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
ast_copy_string ( p -> offered_media [ SDP_AUDIO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_AUDIO ] . codecs ) ); 190
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
ast_copy_string ( p -> offered_media [ SDP_VIDEO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_VIDEO ] . codecs ) ); 243
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
ast_copy_string ( p -> offered_media [ SDP_TEXT ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_TEXT ] . codecs ) ); 288
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
ast_verbose ( "Got T.38 offer in SDP in dialog %s\n" , p -> callid ); 329
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
ast_udptl_set_error_correction_scheme ( p -> udptl , UDPTL_ERROR_CORRECTION_NONE ); 340
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
if ( process_sdp_a_audio ( value , p , & newaudiortp , & last_rtpmap_codec ) )  388
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
if ( process_sdp_a_video ( value , p , & newvideortp , & last_rtpmap_codec ) )  397
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
if ( process_sdp_a_image ( value , p ) )  412
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
change_t38_state ( p , T38_DISABLED ); 481
ast_format_cap_joint_copy ( p -> caps , newpeercapability , newjointcapability ); 493
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
ast_verbose ( "Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> caps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , peercapability ) , ast_getformatname_multiple ( s3 , SIPBUFSIZE , vpeercapability ) , ast_getformatname_multiple ( s4 , SIPBUFSIZE , tpeercapability ) , ast_getformatname_multiple ( s5 , SIPBUFSIZE , newjointcapability ) ); 507
ast_verbose ( "Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n" , ast_rtp_lookup_mime_multiple2 ( s1 , NULL , p -> noncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s2 , NULL , peernoncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s3 , NULL , newnoncodeccapability , 0 , 0 ) ); 519
ast_format_cap_copy ( p -> jointcaps , newjointcapability ); 528
ast_format_cap_copy ( p -> peercaps , newpeercapability ); 529
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_PREFERRED_CODEC ) )  533
ast_codec_choose ( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ); 534
ast_format_cap_set ( p -> jointcaps , & tmp_fmt ); 535
if ( p -> rtp )  540
ast_rtp_instance_set_remote_address ( p -> rtp , sa ); 543
ast_rtp_codecs_payloads_copy ( & newaudiortp , ast_rtp_instance_get_codecs ( p -> rtp ) , p -> rtp ); 549
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_RTCP , 1 ); 552
if ( p -> owner )  554
ast_channel_set_fd ( p -> owner , 1 , ast_rtp_instance_fd ( p -> rtp , 1 ) ); 555
if ( ast_test_flag ( & p -> flags [ 0 ] , SIP_DTMF ) == SIP_DTMF_AUTO )  558
ast_clear_flag ( & p -> flags [ 0 ] , SIP_DTMF ); 559
if ( newnoncodeccapability & AST_RTP_DTMF )  560
ast_set_flag ( & p -> flags [ 0 ] , SIP_DTMF_RFC2833 ); 562
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_DTMF , 1 ); 564
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_DTMF_COMPENSATE , ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_RFC2833_COMPENSATE ) ); 565
ast_set_flag ( & p -> flags [ 0 ] , SIP_DTMF_INBAND ); 567
if ( p -> owner )  574
ast_channel_set_fd ( p -> owner , 1 , - 1 ); 575
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_RTCP , 0 ); 578
ast_rtp_instance_stop ( p -> rtp ); 580
if ( p -> vrtp )  587
ast_rtp_instance_set_remote_address ( p -> vrtp , vsa ); 590
ast_rtp_codecs_payloads_copy ( & newvideortp , ast_rtp_instance_get_codecs ( p -> vrtp ) , p -> vrtp ); 595
ast_rtp_instance_stop ( p -> vrtp ); 597
if ( p -> trtp )  604
ast_rtp_instance_set_remote_address ( p -> trtp , tsa ); 607
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
ast_rtp_red_init ( p -> trtp , 300 , red_data_pt , 2 ); 614
ast_rtp_codecs_payloads_copy ( & newtextrtp , ast_rtp_instance_get_codecs ( p -> trtp ) , p -> trtp ); 618
ast_rtp_instance_stop ( p -> trtp ); 620
if ( p -> udptl )  627
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) )  629
ast_rtp_instance_get_remote_address ( p -> rtp , isa ); 630
ast_udptl_set_peer ( p -> udptl , isa ); 636
if ( ! ast_udptl_get_far_max_datagram ( p -> udptl ) )  641
ast_udptl_set_far_max_datagram ( p -> udptl , 0 ); 643
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  650
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  654
ast_channel_lock ( p -> owner ); 655
if ( strcmp ( p -> owner -> exten , "fax" ) )  656
const char * target_context = S_OR ( p -> owner -> macrocontext , p -> owner -> context ) ; 657
ast_channel_unlock ( p -> owner ); 658
if ( ast_exists_extension ( p -> owner , target_context , "fax" , 1 , S_COR ( p -> owner -> caller . id . number . valid , p -> owner -> caller . id . number . str , NULL ) ) )  659
pbx_builtin_setvar_helper ( p -> owner , "FAXEXTEN" , p -> owner -> exten ); 662
if ( ast_async_goto ( p -> owner , target_context , "fax" , 1 ) )  663
ast_log ( LOG_NOTICE , "Failed to async goto '%s' into fax of '%s'\n" , p -> owner -> name , target_context ); 664
ast_channel_unlock ( p -> owner ); 670
ast_udptl_stop ( p -> udptl ); 676
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
ast_debug ( 2 , "We're settling with these formats: %s\n" , ast_getformatname_multiple ( buf , SIPBUFSIZE , p -> jointcaps ) ); 689
if ( ! p -> owner )  691
if ( ast_format_cap_has_type ( p -> jointcaps , AST_FORMAT_TYPE_AUDIO ) )  697
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
ast_codec_choose ( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ); 705
ast_format_cap_set ( p -> owner -> nativeformats , & tmp_fmt ); 707
ast_format_cap_joint_append ( p -> caps , vpeercapability , p -> owner -> nativeformats ); 708
ast_format_cap_joint_append ( p -> caps , tpeercapability , p -> owner -> nativeformats ); 709
ast_set_read_format ( p -> owner , & p -> owner -> readformat ); 711
ast_set_write_format ( p -> owner , & p -> owner -> writeformat ); 712
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_CALL_ONHOLD ) && ( ! ast_sockaddr_isnull ( sa ) || ! ast_sockaddr_isnull ( vsa ) || ! ast_sockaddr_isnull ( tsa ) || ! ast_sockaddr_isnull ( isa ) ) && ( ! sendonly || sendonly == - 1 ) )  715
ast_queue_control ( p -> owner , AST_CONTROL_UNHOLD ); 716
ast_queue_frame ( p -> owner , & ast_null_frame ); 718
ast_queue_control_data ( p -> owner , AST_CONTROL_HOLD , S_OR ( p -> mohsuggest , NULL ) , ! ast_strlen_zero ( p -> mohsuggest ) ? strlen ( p -> mohsuggest ) + 1 : 0 ); 721
ast_rtp_instance_stop ( p -> rtp ); 725
ast_queue_frame ( p -> owner , & ast_null_frame ); 728
return res ; 738
------------------------------
105 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c memset 336
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
106 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c memset 85
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
------------------------------
107 /home/speedy/test/source2slice/NVD/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memset 42
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
108 /home/speedy/test/source2slice/NVD/CVE_2013_6380_VULN_aac_send_raw_srb.c memset 42
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
------------------------------
109 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c memset 388
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
return ret ; 394
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
return ret ; 402
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ); 407
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
av_log ( h -> avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 410
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
av_assert1 ( h -> mb_y < h -> mb_height ); 417
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> nal_unit_type == NAL_IDR_SLICE )  427
get_ue_golomb ( & h -> gb ); 428
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ); 444
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
av_log ( h -> avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 471
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
pred_weight_table ( h ); 500
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
implicit_weight_table ( h , - 1 ); 503
h -> use_weight = 0; 505
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( FRAME_MBAFF ( h ) )  524
ff_h264_fill_mbaff_ref_list ( h ); 525
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  527
implicit_weight_table ( h , 0 ); 528
implicit_weight_table ( h , 1 ); 529
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  533
ff_h264_direct_dist_scale_factor ( h ); 534
ff_h264_direct_ref_list_init ( h ); 535
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & h -> gb ); 538
if ( tmp > 2 )  539
av_log ( h -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 540
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
av_log ( h -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 549
h -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ); 554
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  556
get_bits1 ( & h -> gb ); 557
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  558
get_se_golomb ( & h -> gb ); 560
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & h -> gb ); 566
if ( tmp > 2 )  567
av_log ( h -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 568
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
av_log ( h -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 581
if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
av_log ( h -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 606
av_log ( h -> avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 611
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h -> slice_num = ++ h0 -> current_slice; 626
if ( h -> slice_num )  628
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y; 629
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES )  630
av_log ( h -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 634
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 639
for (i = 0; i < 16; i++) 640
id_list [ i ] = 60; 641
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
for (k = 0; k < h->short_ref_count; k++) 645
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
id_list [ i ] = k; 647
for (k = 0; k < h->long_ref_count; k++) 650
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
if ( h -> ref_count [ 0 ] )  670
h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ]; 670
if ( h -> ref_count [ 1 ] )  671
h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ]; 671
h -> er . ref_count = h -> ref_count [ 0 ]; 672
if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO )  674
av_log ( h -> avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? "F" : h -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 675
------------------------------
110 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c memset 386
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ); 386
------------------------------
111 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c memset 388
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
return ret ; 394
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
return ret ; 402
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ); 407
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
av_log ( h -> avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 410
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
av_assert1 ( h -> mb_y < h -> mb_height ); 417
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> nal_unit_type == NAL_IDR_SLICE )  427
get_ue_golomb ( & h -> gb ); 428
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ); 444
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
av_log ( h -> avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 471
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  527
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  533
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
av_log ( h -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 540
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y; 629
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES )  630
av_log ( h -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 634
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 639
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
for (k = 0; k < h->short_ref_count; k++) 645
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
for (k = 0; k < h->long_ref_count; k++) 650
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 658
for (i = 0; i < 16; i++) 660
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
if ( h -> ref_count [ 0 ] )  670
h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ]; 670
if ( h -> ref_count [ 1 ] )  671
h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ]; 671
h -> er . ref_count = h -> ref_count [ 0 ]; 672
if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO )  674
av_log ( h -> avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? "F" : h -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 675
------------------------------
112 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c memset 386
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ); 386
------------------------------
113 /home/speedy/test/source2slice/NVD/CVE_2013_7011_PATCHED_read_header.c memset 7
static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 11
if ( v >= 2 )  12
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 13
f -> version = v; 16
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 17
if ( f -> ac > 1 )  18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 20
f -> colorspace = get_symbol ( c , state , 0 ); 23
if ( f -> version > 0 )  25
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 26
chroma_planes = get_rac ( c , state ); 28
chroma_h_shift = get_symbol ( c , state , 0 ); 29
chroma_v_shift = get_symbol ( c , state , 0 ); 30
transparency = get_rac ( c , state ); 31
if ( f -> plane_count )  33
if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  34
av_log ( f -> avctx , AV_LOG_ERROR , "Invalid change of global parameters\n" ); 38
f -> chroma_planes = chroma_planes; 43
f -> chroma_h_shift = chroma_h_shift; 44
f -> chroma_v_shift = chroma_v_shift; 45
f -> transparency = transparency; 46
f -> plane_count = 2 + f -> transparency; 48
if ( f -> colorspace == 0 )  51
if ( ! f -> transparency && ! f -> chroma_planes )  52
if ( f -> avctx -> bits_per_raw_sample <= 8 )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 56
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  57
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  58
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 59
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 60
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 61
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 62
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 64
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 66
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  69
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  70
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 71
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 72
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 73
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 75
if ( f -> avctx -> bits_per_raw_sample == 9 )  78
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  80
if ( f -> avctx -> bits_per_raw_sample == 10 )  88
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  90
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 100
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 101
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 102
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 104
if ( f -> colorspace == 1 )  108
if ( f -> chroma_h_shift || f -> chroma_v_shift )  109
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 110
if ( f -> avctx -> bits_per_raw_sample == 9 )  114
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 115
if ( f -> avctx -> bits_per_raw_sample == 10 )  116
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 117
if ( f -> avctx -> bits_per_raw_sample == 12 )  118
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 119
if ( f -> avctx -> bits_per_raw_sample == 14 )  120
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 121
if ( f -> transparency )  123
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 123
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 124
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 126
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 130
if ( f -> version < 2 )  132
context_count = read_quant_tables ( c , f -> quant_table ); 133
if ( context_count < 0 )  134
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 135
if ( f -> version < 3 )  138
f -> slice_count = get_symbol ( c , state , 0 ); 139
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  152
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 153
for (j = 0; j < f->slice_count; j++) 157
FFV1Context * fs = f -> slice_context [ j ] ; 158
fs -> ac = f -> ac; 159
fs -> packed_at_lsb = f -> packed_at_lsb; 160
fs -> slice_damaged = 0; 162
if ( f -> version == 2 )  164
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 165
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 166
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 167
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 168
fs -> slice_x /= f -> num_h_slices; 170
fs -> slice_y /= f -> num_v_slices; 171
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 172
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 173
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  174
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  177
for (i = 0; i < f->plane_count; i++) 182
PlaneContext * const p = & fs -> plane [ i ] 183
if ( f -> version == 2 )  185
int idx = get_symbol ( c , state , 0 ) ; 186
if ( idx > ( unsigned ) f -> quant_table_count )  187
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 188
p -> quant_table_index = idx; 192
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 193
context_count = f -> context_count [ idx ]; 195
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 197
if ( f -> version <= 2 )  200
av_assert0 ( context_count >= 0 ); 201
if ( p -> context_count < context_count )  202
av_freep ( & p -> state ); 203
av_freep ( & p -> vlc_state ); 204
p -> context_count = context_count; 206
------------------------------
114 /home/speedy/test/source2slice/NVD/CVE_2013_7011_VULN_read_header.c memset 7
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 12
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 49
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 58
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 87
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 93
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 109
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 113
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 118
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 136
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 171
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
av_assert0 ( context_count >= 0 ); 184
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
115 /home/speedy/test/source2slice/NVD/CVE_2013_7019_PATCHED_get_cox.c memset 61
static int CVE_2013_7019_PATCHED_get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) 1
if ( bytestream2_get_bytes_left ( & s -> g ) < 5 )  5
c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1; 10
if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS )  11
if ( c -> nreslevels <= s -> reduction_factor )  16
c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor; 27
c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 29
c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 30
if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 )  32
if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 )  38
c -> cblk_style = bytestream2_get_byteu ( & s -> g ); 43
c -> transform = bytestream2_get_byteu ( & s -> g ); 47
if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) )  49
c -> transform = FF_DWT97_INT; 50
if ( c -> csty & JPEG2000_CSTY_PREC )  52
memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ); 60
memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ); 61
------------------------------
116 /home/speedy/test/source2slice/NVD/CVE_2013_7019_PATCHED_get_cox.c memset 60
static int CVE_2013_7019_PATCHED_get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) 1
if ( bytestream2_get_bytes_left ( & s -> g ) < 5 )  5
c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1; 10
if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS )  11
if ( c -> nreslevels <= s -> reduction_factor )  16
c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor; 27
c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 29
c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 30
if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 )  32
if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 )  38
c -> cblk_style = bytestream2_get_byteu ( & s -> g ); 43
c -> transform = bytestream2_get_byteu ( & s -> g ); 47
if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) )  49
c -> transform = FF_DWT97_INT; 50
if ( c -> csty & JPEG2000_CSTY_PREC )  52
memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ); 60
memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ); 61
------------------------------
117 /home/speedy/test/source2slice/NVD/CVE_2013_7019_VULN_get_cox.c memset 54
static int CVE_2013_7019_VULN_get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) 1
if ( bytestream2_get_bytes_left ( & s -> g ) < 5 )  5
c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1; 10
if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS )  11
if ( c -> nreslevels < s -> reduction_factor )  17
c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor; 20
c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 22
c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 23
if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 )  25
if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 )  31
c -> cblk_style = bytestream2_get_byteu ( & s -> g ); 36
c -> transform = bytestream2_get_byteu ( & s -> g ); 40
if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) )  42
c -> transform = FF_DWT97_INT; 43
if ( c -> csty & JPEG2000_CSTY_PREC )  45
memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ); 53
memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ); 54
------------------------------
118 /home/speedy/test/source2slice/NVD/CVE_2013_7019_VULN_get_cox.c memset 53
static int CVE_2013_7019_VULN_get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) 1
if ( bytestream2_get_bytes_left ( & s -> g ) < 5 )  5
c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1; 10
if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS )  11
if ( c -> nreslevels < s -> reduction_factor )  17
c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor; 20
c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 22
c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2; 23
if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 )  25
if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 )  31
c -> cblk_style = bytestream2_get_byteu ( & s -> g ); 36
c -> transform = bytestream2_get_byteu ( & s -> g ); 40
if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) )  42
c -> transform = FF_DWT97_INT; 43
if ( c -> csty & JPEG2000_CSTY_PREC )  45
memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ); 53
memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ); 54
------------------------------
119 /home/speedy/test/source2slice/NVD/CVE_2013_7264_PATCHED_l2tp_ip_recvmsg.c memset 34
static int CVE_2013_7264_PATCHED_l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
size_t len, int noblock, int flags, int *addr_len) 2
struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; 7
struct sk_buff * skb ; 8
if ( flags & MSG_OOB )  10
skb = skb_recv_datagram ( sk , flags , noblock , & err ); 13
if ( ! skb )  14
copied = skb -> len; 17
if ( len < copied )  18
msg -> msg_flags |= MSG_TRUNC; 19
copied = len; 20
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 23
if ( err )  24
if ( sin )  30
sin -> sin_family = AF_INET; 31
sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr; 32
sin -> sin_port = 0; 33
memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ); 34
* addr_len = sizeof ( * sin ); 35
------------------------------
120 /home/speedy/test/source2slice/NVD/CVE_2013_7264_VULN_l2tp_ip_recvmsg.c memset 37
static int CVE_2013_7264_VULN_l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
size_t len, int noblock, int flags, int *addr_len) 2
struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; 7
struct sk_buff * skb ; 8
if ( flags & MSG_OOB )  10
skb = skb_recv_datagram ( sk , flags , noblock , & err ); 16
if ( ! skb )  17
copied = skb -> len; 20
if ( len < copied )  21
msg -> msg_flags |= MSG_TRUNC; 22
copied = len; 23
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 26
if ( err )  27
if ( sin )  33
sin -> sin_family = AF_INET; 34
sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr; 35
sin -> sin_port = 0; 36
memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ); 37
------------------------------
121 /home/speedy/test/source2slice/NVD/CVE_2013_7339_PATCHED_rds_ib_laddr_check.c memset 14
static int CVE_2013_7339_PATCHED_rds_ib_laddr_check(__be32 addr) 1
struct rdma_cm_id * cm_id ; 4
struct sockaddr_in sin ; 5
cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ); 10
if ( IS_ERR ( cm_id ) )  11
memset ( & sin , 0 , sizeof ( sin ) ); 14
sin . sin_family = AF_INET; 15
sin . sin_addr . s_addr = addr; 16
ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ); 19
if ( ret || ! cm_id -> device || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  22
rdsdebug ( "addr %pI4 ret %d node type %d\n" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ); 26
return ret ; 32
------------------------------
122 /home/speedy/test/source2slice/NVD/CVE_2013_7339_VULN_rds_ib_laddr_check.c memset 14
static int CVE_2013_7339_VULN_rds_ib_laddr_check(__be32 addr) 1
struct rdma_cm_id * cm_id ; 4
struct sockaddr_in sin ; 5
cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ); 10
if ( IS_ERR ( cm_id ) )  11
memset ( & sin , 0 , sizeof ( sin ) ); 14
sin . sin_family = AF_INET; 15
sin . sin_addr . s_addr = addr; 16
ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ); 19
if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  22
rdsdebug ( "addr %pI4 ret %d node type %d\n" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ); 25
return ret ; 31
------------------------------
123 /home/speedy/test/source2slice/NVD/CVE_2014_2739_PATCHED_cma_req_handler.c memset 14
static int CVE_2014_2739_PATCHED_cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event) 1
struct rdma_id_private * listen_id , * conn_id ; 3
struct rdma_cm_event event ; 4
listen_id = cm_id -> context; 7
if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) )  8
if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) )  11
memset ( & event , 0 , sizeof event ); 14
event . event = RDMA_CM_EVENT_CONNECT_REQUEST; 16
event . param . ud . private_data = ib_event -> private_data + offset; 19
event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset; 20
ret = conn_id -> id . event_handler ( & conn_id -> id , & event ); 46
if ( ret )  47
return ret ; 74
------------------------------
124 /home/speedy/test/source2slice/NVD/CVE_2014_2739_VULN_cma_req_handler.c memset 23
static int CVE_2014_2739_VULN_cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event) 1
struct rdma_id_private * listen_id , * conn_id ; 3
struct rdma_cm_event event ; 4
listen_id = cm_id -> context; 16
if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) )  17
if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) )  20
memset ( & event , 0 , sizeof event ); 23
event . event = RDMA_CM_EVENT_CONNECT_REQUEST; 25
event . param . ud . private_data = ib_event -> private_data + offset; 28
event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset; 29
ret = conn_id -> id . event_handler ( & conn_id -> id , & event ); 55
if ( ret )  56
return ret ; 100
------------------------------
125 /home/speedy/test/source2slice/NVD/CVE_2014_2894_PATCHED_cmd_smart.c memset 123
static bool CVE_2014_2894_PATCHED_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
int i ; 72
for (i = 0; i < 11; i++) 73
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
s -> status = READY_STAT | SEEK_STAT; 142
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 143
ide_set_irq ( s -> bus ); 144
switch ( s -> sector )  148
s -> smart_selftest_count ++; 152
if ( s -> smart_selftest_count > 21 )  153
s -> smart_selftest_count = 1; 154
n = 2 + ( s -> smart_selftest_count - 1 ) * 24; 156
s -> smart_selftest_data [ n ] = s -> sector; 157
s -> smart_selftest_data [ n + 1 ] = 0x00; 158
s -> smart_selftest_data [ n + 2 ] = 0x34; 159
s -> smart_selftest_data [ n + 3 ] = 0x12; 160
ide_abort_command ( s ); 169
------------------------------
126 /home/speedy/test/source2slice/NVD/CVE_2014_2894_PATCHED_cmd_smart.c memset 111
static bool CVE_2014_2894_PATCHED_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
int i ; 72
for (i = 0; i < 11; i++) 73
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
s -> status = READY_STAT | SEEK_STAT; 142
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 143
ide_set_irq ( s -> bus ); 144
switch ( s -> sector )  148
s -> smart_selftest_count ++; 152
if ( s -> smart_selftest_count > 21 )  153
s -> smart_selftest_count = 1; 154
n = 2 + ( s -> smart_selftest_count - 1 ) * 24; 156
s -> smart_selftest_data [ n ] = s -> sector; 157
s -> smart_selftest_data [ n + 1 ] = 0x00; 158
s -> smart_selftest_data [ n + 2 ] = 0x34; 159
s -> smart_selftest_data [ n + 3 ] = 0x12; 160
ide_abort_command ( s ); 169
------------------------------
127 /home/speedy/test/source2slice/NVD/CVE_2014_2894_PATCHED_cmd_smart.c memset 68
static bool CVE_2014_2894_PATCHED_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = 0; 80
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 104
ide_set_irq ( s -> bus ); 105
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
for (n = 2; n < 506; n++) 129
s -> io_buffer [ n ] = s -> smart_selftest_data [ n ]; 130
for (n = 0; n < 511; n++) 134
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
s -> status = READY_STAT | SEEK_STAT; 142
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 143
ide_set_irq ( s -> bus ); 144
switch ( s -> sector )  148
s -> smart_selftest_count ++; 152
if ( s -> smart_selftest_count > 21 )  153
s -> smart_selftest_count = 1; 154
n = 2 + ( s -> smart_selftest_count - 1 ) * 24; 156
s -> smart_selftest_data [ n ] = s -> sector; 157
s -> smart_selftest_data [ n + 1 ] = 0x00; 158
s -> smart_selftest_data [ n + 2 ] = 0x34; 159
s -> smart_selftest_data [ n + 3 ] = 0x12; 160
ide_abort_command ( s ); 169
------------------------------
128 /home/speedy/test/source2slice/NVD/CVE_2014_2894_PATCHED_cmd_smart.c memset 48
static bool CVE_2014_2894_PATCHED_cmd_smart(IDEState *s, uint8_t cmd) 3
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 63
ide_set_irq ( s -> bus ); 64
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = 0; 80
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 104
ide_set_irq ( s -> bus ); 105
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
for (n = 2; n < 506; n++) 129
s -> io_buffer [ n ] = s -> smart_selftest_data [ n ]; 130
for (n = 0; n < 511; n++) 134
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
s -> status = READY_STAT | SEEK_STAT; 142
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 143
ide_set_irq ( s -> bus ); 144
switch ( s -> sector )  148
s -> smart_selftest_count ++; 152
if ( s -> smart_selftest_count > 21 )  153
s -> smart_selftest_count = 1; 154
n = 2 + ( s -> smart_selftest_count - 1 ) * 24; 156
s -> smart_selftest_data [ n ] = s -> sector; 157
s -> smart_selftest_data [ n + 1 ] = 0x00; 158
s -> smart_selftest_data [ n + 2 ] = 0x34; 159
s -> smart_selftest_data [ n + 3 ] = 0x12; 160
ide_abort_command ( s ); 169
------------------------------
129 /home/speedy/test/source2slice/NVD/CVE_2014_2894_VULN_cmd_smart.c memset 123
static bool CVE_2014_2894_VULN_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
s -> smart_enabled = 0; 17
s -> smart_enabled = 1; 21
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
int i ; 72
for (i = 0; i < 11; i++) 73
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
------------------------------
130 /home/speedy/test/source2slice/NVD/CVE_2014_2894_VULN_cmd_smart.c memset 111
static bool CVE_2014_2894_VULN_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
s -> smart_enabled = 0; 17
s -> smart_enabled = 1; 21
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
int i ; 72
for (i = 0; i < 11; i++) 73
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
------------------------------
131 /home/speedy/test/source2slice/NVD/CVE_2014_2894_VULN_cmd_smart.c memset 68
static bool CVE_2014_2894_VULN_cmd_smart(IDEState *s, uint8_t cmd) 3
int n ; 5
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
s -> smart_enabled = 0; 17
s -> smart_enabled = 1; 21
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 51
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = 0; 80
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 104
ide_set_irq ( s -> bus ); 105
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
for (n = 2; n < 506; n++) 129
s -> io_buffer [ n ] = s -> smart_selftest_data [ n ]; 130
for (n = 0; n < 511; n++) 134
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
------------------------------
132 /home/speedy/test/source2slice/NVD/CVE_2014_2894_VULN_cmd_smart.c memset 48
static bool CVE_2014_2894_VULN_cmd_smart(IDEState *s, uint8_t cmd) 3
if ( s -> hcyl != 0xc2 || s -> lcyl != 0x4f )  7
if ( ! s -> smart_enabled && s -> feature != SMART_ENABLE )  11
switch ( s -> feature )  15
s -> smart_enabled = 0; 17
s -> smart_enabled = 1; 21
switch ( s -> sector )  25
s -> smart_autosave = 0; 27
s -> smart_autosave = 1; 30
if ( ! s -> smart_errors )  38
s -> hcyl = 0x2c; 42
s -> lcyl = 0xf4; 43
memset ( s -> io_buffer , 0 , 0x200 ); 48
s -> io_buffer [ 0 ] = 0x01; 49
s -> io_buffer [ 2 + 0 + ( n * 12 ) ] = smart_attributes [ n ] [ 0 ]; 52
s -> io_buffer [ 2 + 1 + ( n * 12 ) ] = smart_attributes [ n ] [ 11 ]; 53
for (n = 0; n < 511; n++) 57
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 58
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 60
s -> status = READY_STAT | SEEK_STAT; 62
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 63
ide_set_irq ( s -> bus ); 64
memset ( s -> io_buffer , 0 , 0x200 ); 68
s -> io_buffer [ 0 ] = 0x01; 69
for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) 71
s -> io_buffer [ 2 + i + ( n * 12 ) ] = smart_attributes [ n ] [ i ]; 74
s -> io_buffer [ 362 ] = 0x02 | ( s -> smart_autosave ? 0x80 : 0x00 ); 78
if ( s -> smart_selftest_count == 0 )  79
s -> io_buffer [ 363 ] = 0; 80
s -> io_buffer [ 363 ] = s -> smart_selftest_data [ 3 + ( s -> smart_selftest_count - 1 ) * 24 ]; 82
s -> io_buffer [ 364 ] = 0x20; 87
s -> io_buffer [ 365 ] = 0x01; 88
s -> io_buffer [ 367 ] = ( 1 << 4 | 1 << 3 | 1 ); 90
s -> io_buffer [ 368 ] = 0x03; 91
s -> io_buffer [ 369 ] = 0x00; 92
s -> io_buffer [ 370 ] = 0x01; 93
s -> io_buffer [ 372 ] = 0x02; 94
s -> io_buffer [ 373 ] = 0x36; 95
s -> io_buffer [ 374 ] = 0x01; 96
for (n = 0; n < 511; n++) 98
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 99
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 101
s -> status = READY_STAT | SEEK_STAT; 103
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); 104
ide_set_irq ( s -> bus ); 105
switch ( s -> sector )  109
memset ( s -> io_buffer , 0 , 0x200 ); 111
s -> io_buffer [ 0 ] = 0x01; 112
s -> io_buffer [ 1 ] = 0x00; 113
s -> io_buffer [ 452 ] = s -> smart_errors & 0xff; 114
s -> io_buffer [ 453 ] = ( s -> smart_errors & 0xff00 ) >> 8; 115
for (n = 0; n < 511; n++) 117
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 118
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 120
memset ( s -> io_buffer , 0 , 0x200 ); 123
s -> io_buffer [ 0 ] = 0x01; 124
if ( s -> smart_selftest_count == 0 )  125
s -> io_buffer [ 508 ] = 0; 126
for (n = 2; n < 506; n++) 129
s -> io_buffer [ n ] = s -> smart_selftest_data [ n ]; 130
for (n = 0; n < 511; n++) 134
s -> io_buffer [ 511 ] += s -> io_buffer [ n ]; 135
s -> io_buffer [ 511 ] = 0x100 - s -> io_buffer [ 511 ]; 137
------------------------------
133 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c memset 267
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int csl , sil , cl ; 19
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  126
v [ 1 ] = 0xff; 127
v [ 1 ] = p [ 10 ]; 129
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  130
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  132
s -> version = TLS1_2_VERSION; 135
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  138
s -> version = TLS1_1_VERSION; 141
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  144
s -> version = TLS1_VERSION; 146
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  149
s -> version = SSL3_VERSION; 151
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  158
s -> version = SSL3_VERSION; 160
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  163
s -> version = TLS1_VERSION; 167
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  172
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  180
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  188
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  196
p = s -> packet; 202
v [ 0 ] = p [ 3 ]; 203
v [ 1 ] = p [ 4 ]; 204
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 218
if ( n > ( 1024 * 4 ) )  219
if ( n < 9 )  224
j = ssl23_read_bytes ( s , n + 2 ); 230
if ( j <= 0 )  234
d = ( unsigned char * ) s -> init_buf -> data; 245
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  246
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 255
d += 3; 258
* ( d ++ ) = SSL3_VERSION_MAJOR; 261
* ( d ++ ) = v [ 1 ]; 262
memset ( d , 0 , SSL3_RANDOM_SIZE ); 267
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 268
d += SSL3_RANDOM_SIZE; 269
* ( d ++ ) = 0; 272
dd = d; 276
d += 2; 277
* ( d ++ ) = p [ i + 1 ]; 281
* ( d ++ ) = p [ i + 2 ]; 282
s2n ( j , dd ); 285
* ( d ++ ) = 1; 288
* ( d ++ ) = 0; 289
while ( p < s -> packet + s -> packet_length )  294
* ( d ++ ) = * ( p ++ ); 296
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 300
l2n3 ( ( long ) i , d_len ); 301
s -> s3 -> tmp . message_size = i; 306
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  364
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 367
s -> rstate = SSL_ST_READ_HEADER; 373
s -> packet_length = n; 374
if ( s -> s3 -> rbuf . buf == NULL )  375
if ( ! ssl3_setup_read_buffer ( s ) )  376
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 379
memcpy ( s -> packet , buf , n ); 380
s -> s3 -> rbuf . left = n; 381
s -> s3 -> rbuf . offset = 0; 382
s -> s3 -> rbuf . left = 0; 387
s -> s3 -> rbuf . offset = 0; 388
if ( s -> version == TLS1_2_VERSION )  390
s -> method = TLSv1_2_server_method ( ); 391
if ( s -> version == TLS1_1_VERSION )  392
if ( s -> version == TLS1_VERSION )  394
s -> handshake_func = s -> method -> ssl_accept; 401
s -> init_num = 0; 410
return ( SSL_accept ( s ) ) ; 413
------------------------------
134 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c memset 251
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int csl , sil , cl ; 19
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
v [ 0 ] = p [ 1 ]; 107
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  130
v [ 1 ] = 0xff; 131
v [ 1 ] = p [ 10 ]; 133
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  134
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  136
s -> version = TLS1_2_VERSION; 139
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  142
s -> version = TLS1_1_VERSION; 145
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  148
s -> version = TLS1_VERSION; 150
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  153
s -> version = SSL3_VERSION; 155
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  162
s -> version = SSL3_VERSION; 164
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  167
s -> version = TLS1_VERSION; 171
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  176
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  184
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  192
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  200
p = s -> packet; 206
v [ 0 ] = p [ 3 ]; 207
v [ 1 ] = p [ 4 ]; 208
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 210
if ( n > ( 1024 * 4 ) )  211
j = ssl23_read_bytes ( s , n + 2 ); 217
if ( j <= 0 )  218
d = ( unsigned char * ) s -> init_buf -> data; 229
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  230
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 239
d += 3; 242
* ( d ++ ) = SSL3_VERSION_MAJOR; 245
* ( d ++ ) = v [ 1 ]; 246
memset ( d , 0 , SSL3_RANDOM_SIZE ); 251
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 252
d += SSL3_RANDOM_SIZE; 253
* ( d ++ ) = 0; 256
dd = d; 260
d += 2; 261
* ( d ++ ) = p [ i + 1 ]; 265
* ( d ++ ) = p [ i + 2 ]; 266
s2n ( j , dd ); 269
* ( d ++ ) = 1; 272
* ( d ++ ) = 0; 273
while ( p < s -> packet + s -> packet_length )  278
* ( d ++ ) = * ( p ++ ); 280
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 284
l2n3 ( ( long ) i , d_len ); 285
s -> s3 -> tmp . message_size = i; 290
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  348
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 351
s -> rstate = SSL_ST_READ_HEADER; 357
s -> packet_length = n; 358
if ( s -> s3 -> rbuf . buf == NULL )  359
if ( ! ssl3_setup_read_buffer ( s ) )  360
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 363
memcpy ( s -> packet , buf , n ); 364
s -> s3 -> rbuf . left = n; 365
s -> s3 -> rbuf . offset = 0; 366
s -> s3 -> rbuf . left = 0; 371
s -> s3 -> rbuf . offset = 0; 372
if ( s -> version == TLS1_2_VERSION )  374
s -> method = TLSv1_2_server_method ( ); 375
if ( s -> version == TLS1_1_VERSION )  376
if ( s -> version == TLS1_VERSION )  378
s -> handshake_func = s -> method -> ssl_accept; 385
s -> init_num = 0; 394
return ( SSL_accept ( s ) ) ; 397
------------------------------
135 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c memset 417
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
context -> accept_socket = INVALID_SOCKET; 271
if ( context -> accept_socket == INVALID_SOCKET )  283
err_count = 0; 289
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
context -> overlapped . Pointer = NULL; 328
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
------------------------------
136 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c memset 413
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
context -> accept_socket = INVALID_SOCKET; 271
if ( context -> accept_socket == INVALID_SOCKET )  283
err_count = 0; 289
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
context -> overlapped . Pointer = NULL; 325
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 341
while ( rv == WAIT_IO_COMPLETION )  342
if ( rv != WAIT_OBJECT_0 + 2 )  345
context -> sa_server = ( void * ) context -> buff; 352
context -> sa_server_len = sizeof ( context -> buff ) / 2; 353
context -> sa_client_len = context -> sa_server_len; 354
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 355
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 358
if ( context -> accept_socket == INVALID_SOCKET )  361
rv = apr_get_netos_error ( ); 363
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  364
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  378
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  383
context -> overlapped . Pointer = NULL; 399
err_count = 0; 400
context -> sa_server_len = sizeof ( context -> buff ) / 2; 402
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  403
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  409
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 413
sockinfo . os_sock = & context -> accept_socket; 417
sockinfo . local = context -> sa_server; 418
sockinfo . remote = context -> sa_client; 419
sockinfo . family = context -> sa_server -> sa_family; 420
sockinfo . type = SOCK_STREAM; 421
sockinfo . protocol = IPPROTO_TCP; 422
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 428
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 429
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 431
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 433
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 438
context = NULL; 441
------------------------------
137 /home/speedy/test/source2slice/NVD/CVE_2014_3640_PATCHED_udp_input.c memset 58
void
CVE_2014_3640_PATCHED_udp_input(register struct mbuf *m, int iphlen) 3
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
memset ( & ( ( struct ipovly * ) ip ) -> ih_mbuf , 0 , sizeof ( struct mbuf_ptr ) ); 58
------------------------------
138 /home/speedy/test/source2slice/NVD/CVE_2014_3640_VULN_udp_input.c memset 58
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
memset ( & ( ( struct ipovly * ) ip ) -> ih_mbuf , 0 , sizeof ( struct mbuf_ptr ) ); 58
------------------------------
139 /home/speedy/test/source2slice/NVD/CVE_2014_4654_PATCHED_snd_ctl_elem_add.c memset 18
static int CVE_2014_4654_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_kcontrol kctl , * _kctl ; 5
if ( info -> count < 1 )  11
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
------------------------------
140 /home/speedy/test/source2slice/NVD/CVE_2014_4654_VULN_snd_ctl_elem_add.c memset 20
static int CVE_2014_4654_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
141 /home/speedy/test/source2slice/NVD/CVE_2014_4655_PATCHED_snd_ctl_elem_add.c memset 18
static int CVE_2014_4655_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_kcontrol kctl , * _kctl ; 5
if ( info -> count < 1 )  11
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
------------------------------
142 /home/speedy/test/source2slice/NVD/CVE_2014_4655_VULN_snd_ctl_elem_add.c memset 20
static int CVE_2014_4655_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
143 /home/speedy/test/source2slice/NVD/CVE_2014_5163_PATCHED_decode_apn.c memset 8
static void
CVE_2014_5163_PATCHED_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH + 1 ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
------------------------------
144 /home/speedy/test/source2slice/NVD/CVE_2014_5163_VULN_decode_apn.c memset 8
static void
CVE_2014_5163_VULN_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
------------------------------
145 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 153
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for(y = 0; y < avctx->height ; y++ ) 151
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
memset ( row , 0 , avctx -> width << 2 ); 153
decodeplane32 ( ( uint32_t * ) row , s -> planebuf , s -> planesize , plane ); 156
------------------------------
146 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 143
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for (y = 0; y < avctx->height ; y++) 141
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 143
for (plane = 0; plane < s->bpp; plane++) 144
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
decodeplane8 ( s -> ham_buf , s -> planebuf , s -> planesize , plane ); 146
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 148
decode_rgb8 ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 185
decode_rgbn ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 187
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
* ( AVFrame * ) data = s -> frame; 206
------------------------------
147 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 133
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
for (y = 0; y < avctx->height ; y++ ) 131
memset ( s -> mask_buf , 0 , avctx -> width * sizeof ( uint32_t ) ); 133
for (plane = 0; plane < s->bpp; plane++) 134
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
decodeplane32 ( s -> mask_buf , s -> planebuf , s -> planesize , plane ); 136
lookup_pal_indicies ( ( uint32_t * ) row , s -> mask_buf , s -> mask_palbuf , avctx -> width ); 138
------------------------------
148 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 124
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
for(y = 0; y < avctx->height ; y++ ) 122
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
memset ( row , 0 , avctx -> width ); 124
decodeplane8 ( row , s -> planebuf , s -> planesize , plane ); 127
------------------------------
149 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 94
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for(y = 0; y < avctx->height; y++ ) 92
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 93
memset ( row , 0 , avctx -> width << 2 ); 94
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
------------------------------
150 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 84
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for (y = 0; y < avctx->height; y++) 82
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 84
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
buf += s -> planesize; 87
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 89
------------------------------
151 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 75
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
for(y = 0; y < avctx->height; y++ ) 73
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 74
memset ( row , 0 , avctx -> width ); 75
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
------------------------------
152 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 47
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
for(y = 0; y < avctx->height; y++) 45
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 47
for (plane = 0; plane < s->bpp; plane++) 48
const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
------------------------------
153 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 44
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 46
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
memset ( row , 0 , avctx -> width ); 124
decodeplane8 ( row , s -> planebuf , s -> planesize , plane ); 127
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 132
lookup_pal_indicies ( ( uint32_t * ) row , s -> mask_buf , s -> mask_palbuf , avctx -> width ); 138
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 142
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 148
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
memset ( row , 0 , avctx -> width << 2 ); 153
decodeplane32 ( ( uint32_t * ) row , s -> planebuf , s -> planesize , plane ); 156
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 163
buf += decode_byterun ( row , avctx -> width , buf , buf_end ); 164
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 168
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 170
decode_deep_rle32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 177
decode_rgb8 ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 185
decode_rgbn ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 187
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
* ( AVFrame * ) data = s -> frame; 206
------------------------------
154 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memset 35
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 35
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
------------------------------
155 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 153
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for(y = 0; y < avctx->height ; y++ ) 151
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
memset ( row , 0 , avctx -> width << 2 ); 153
decodeplane32 ( ( uint32_t * ) row , s -> planebuf , s -> planesize , plane ); 156
------------------------------
156 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 143
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for (y = 0; y < avctx->height ; y++) 141
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 143
for (plane = 0; plane < s->bpp; plane++) 144
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
decodeplane8 ( s -> ham_buf , s -> planebuf , s -> planesize , plane ); 146
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 148
decode_rgb8 ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 185
decode_rgbn ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 187
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
* ( AVFrame * ) data = s -> frame; 206
------------------------------
157 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 133
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
for (y = 0; y < avctx->height ; y++ ) 131
memset ( s -> mask_buf , 0 , avctx -> width * sizeof ( uint32_t ) ); 133
for (plane = 0; plane < s->bpp; plane++) 134
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
decodeplane32 ( s -> mask_buf , s -> planebuf , s -> planesize , plane ); 136
lookup_pal_indicies ( ( uint32_t * ) row , s -> mask_buf , s -> mask_palbuf , avctx -> width ); 138
------------------------------
158 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 124
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
for(y = 0; y < avctx->height ; y++ ) 122
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
memset ( row , 0 , avctx -> width ); 124
decodeplane8 ( row , s -> planebuf , s -> planesize , plane ); 127
------------------------------
159 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 94
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for(y = 0; y < avctx->height; y++ ) 92
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 93
memset ( row , 0 , avctx -> width << 2 ); 94
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
------------------------------
160 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 84
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for (y = 0; y < avctx->height; y++) 82
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 84
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
buf += s -> planesize; 87
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 89
------------------------------
161 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 75
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
for(y = 0; y < avctx->height; y++ ) 73
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 74
memset ( row , 0 , avctx -> width ); 75
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
------------------------------
162 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 47
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
for(y = 0; y < avctx->height; y++) 45
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 47
for (plane = 0; plane < s->bpp; plane++) 48
const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
------------------------------
163 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 44
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 46
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
------------------------------
164 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memset 35
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 35
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
------------------------------
165 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c memset 476
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
SHELLEXECUTEINFO sinfo ; 475
memset ( & sinfo , 0 , sizeof ( SHELLEXECUTEINFO ) ); 476
sinfo . cbSize = sizeof ( SHELLEXECUTEINFO ); 477
sinfo . fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOCLOSEPROCESS; 478
sinfo . hwnd = nullptr; 481
sinfo . lpFile = argv [ 0 ]; 482
sinfo . lpParameters = cmdLine; 483
sinfo . nShow = SW_SHOWNORMAL; 485
bool result = ShellExecuteEx ( & sinfo ) ; 487
if ( result )  490
WaitForSingleObject ( sinfo . hProcess , INFINITE ); 491
CloseHandle ( sinfo . hProcess ); 492
------------------------------
166 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c memset 476
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
HKEY baseKey ; 372
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
SHELLEXECUTEINFO sinfo ; 475
memset ( & sinfo , 0 , sizeof ( SHELLEXECUTEINFO ) ); 476
sinfo . cbSize = sizeof ( SHELLEXECUTEINFO ); 477
sinfo . fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOCLOSEPROCESS; 478
sinfo . hwnd = nullptr; 481
sinfo . lpFile = argv [ 0 ]; 482
sinfo . lpParameters = cmdLine; 483
sinfo . nShow = SW_SHOWNORMAL; 485
bool result = ShellExecuteEx ( & sinfo ) ; 487
if ( result )  490
WaitForSingleObject ( sinfo . hProcess , INFINITE ); 491
CloseHandle ( sinfo . hProcess ); 492
------------------------------
167 /home/speedy/test/source2slice/NVD/CVE_2015_3339_PATCHED_prepare_binprm.c memset 13
int CVE_2015_3339_PATCHED_prepare_binprm(struct linux_binprm *bprm) 1
int retval ; 3
retval = security_bprm_set_creds ( bprm ); 8
if ( retval )  9
bprm -> cred_prepared = 1; 11
memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ); 13
return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; 14
------------------------------
168 /home/speedy/test/source2slice/NVD/CVE_2015_3339_VULN_prepare_binprm.c memset 40
int CVE_2015_3339_VULN_prepare_binprm(struct linux_binprm *bprm) 1
struct inode * inode = file_inode ( bprm -> file ) ; 3
umode_t mode = inode -> i_mode ; 4
int retval ; 5
bprm -> cred -> euid = current_euid ( ); 9
bprm -> cred -> egid = current_egid ( ); 10
if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) )  12
if ( mode & S_ISUID )  17
bprm -> per_clear |= PER_CLEAR_ON_SETID; 18
bprm -> cred -> euid = inode -> i_uid; 19
if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) )  28
bprm -> per_clear |= PER_CLEAR_ON_SETID; 29
bprm -> cred -> egid = inode -> i_gid; 30
retval = security_bprm_set_creds ( bprm ); 35
if ( retval )  36
bprm -> cred_prepared = 1; 38
memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ); 40
return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; 41
------------------------------
169 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c MoveFileEx 795
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( ! sStagedUpdate && ! sReplaceRequest && _wrmdir ( DELETE_DIR ) )  783
if ( MoveFileEx ( DELETE_DIR , nullptr , MOVEFILE_DELAY_UNTIL_REBOOT ) )  795
------------------------------
170 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c MoveFileEx 795
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( ! sStagedUpdate && ! sReplaceRequest && _wrmdir ( DELETE_DIR ) )  783
if ( MoveFileEx ( DELETE_DIR , nullptr , MOVEFILE_DELAY_UNTIL_REBOOT ) )  795
------------------------------
171 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strdup 130
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
* title = strdup ( "Server Error" ); 130
------------------------------
172 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strdup 125
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
* title = strdup ( "Server Error" ); 125
------------------------------
173 /home/speedy/test/source2slice/NVD/CVE_2014_3640_PATCHED_udp_input.c strerror 158
void
CVE_2014_3640_PATCHED_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so == & slirp -> udb || so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
m -> m_len += iphlen; 154
m -> m_data -= iphlen; 155
icmp_error ( m , ICMP_UNREACH , ICMP_UNREACH_NET , 0 , strerror ( errno ) ); 158
------------------------------
174 /home/speedy/test/source2slice/NVD/CVE_2014_3640_PATCHED_udp_input.c strerror 157
void
CVE_2014_3640_PATCHED_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so == & slirp -> udb || so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
DEBUG_MISC ( ( dfd , "udp tx errno = %d-%s\n" , errno , strerror ( errno ) ) ); 157
------------------------------
175 /home/speedy/test/source2slice/NVD/CVE_2014_3640_PATCHED_udp_input.c strerror 119
void
CVE_2014_3640_PATCHED_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so == & slirp -> udb || so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
DEBUG_MISC ( ( dfd , " udp_attach errno = %d-%s\n" , errno , strerror ( errno ) ) ); 119
------------------------------
176 /home/speedy/test/source2slice/NVD/CVE_2014_3640_VULN_udp_input.c strerror 158
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
m -> m_len += iphlen; 154
m -> m_data -= iphlen; 155
icmp_error ( m , ICMP_UNREACH , ICMP_UNREACH_NET , 0 , strerror ( errno ) ); 158
------------------------------
177 /home/speedy/test/source2slice/NVD/CVE_2014_3640_VULN_udp_input.c strerror 157
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
DEBUG_MISC ( ( dfd , "udp tx errno = %d-%s\n" , errno , strerror ( errno ) ) ); 157
------------------------------
178 /home/speedy/test/source2slice/NVD/CVE_2014_3640_VULN_udp_input.c strerror 119
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
DEBUG_MISC ( ( dfd , " udp_attach errno = %d-%s\n" , errno , strerror ( errno ) ) ); 119
------------------------------
179 /home/speedy/test/source2slice/NVD/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 80
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
fprintf ( stderr , "\n" ); 80
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
------------------------------
180 /home/speedy/test/source2slice/NVD/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 79
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
------------------------------
181 /home/speedy/test/source2slice/NVD/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 76
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
fprintf ( stderr , "\n" ); 80
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
------------------------------
182 /home/speedy/test/source2slice/NVD/CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext.c fprintf 77
int CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
s -> session -> tlsext_ecpointformatlist_length = 0; 63
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  65
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 70
fprintf ( stderr , "CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 73
fprintf ( stderr , "\n" ); 77
if ( type == TLSEXT_TYPE_session_ticket )  82
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  84
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  90
s -> tlsext_ticket_expected = 1; 96
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  99
unsigned char * sdata = data ; 102
if ( size < 2 )  104
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  110
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  118
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 119
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 121
if ( s -> s3 -> server_opaque_prf_input == NULL )  123
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  130
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  136
s -> tlsext_status_expected = 1; 142
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  145
unsigned char * selected ; 148
unsigned char selected_len ; 149
if ( s -> ctx -> next_proto_select_cb == NULL )  152
if ( ! ssl_next_proto_validate ( data , size ) )  158
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  163
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 168
if ( ! s -> next_proto_negotiated )  169
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 174
s -> next_proto_negotiated_len = selected_len; 175
s -> s3 -> next_proto_neg_seen = 1; 176
if ( type == TLSEXT_TYPE_renegotiate )  179
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  181
if ( type == TLSEXT_TYPE_heartbeat )  186
switch ( data [ 0 ] )  188
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 195
if ( type == TLSEXT_TYPE_use_srtp )  202
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  204
data += size; 209
------------------------------
183 /home/speedy/test/source2slice/NVD/CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext.c fprintf 76
int CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
s -> session -> tlsext_ecpointformatlist_length = 0; 63
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  65
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 70
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 71
fprintf ( stderr , "CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 74
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 75
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 76
if ( type == TLSEXT_TYPE_session_ticket )  82
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  84
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  90
s -> tlsext_ticket_expected = 1; 96
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  99
unsigned char * sdata = data ; 102
if ( size < 2 )  104
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  110
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  118
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 119
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 121
if ( s -> s3 -> server_opaque_prf_input == NULL )  123
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  130
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  136
s -> tlsext_status_expected = 1; 142
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  145
unsigned char * selected ; 148
unsigned char selected_len ; 149
if ( s -> ctx -> next_proto_select_cb == NULL )  152
if ( ! ssl_next_proto_validate ( data , size ) )  158
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  163
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 168
if ( ! s -> next_proto_negotiated )  169
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 174
s -> next_proto_negotiated_len = selected_len; 175
s -> s3 -> next_proto_neg_seen = 1; 176
if ( type == TLSEXT_TYPE_renegotiate )  179
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  181
if ( type == TLSEXT_TYPE_heartbeat )  186
switch ( data [ 0 ] )  188
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 195
if ( type == TLSEXT_TYPE_use_srtp )  202
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  204
data += size; 209
------------------------------
184 /home/speedy/test/source2slice/NVD/CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext.c fprintf 73
int CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
s -> session -> tlsext_ecpointformatlist_length = 0; 63
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  65
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 70
fprintf ( stderr , "CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 73
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 76
fprintf ( stderr , "\n" ); 77
if ( type == TLSEXT_TYPE_session_ticket )  82
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  84
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  90
s -> tlsext_ticket_expected = 1; 96
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  99
unsigned char * sdata = data ; 102
if ( size < 2 )  104
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  110
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  118
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 119
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 121
if ( s -> s3 -> server_opaque_prf_input == NULL )  123
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  130
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  136
s -> tlsext_status_expected = 1; 142
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  145
unsigned char * selected ; 148
unsigned char selected_len ; 149
if ( s -> ctx -> next_proto_select_cb == NULL )  152
if ( ! ssl_next_proto_validate ( data , size ) )  158
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  163
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 168
if ( ! s -> next_proto_negotiated )  169
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 174
s -> next_proto_negotiated_len = selected_len; 175
s -> s3 -> next_proto_neg_seen = 1; 176
if ( type == TLSEXT_TYPE_renegotiate )  179
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  181
if ( type == TLSEXT_TYPE_heartbeat )  186
switch ( data [ 0 ] )  188
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 195
if ( type == TLSEXT_TYPE_use_srtp )  202
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  204
data += size; 209
------------------------------
185 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c fprintf 322
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
fprintf ( stderr , "Unable to create elevated lock file! Exiting\n" ); 322
------------------------------
186 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c fprintf 184
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
187 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c fprintf 37
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
fprintf ( stderr , "Usage: updater patch-dir install-dir apply-to-dir [wait-pid [callback-working-dir callback-path args...]]\n" ); 37
------------------------------
188 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c fprintf 322
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
fprintf ( stderr , "Unable to create elevated lock file! Exiting\n" ); 322
fprintf ( stderr , "The post update process which runs as the user"
" for service update could not be launched." ) 462
------------------------------
189 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c fprintf 184
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
190 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c fprintf 37
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
fprintf ( stderr , "Usage: updater patch-dir install-dir apply-to-dir [wait-pid [callback-working-dir callback-path args...]]\n" ); 37
------------------------------
191 /home/speedy/test/source2slice/NVD/CVE_2005_3356_PATCHED_sys_mq_open.c strlen 17
asmlinkage long CVE_2005_3356_PATCHED_sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
struct mq_attr __user *u_attr) 2
struct dentry * dentry ; 4
char * name ; 6
int fd , error ; 7
if ( IS_ERR ( name = getname ( u_name ) ) )  9
fd = get_unused_fd ( ); 12
if ( fd < 0 )  13
dentry = lookup_one_len ( name , mqueue_mnt -> mnt_root , strlen ( name ) ); 17
if ( IS_ERR ( dentry ) )  18
error = PTR_ERR ( dentry ); 19
if ( dentry -> d_inode )  25
filp = do_open ( dentry , oflag ); 29
filp = do_create ( mqueue_mnt -> mnt_root , dentry , oflag , mode , u_attr ); 31
if ( ! dentry -> d_inode )  36
filp = do_open ( dentry , oflag ); 38
if ( IS_ERR ( filp ) )  41
error = PTR_ERR ( filp ); 42
fd_install ( fd , filp ); 47
dput ( dentry ); 51
fd = error; 56
return fd ; 61
------------------------------
192 /home/speedy/test/source2slice/NVD/CVE_2005_3356_VULN_sys_mq_open.c strlen 17
asmlinkage long CVE_2005_3356_VULN_sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
struct mq_attr __user *u_attr) 2
struct dentry * dentry ; 4
char * name ; 6
int fd , error ; 7
if ( IS_ERR ( name = getname ( u_name ) ) )  9
fd = get_unused_fd ( ); 12
if ( fd < 0 )  13
dentry = lookup_one_len ( name , mqueue_mnt -> mnt_root , strlen ( name ) ); 17
if ( IS_ERR ( dentry ) )  18
error = PTR_ERR ( dentry ); 19
if ( dentry -> d_inode )  25
filp = ( oflag & O_EXCL ) ? ERR_PTR ( - EEXIST ) : do_open ( dentry , oflag ); 26
filp = do_create ( mqueue_mnt -> mnt_root , dentry , oflag , mode , u_attr ); 29
filp = ( dentry -> d_inode ) ? do_open ( dentry , oflag ) : ERR_PTR ( - ENOENT ); 33
dput ( dentry ); 36
if ( IS_ERR ( filp ) )  38
error = PTR_ERR ( filp ); 39
fd_install ( fd , filp ); 44
fd = error; 51
return fd ; 56
------------------------------
193 /home/speedy/test/source2slice/NVD/CVE_2005_4618_PATCHED_sysctl_string.c strlen 14
int CVE_2005_4618_PATCHED_sysctl_string(ctl_table *table, int __user *name, int nlen,
void __user *oldval, size_t __user *oldlenp,
void __user *newval, size_t newlen, void **context) 3
size_t l , len ; 5
if ( ! table -> data || ! table -> maxlen )  7
if ( oldval && oldlenp )  10
if ( get_user ( len , oldlenp ) )  11
if ( len )  13
l = strlen ( table -> data ) + 1; 14
if ( len > l )  15
len = l; 15
if ( len >= table -> maxlen )  16
if ( copy_to_user ( oldval , table -> data , len ) )  18
if ( put_user ( len , oldlenp ) )  20
------------------------------
194 /home/speedy/test/source2slice/NVD/CVE_2005_4618_VULN_sysctl_string.c strlen 14
int CVE_2005_4618_VULN_sysctl_string(ctl_table *table, int __user *name, int nlen,
void __user *oldval, size_t __user *oldlenp,
void __user *newval, size_t newlen, void **context) 3
size_t l , len ; 5
if ( ! table -> data || ! table -> maxlen )  7
if ( oldval && oldlenp )  10
if ( get_user ( len , oldlenp ) )  11
if ( len )  13
l = strlen ( table -> data ); 14
if ( len > l )  15
len = l; 15
if ( len >= table -> maxlen )  16
if ( copy_to_user ( oldval , table -> data , len ) )  18
if ( put_user ( 0 , ( ( char __user * ) oldval ) + len ) )  20
if ( put_user ( len , oldlenp ) )  22
------------------------------
195 /home/speedy/test/source2slice/NVD/CVE_2007_1217_VULN_bufprint.c strlen 7
static void CVE_2007_1217_VULN_bufprint(char *fmt,...) 1
va_list f ; 3
vsprintf ( p , fmt , f ); 5
p += strlen ( p ); 7
------------------------------
196 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 410
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  400
if ( arg )  404
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  407
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 409
if ( strlen ( iocts . drvid ) )  410
------------------------------
197 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 385
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
* p = 0; 412
------------------------------
198 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 383
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
------------------------------
199 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 379
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
* p = 0; 412
------------------------------
200 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 335
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
------------------------------
201 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 250
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
------------------------------
202 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 121
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int ret ; 8
char * s ; 11
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  92
if ( copy_from_user ( name , argp , sizeof ( name ) ) )  93
s = name; 95
s = NULL; 97
ret = down_interruptible ( & dev -> sem ); 99
if ( ret )  100
if ( s = isdn_net_new ( s , NULL ) )  101
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  102
ret = - EFAULT; 103
ret = 0; 105
ret = - ENODEV; 108
if ( arg )  113
if ( copy_from_user ( bname , argp , sizeof ( bname ) - 1 ) )  114
ret = down_interruptible ( & dev -> sem ); 118
if ( ret )  119
if ( s = isdn_net_newslave ( bname ) )  120
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  121
------------------------------
203 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strlen 102
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int ret ; 8
char * s ; 11
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  92
if ( copy_from_user ( name , argp , sizeof ( name ) ) )  93
s = name; 95
s = NULL; 97
ret = down_interruptible ( & dev -> sem ); 99
if ( ret )  100
if ( s = isdn_net_new ( s , NULL ) )  101
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  102
------------------------------
204 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 407
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  398
if ( arg )  402
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  405
if ( strlen ( iocts . drvid ) )  407
------------------------------
205 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 383
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
* p = 0; 409
------------------------------
206 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 381
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
------------------------------
207 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 377
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
* p = 0; 409
------------------------------
208 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 333
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
------------------------------
209 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 249
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
------------------------------
210 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 121
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int ret ; 8
char * s ; 11
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  92
if ( copy_from_user ( name , argp , sizeof ( name ) ) )  93
s = name; 95
s = NULL; 97
ret = down_interruptible ( & dev -> sem ); 99
if ( ret )  100
if ( s = isdn_net_new ( s , NULL ) )  101
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  102
ret = - EFAULT; 103
ret = 0; 105
ret = - ENODEV; 108
if ( arg )  113
if ( copy_from_user ( bname , argp , sizeof ( bname ) - 1 ) )  114
ret = down_interruptible ( & dev -> sem ); 118
if ( ret )  119
if ( s = isdn_net_newslave ( bname ) )  120
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  121
------------------------------
211 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strlen 102
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int ret ; 8
char * s ; 11
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  92
if ( copy_from_user ( name , argp , sizeof ( name ) ) )  93
s = name; 95
s = NULL; 97
ret = down_interruptible ( & dev -> sem ); 99
if ( ret )  100
if ( s = isdn_net_new ( s , NULL ) )  101
if ( copy_to_user ( argp , s , strlen ( s ) + 1 ) )  102
------------------------------
212 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 112
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
------------------------------
213 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 111
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
214 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 108
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
215 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 108
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
216 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 65
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
------------------------------
217 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strlen 65
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
------------------------------
218 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 107
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
------------------------------
219 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 106
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
220 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
221 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
222 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 60
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
------------------------------
223 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strlen 60
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
------------------------------
224 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strlen 91
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
225 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strlen 88
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
226 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strlen 91
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
227 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strlen 88
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
228 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c strlen 95
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
ast_copy_string ( cause_code -> chan_name , ast_channel_name ( p -> owner ) , AST_CHANNEL_NAME ); 98
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
------------------------------
229 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c strlen 95
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
ast_copy_string ( cause_code -> chan_name , ast_channel_name ( p -> owner ) , AST_CHANNEL_NAME ); 98
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
------------------------------
230 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strlen 721
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int sendonly = - 1 ; 52
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tsa && tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_CALL_ONHOLD ) && ( ! ast_sockaddr_isnull ( sa ) || ! ast_sockaddr_isnull ( vsa ) || ! ast_sockaddr_isnull ( tsa ) || ! ast_sockaddr_isnull ( isa ) ) && ( ! sendonly || sendonly == - 1 ) )  715
if ( ( sockaddr_is_null_or_any ( sa ) && sockaddr_is_null_or_any ( vsa ) && sockaddr_is_null_or_any ( tsa ) && sockaddr_is_null_or_any ( isa ) ) || ( sendonly && sendonly != - 1 ) )  720
ast_queue_control_data ( p -> owner , AST_CONTROL_HOLD , S_OR ( p -> mohsuggest , NULL ) , ! ast_strlen_zero ( p -> mohsuggest ) ? strlen ( p -> mohsuggest ) + 1 : 0 ); 721
------------------------------
231 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strlen 721
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int sendonly = - 1 ; 52
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_CALL_ONHOLD ) && ( ! ast_sockaddr_isnull ( sa ) || ! ast_sockaddr_isnull ( vsa ) || ! ast_sockaddr_isnull ( tsa ) || ! ast_sockaddr_isnull ( isa ) ) && ( ! sendonly || sendonly == - 1 ) )  715
if ( ( sockaddr_is_null_or_any ( sa ) && sockaddr_is_null_or_any ( vsa ) && sockaddr_is_null_or_any ( tsa ) && sockaddr_is_null_or_any ( isa ) ) || ( sendonly && sendonly != - 1 ) )  720
ast_queue_control_data ( p -> owner , AST_CONTROL_HOLD , S_OR ( p -> mohsuggest , NULL ) , ! ast_strlen_zero ( p -> mohsuggest ) ? strlen ( p -> mohsuggest ) + 1 : 0 ); 721
------------------------------
232 /home/speedy/test/source2slice/NVD/CVE_2014_1690_PATCHED_help.c strlen 58
static unsigned int CVE_2014_1690_PATCHED_help(struct sk_buff *skb,
enum ip_conntrack_info ctinfo,
unsigned int protoff,
unsigned int matchoff,
unsigned int matchlen,
struct nf_conntrack_expect *exp) 6
char buffer [ sizeof ( "4294967296 65635" ) ] ; 8
struct nf_conn * ct = exp -> master ; 9
union nf_inet_addr newaddr ; 10
u_int16_t port ; 11
unsigned int ret ; 12
newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3; 15
exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port; 17
exp -> dir = IP_CT_DIR_REPLY; 18
exp -> expectfn = nf_nat_follow_master; 19
for (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) 22
int ret ; 23
exp -> tuple . dst . u . tcp . port = htons ( port ); 25
ret = nf_ct_expect_related ( exp ); 26
if ( ret == 0 )  27
if ( ret != - EBUSY )  29
port = 0; 30
if ( port == 0 )  35
snprintf ( buffer , sizeof ( buffer ) , "%u %u" , ntohl ( newaddr . ip ) , port ); 54
ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ); 58
if ( ret != NF_ACCEPT )  60
return ret ; 65
------------------------------
233 /home/speedy/test/source2slice/NVD/CVE_2014_1690_VULN_help.c strlen 36
static unsigned int CVE_2014_1690_VULN_help(struct sk_buff *skb,
enum ip_conntrack_info ctinfo,
unsigned int protoff,
unsigned int matchoff,
unsigned int matchlen,
struct nf_conntrack_expect *exp) 6
char buffer [ sizeof ( "4294967296 65635" ) ] ; 8
u_int16_t port ; 9
unsigned int ret ; 10
exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port; 13
exp -> dir = IP_CT_DIR_REPLY; 14
exp -> expectfn = nf_nat_follow_master; 15
for (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) 18
int ret ; 19
exp -> tuple . dst . u . tcp . port = htons ( port ); 21
ret = nf_ct_expect_related ( exp ); 22
if ( ret == 0 )  23
if ( ret != - EBUSY )  25
port = 0; 26
if ( port == 0 )  31
ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ); 36
if ( ret != NF_ACCEPT )  39
return ret ; 43
------------------------------
234 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strlen 146
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
if ( language [ 3 ] )  131
language [ 0 ] = '\0'; 132
language [ 0 ] = '\0'; 134
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
ptr = filename + strlen ( filename ); 146
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
------------------------------
235 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strlen 116
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( con -> uri [ strlen ( con -> uri ) - 1 ] != '/' )  116
------------------------------
236 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strlen 125
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
if ( language [ 3 ] )  110
language [ 0 ] = '\0'; 111
language [ 0 ] = '\0'; 113
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
ptr = filename + strlen ( filename ); 125
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
------------------------------
237 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strlen 95
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( con -> uri [ strlen ( con -> uri ) - 1 ] != '/' )  95
------------------------------
238 /home/speedy/test/source2slice/NVD/CVE_2015_0253_PATCHED_read_request_line.c strlen 88
static int CVE_2015_0253_PATCHED_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
const char * ll ; 3
apr_size_t len ; 9
int num_blank_lines = 0 ; 10
int max_blank_lines = r -> server -> limit_req_fields ; 11
if ( max_blank_lines <= 0 )  13
max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS; 14
apr_status_t rv ; 33
r -> the_request = NULL; 38
rv = ap_rgetline ( & ( r -> the_request ) , ( apr_size_t ) ( r -> server -> limit_req_line + 2 ) , & len , r , 0 , bb ); 39
if ( rv != APR_SUCCESS )  42
while ( ( len <= 0 ) && ( ++ num_blank_lines < max_blank_lines ) )  62
r -> request_time = apr_time_now ( ); 70
ll = r -> the_request; 71
if ( ll [ 0 ] )  85
len = strlen ( ll ); 88
r -> protocol = apr_pstrmemdup ( r -> pool , pro , len ); 94
if ( len == 8 && pro [ 0 ] == 'H' && pro [ 1 ] == 'T' && pro [ 2 ] == 'T' && pro [ 3 ] == 'P' && pro [ 4 ] == '/' && apr_isdigit ( pro [ 5 ] ) && pro [ 6 ] == '.' && apr_isdigit ( pro [ 7 ] ) )  97
r -> proto_num = HTTP_VERSION ( pro [ 5 ] - '0' , pro [ 7 ] - '0' ); 101
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
------------------------------
239 /home/speedy/test/source2slice/NVD/CVE_2015_0253_VULN_read_request_line.c strlen 88
static int CVE_2015_0253_VULN_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
const char * ll ; 3
apr_size_t len ; 9
int num_blank_lines = 0 ; 10
int max_blank_lines = r -> server -> limit_req_fields ; 11
if ( max_blank_lines <= 0 )  13
max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS; 14
apr_status_t rv ; 33
r -> the_request = NULL; 38
rv = ap_rgetline ( & ( r -> the_request ) , ( apr_size_t ) ( r -> server -> limit_req_line + 2 ) , & len , r , 0 , bb ); 39
if ( rv != APR_SUCCESS )  42
while ( ( len <= 0 ) && ( ++ num_blank_lines < max_blank_lines ) )  62
r -> request_time = apr_time_now ( ); 70
ll = r -> the_request; 71
if ( ll [ 0 ] )  85
len = strlen ( ll ); 88
r -> protocol = apr_pstrmemdup ( r -> pool , pro , len ); 94
if ( len == 8 && pro [ 0 ] == 'H' && pro [ 1 ] == 'T' && pro [ 2 ] == 'T' && pro [ 3 ] == 'P' && pro [ 4 ] == '/' && apr_isdigit ( pro [ 5 ] ) && pro [ 6 ] == '.' && apr_isdigit ( pro [ 7 ] ) )  97
r -> proto_num = HTTP_VERSION ( pro [ 5 ] - '0' , pro [ 7 ] - '0' ); 101
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
------------------------------
240 /home/speedy/test/source2slice/NVD/CVE_2015_3008_PATCHED_handle_tcptls_connection.c strlen 88
static void *CVE_2015_3008_PATCHED_handle_tcptls_connection(void *data) 1
struct ast_tcptls_session_instance * tcptls_session = data ; 3
int ( * ssl_setup ) ( SSL * ) = ( tcptls_session -> client ) ? SSL_connect : SSL_accept 5
int ret ; 6
if ( ast_thread_inhibit_escalations ( ) )  15
tcptls_session -> stream_cookie = tcptls_stream_alloc ( ); 22
if ( ! tcptls_session -> stream_cookie )  23
if ( ! tcptls_session -> parent -> tls_cfg )  32
if ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) )  42
if ( ( ret = ssl_setup ( tcptls_session -> ssl ) ) <= 0 )  44
if ( tcptls_session -> f = tcptls_stream_fopen ( tcptls_session -> stream_cookie , tcptls_session -> ssl , tcptls_session -> fd , - 1 ) )  46
if ( ( tcptls_session -> client && ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_DONT_VERIFY_SERVER ) ) || ( ! tcptls_session -> client && ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_VERIFY_CLIENT ) ) )  48
X509 * peer ; 50
long res ; 51
peer = SSL_get_peer_certificate ( tcptls_session -> ssl ); 52
if ( ! peer )  53
res = SSL_get_verify_result ( tcptls_session -> ssl ); 60
if ( res != X509_V_OK )  61
if ( ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_IGNORE_COMMON_NAME ) )  68
ASN1_STRING * str ; 69
unsigned char * str2 ; 70
X509_NAME * name = X509_get_subject_name ( peer ) ; 71
int pos = - 1 ; 72
int found = 0 ; 73
pos = X509_NAME_get_index_by_NID ( name , NID_commonName , pos ); 78
if ( pos < 0 )  79
str = X509_NAME_ENTRY_get_data ( X509_NAME_get_entry ( name , pos ) ); 81
ret = ASN1_STRING_to_UTF8 ( & str2 , str ); 82
if ( ret < 0 )  83
if ( str2 )  87
if ( strlen ( ( char * ) str2 ) != ret )  88
if ( ! strcasecmp ( tcptls_session -> parent -> hostname , ( char * ) str2 ) )  90
found = 1; 91
if ( found )  96
------------------------------
241 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c execv 14
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
execv ( argv [ 0 ] , argv ); 14
------------------------------
242 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c execv 14
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
execv ( argv [ 0 ] , argv ); 14
------------------------------
243 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c sprintf 64
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
unsigned long timo ; 6
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
timo = key -> expiry - now . tv_sec; 53
if ( timo < 60 )  55
if ( timo < 60 * 60 )  57
if ( timo < 60 * 60 * 24 )  59
if ( timo < 60 * 60 * 24 * 7 )  61
sprintf ( xbuf , "%luw" , timo / ( 60 * 60 * 24 * 7 ) ); 64
seq_printf ( m , "%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s " , key -> serial , showflag ( key , 'I' , KEY_FLAG_INSTANTIATED ) , showflag ( key , 'R' , KEY_FLAG_REVOKED ) , showflag ( key , 'D' , KEY_FLAG_DEAD ) , showflag ( key , 'Q' , KEY_FLAG_IN_QUOTA ) , showflag ( key , 'U' , KEY_FLAG_USER_CONSTRUCT ) , showflag ( key , 'N' , KEY_FLAG_NEGATIVE ) , showflag ( key , 'i' , KEY_FLAG_INVALIDATED ) , atomic_read ( & key -> usage ) , xbuf , key -> perm , from_kuid_munged ( seq_user_ns ( m ) , key -> uid ) , from_kgid_munged ( seq_user_ns ( m ) , key -> gid ) , key -> type -> name ); 70
------------------------------
244 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c sprintf 62
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
unsigned long timo ; 6
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
timo = key -> expiry - now . tv_sec; 53
if ( timo < 60 )  55
sprintf ( xbuf , "%lus" , timo ); 56
if ( timo < 60 * 60 )  57
sprintf ( xbuf , "%lum" , timo / 60 ); 58
if ( timo < 60 * 60 * 24 )  59
sprintf ( xbuf , "%luh" , timo / ( 60 * 60 ) ); 60
if ( timo < 60 * 60 * 24 * 7 )  61
sprintf ( xbuf , "%lud" , timo / ( 60 * 60 * 24 ) ); 62
------------------------------
245 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c sprintf 60
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
unsigned long timo ; 6
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
timo = key -> expiry - now . tv_sec; 53
if ( timo < 60 )  55
sprintf ( xbuf , "%lus" , timo ); 56
if ( timo < 60 * 60 )  57
sprintf ( xbuf , "%lum" , timo / 60 ); 58
if ( timo < 60 * 60 * 24 )  59
sprintf ( xbuf , "%luh" , timo / ( 60 * 60 ) ); 60
sprintf ( xbuf , "%lud" , timo / ( 60 * 60 * 24 ) ); 62
------------------------------
246 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c sprintf 58
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
unsigned long timo ; 6
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
timo = key -> expiry - now . tv_sec; 53
if ( timo < 60 )  55
sprintf ( xbuf , "%lus" , timo ); 56
if ( timo < 60 * 60 )  57
sprintf ( xbuf , "%lum" , timo / 60 ); 58
sprintf ( xbuf , "%luh" , timo / ( 60 * 60 ) ); 60
sprintf ( xbuf , "%lud" , timo / ( 60 * 60 * 24 ) ); 62
------------------------------
247 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c sprintf 56
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
unsigned long timo ; 6
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
timo = key -> expiry - now . tv_sec; 53
if ( timo < 60 )  55
sprintf ( xbuf , "%lus" , timo ); 56
sprintf ( xbuf , "%lum" , timo / 60 ); 58
sprintf ( xbuf , "%luh" , timo / ( 60 * 60 ) ); 60
sprintf ( xbuf , "%lud" , timo / ( 60 * 60 * 24 ) ); 62
------------------------------
248 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c sprintf 377
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
* p = 0; 409
------------------------------
249 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c sprintf 88
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 89
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
if ( tmp != s -> outputstr -> str )  116
free ( tmp ); 117
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
250 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c sprintf 83
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
251 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c sprintf 41
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_share [ 0 ] = 0; 32
sprintf ( psz_remote , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
------------------------------
252 /home/speedy/test/source2slice/NVD/CVE_2009_2768_PATCHED_load_flat_shared_library.c sprintf 8
static int CVE_2009_2768_PATCHED_load_flat_shared_library(int id, struct lib_info *libs) 1
char buf [ 16 ] ; 5
sprintf ( buf , "/lib/lib%d.so" , id ); 8
bprm . filename = buf; 11
bprm . file = open_exec ( bprm . filename ); 12
res = PTR_ERR ( bprm . file ); 13
if ( IS_ERR ( bprm . file ) )  14
return res ; 15
bprm . cred = prepare_exec_creds ( ); 17
if ( ! bprm . cred )  19
res = prepare_binprm ( & bprm ); 22
if ( res <= ( unsigned long ) - 4096 )  24
res = load_flat_file ( & bprm , libs , id , NULL ); 25
abort_creds ( bprm . cred ); 27
allow_write_access ( bprm . file ); 30
fput ( bprm . file ); 31
return ( res ) ; 33
------------------------------
253 /home/speedy/test/source2slice/NVD/CVE_2009_2768_VULN_load_flat_shared_library.c sprintf 8
static int CVE_2009_2768_VULN_load_flat_shared_library(int id, struct lib_info *libs) 1
char buf [ 16 ] ; 5
sprintf ( buf , "/lib/lib%d.so" , id ); 8
bprm . filename = buf; 11
bprm . file = open_exec ( bprm . filename ); 12
res = PTR_ERR ( bprm . file ); 13
if ( IS_ERR ( bprm . file ) )  14
return res ; 15
res = prepare_binprm ( & bprm ); 17
if ( res <= ( unsigned long ) - 4096 )  19
res = load_flat_file ( & bprm , libs , id , NULL ); 20
if ( bprm . file )  21
allow_write_access ( bprm . file ); 22
fput ( bprm . file ); 23
bprm . file = NULL; 24
return ( res ) ; 26
------------------------------
254 /home/speedy/test/source2slice/NVD/CVE_2010_1488_PATCHED_proc_oom_score.c sprintf 11
static int CVE_2010_1488_PATCHED_proc_oom_score(struct task_struct *task, char *buffer) 1
unsigned long points = 0 ; 3
struct timespec uptime ; 4
if ( pid_alive ( task ) )  8
points = badness ( task , uptime . tv_sec ); 9
return sprintf ( buffer , "%lu\n" , points ) ; 11
------------------------------
255 /home/speedy/test/source2slice/NVD/CVE_2010_1488_VULN_proc_oom_score.c sprintf 10
static int CVE_2010_1488_VULN_proc_oom_score(struct task_struct *task, char *buffer) 1
unsigned long points ; 3
struct timespec uptime ; 4
points = badness ( task -> group_leader , uptime . tv_sec ); 8
return sprintf ( buffer , "%lu\n" , points ) ; 10
------------------------------
256 /home/speedy/test/source2slice/NVD/CVE_2010_2431_PATCHED_cupsFileOpen.c strrchr 57
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_PATCHED_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  57
* portname ++ = '\0'; 58
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  66
if ( ! httpAddrConnect ( addrlist , & fd ) )  73
httpAddrFreeList ( addrlist ); 75
httpAddrFreeList ( addrlist ); 79
------------------------------
257 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c strrchr 46
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
httpAddrFreeList ( addrlist ); 64
httpAddrFreeList ( addrlist ); 68
------------------------------
258 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c free 118
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
if ( s -> outputstr )  99
free ( s -> outputstr ); 118
------------------------------
259 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c free 117
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp != s -> outputstr -> str )  116
free ( tmp ); 117
------------------------------
260 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c free 113
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
if ( s -> outputstr )  94
free ( s -> outputstr ); 113
------------------------------
261 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c free 112
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
------------------------------
262 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c free 488
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
free ( cmdLine ); 488
------------------------------
263 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c free 488
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
HKEY baseKey ; 372
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
free ( cmdLine ); 488
------------------------------
264 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c rand 38
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 40
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 46
time ( & s -> sessiontimeout ); 51
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
ast_mutex_unlock ( & s -> __lock ); 56
if ( s )  58
if ( process_message ( s , & m ) )  71
if ( s -> authenticated )  72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 75
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 77
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 81
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 83
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 89
ast_mutex_lock ( & s -> __lock ); 98
if ( s -> outputstr )  99
tmp = xml_translate ( s -> outputstr -> str , params ); 102
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
if ( tmp != s -> outputstr -> str )  116
free ( tmp ); 117
free ( s -> outputstr ); 118
s -> outputstr = NULL; 119
ast_mutex_unlock ( & s -> __lock ); 121
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
ast_mutex_lock ( & s -> __lock ); 132
if ( s -> needdestroy )  133
if ( s -> inuse == 1 )  134
if ( s -> waiting_thread != AST_PTHREADT_NULL )  139
pthread_kill ( s -> waiting_thread , SIGURG ); 140
s -> inuse --; 141
s -> inuse --; 144
ast_mutex_unlock ( & s -> __lock ); 145
destroy_session ( s ); 148
return retval ; 152
------------------------------
265 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c rand 33
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 35
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 41
time ( & s -> sessiontimeout ); 46
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
ast_mutex_unlock ( & s -> __lock ); 51
if ( s )  53
if ( process_message ( s , & m ) )  66
if ( s -> authenticated )  67
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 70
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 76
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 78
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
ast_mutex_lock ( & s -> __lock ); 93
if ( s -> outputstr )  94
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
free ( s -> outputstr ); 113
s -> outputstr = NULL; 114
ast_mutex_unlock ( & s -> __lock ); 116
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
ast_mutex_lock ( & s -> __lock ); 127
if ( s -> needdestroy )  128
if ( s -> inuse == 1 )  129
if ( s -> waiting_thread != AST_PTHREADT_NULL )  134
pthread_kill ( s -> waiting_thread , SIGURG ); 135
s -> inuse --; 136
s -> inuse --; 139
ast_mutex_unlock ( & s -> __lock ); 140
destroy_session ( s ); 143
return retval ; 147
------------------------------
266 /home/speedy/test/source2slice/NVD/CVE_2010_2431_PATCHED_cupsFileOpen.c open 38
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_PATCHED_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 38
if ( fd < 0 && errno == ENOENT )  43
if ( fd < 0 && errno == EEXIST )  47
if ( fd >= 0 )  51
ftruncate ( fd , 0 ); 52
if ( ! httpAddrConnect ( addrlist , & fd ) )  73
if ( fd < 0 )  86
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  93
closesocket ( fd ); 96
close ( fd ); 98
return ( fp ) ; 105
------------------------------
267 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c open 41
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ); 41
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
------------------------------
268 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c open 37
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 37
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
------------------------------
269 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c open 33
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ); 33
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
------------------------------
270 /home/speedy/test/source2slice/NVD/CVE_2004_1151_PATCHED_sys32_ni_syscall.c strncpy 9
int CVE_2004_1151_PATCHED_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ sizeof ( me -> comm ) ] ; 4
if ( strncmp ( lastcomm , me -> comm , sizeof ( lastcomm ) ) )  6
strncpy ( lastcomm , me -> comm , sizeof ( lastcomm ) ); 9
------------------------------
271 /home/speedy/test/source2slice/NVD/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c strncpy 110
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
if ( skb -> len < CAPI_MSG_BASELEN + 10 )  12
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 15
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 16
switch ( func )  18
msgnum = CAPIMSG_MSGID ( skb -> data ); 20
if ( skb -> len < CAPI_MSG_BASELEN + 11 + sizeof ( capi_profile ) )  45
msgnum = CAPIMSG_MSGID ( skb -> data ); 49
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  51
if ( ! info && ctrl )  57
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 58
if ( skb -> len < CAPI_MSG_BASELEN + 15 )  68
if ( ! info && ctrl )  73
int len = min_t ( uint , CAPI_MANUFACTURER_LEN , skb -> data [ CAPI_MSG_BASELEN + 14 ] ) ; 74
memset ( ctrl -> manu , 0 , CAPI_MANUFACTURER_LEN ); 77
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , len ); 78
if ( skb -> len < CAPI_MSG_BASELEN + 32 )  85
if ( ! info && ctrl )  90
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 91
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 92
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 93
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 94
if ( skb -> len < CAPI_MSG_BASELEN + 17 )  100
if ( ! info && ctrl )  105
int len = min_t ( uint , CAPI_SERIAL_LEN , skb -> data [ CAPI_MSG_BASELEN + 16 ] ) ; 106
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 109
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , len ); 110
------------------------------
272 /home/speedy/test/source2slice/NVD/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c strncpy 78
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
if ( skb -> len < CAPI_MSG_BASELEN + 10 )  12
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 15
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 16
switch ( func )  18
msgnum = CAPIMSG_MSGID ( skb -> data ); 20
if ( skb -> len < CAPI_MSG_BASELEN + 11 + sizeof ( capi_profile ) )  45
msgnum = CAPIMSG_MSGID ( skb -> data ); 49
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  51
if ( ! info && ctrl )  57
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 58
if ( skb -> len < CAPI_MSG_BASELEN + 15 )  68
if ( ! info && ctrl )  73
int len = min_t ( uint , CAPI_MANUFACTURER_LEN , skb -> data [ CAPI_MSG_BASELEN + 14 ] ) ; 74
memset ( ctrl -> manu , 0 , CAPI_MANUFACTURER_LEN ); 77
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , len ); 78
if ( ! info && ctrl )  90
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 91
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 92
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 93
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 94
if ( ! info && ctrl )  105
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 109
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , len ); 110
------------------------------
273 /home/speedy/test/source2slice/NVD/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c strncpy 89
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
------------------------------
274 /home/speedy/test/source2slice/NVD/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c strncpy 65
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
------------------------------
275 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strncpy 151
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
bcc_ptr += length + 1; 121
if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE )  123
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
276 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strncpy 122
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
tcon -> tidStatus = CifsGood; 103
tcon -> need_reconnect = false; 104
tcon -> tid = smb_buffer_response -> Tid; 105
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
tcon -> ipc = 1; 113
strncpy ( tcon -> treeName , tree , MAX_TREE_SIZE ); 122
kfree ( tcon -> nativeFileSystem ); 128
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
------------------------------
277 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strncpy 151
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
bcc_ptr += length + 1; 121
if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE )  123
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
278 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strncpy 122
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
tcon -> tidStatus = CifsGood; 103
tcon -> need_reconnect = false; 104
tcon -> tid = smb_buffer_response -> Tid; 105
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
tcon -> ipc = 1; 113
strncpy ( tcon -> treeName , tree , MAX_TREE_SIZE ); 122
kfree ( tcon -> nativeFileSystem ); 128
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
------------------------------
279 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcmp 101
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
------------------------------
280 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcmp 101
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
------------------------------
281 /home/speedy/test/source2slice/NVD/CVE-2016-2330_VULN_gif_image_write_image.c memcmp 27
static int gif_image_write_image(AVCodecContext *avctx,
uint8_t **bytestream, uint8_t *end,
const uint32_t *palette,
const uint8_t *buf, const int linesize,
AVPacket *pkt) 5
GIFContext * s = avctx -> priv_data ; 7
int len = 0 , height = avctx -> height , width = avctx -> width , x , y ; 8
int x_start = 0 , y_start = 0 , trans = s -> transparent_index ; 9
if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )  14
const uint8_t * ref = s -> last_frame -> data [ 0 ] ; 15
const int ref_linesize = s -> last_frame -> linesize [ 0 ] ; 16
int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ; 17
while ( y_start < y_end )  21
if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )  22
y_start ++; 24
while ( y_end > y_start )  26
if ( memcmp ( ref + y_end * ref_linesize , buf + y_end * linesize , width ) )  27
y_end --; 29
------------------------------
282 /home/speedy/test/source2slice/NVD/CVE-2016-2330_VULN_gif_image_write_image.c memcmp 22
static int gif_image_write_image(AVCodecContext *avctx,
uint8_t **bytestream, uint8_t *end,
const uint32_t *palette,
const uint8_t *buf, const int linesize,
AVPacket *pkt) 5
GIFContext * s = avctx -> priv_data ; 7
int len = 0 , height = avctx -> height , width = avctx -> width , x , y ; 8
int x_start = 0 , y_start = 0 , trans = s -> transparent_index ; 9
if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )  14
const uint8_t * ref = s -> last_frame -> data [ 0 ] ; 15
const int ref_linesize = s -> last_frame -> linesize [ 0 ] ; 16
int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ; 17
while ( y_start < y_end )  21
if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )  22
y_start ++; 24
------------------------------
283 /home/speedy/test/source2slice/NVD/CVE_2009_2844_PATCHED_cmp_ies.c memcmp 12
static int CVE_2009_2844_PATCHED_cmp_ies(u8 num, u8 *ies1, size_t len1, u8 *ies2, size_t len2) 1
const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; 3
const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; 4
int r ; 5
if ( ! ie1 && ! ie2 )  7
if ( ! ie1 || ! ie2 )  9
r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ); 12
if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] )  13
return r ; 15
------------------------------
284 /home/speedy/test/source2slice/NVD/CVE_2009_2844_PATCHED_is_mesh.c memcmp 33
static bool CVE_2009_2844_PATCHED_is_mesh(struct cfg80211_bss *a,
const u8 *meshid, size_t meshidlen,
const u8 *meshcfg) 3
const u8 * ie ; 5
if ( ! is_zero_ether_addr ( a -> bssid ) )  7
ie = find_ie ( WLAN_EID_MESH_ID , a -> information_elements , a -> len_information_elements ); 10
if ( ! ie )  13
if ( ie [ 1 ] != meshidlen )  15
if ( memcmp ( ie + 2 , meshid , meshidlen ) )  17
ie = find_ie ( WLAN_EID_MESH_CONFIG , a -> information_elements , a -> len_information_elements ); 20
if ( ! ie )  23
if ( ie [ 1 ] != IEEE80211_MESH_CONFIG_LEN )  25
return memcmp ( ie + 2 , meshcfg , IEEE80211_MESH_CONFIG_LEN - 2 ) == 0 ; 33
------------------------------
285 /home/speedy/test/source2slice/NVD/CVE_2009_2844_PATCHED_is_mesh.c memcmp 17
static bool CVE_2009_2844_PATCHED_is_mesh(struct cfg80211_bss *a,
const u8 *meshid, size_t meshidlen,
const u8 *meshcfg) 3
const u8 * ie ; 5
if ( ! is_zero_ether_addr ( a -> bssid ) )  7
ie = find_ie ( WLAN_EID_MESH_ID , a -> information_elements , a -> len_information_elements ); 10
if ( ! ie )  13
if ( ie [ 1 ] != meshidlen )  15
if ( memcmp ( ie + 2 , meshid , meshidlen ) )  17
------------------------------
286 /home/speedy/test/source2slice/NVD/CVE_2009_2844_VULN_cmp_ies.c memcmp 12
static int CVE_2009_2844_VULN_cmp_ies(u8 num, u8 *ies1, size_t len1, u8 *ies2, size_t len2) 1
const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; 3
const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; 4
int r ; 5
if ( ! ie1 && ! ie2 )  7
if ( ! ie1 )  9
r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ); 12
if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] )  13
return r ; 15
------------------------------
287 /home/speedy/test/source2slice/NVD/CVE_2009_2844_VULN_is_mesh.c memcmp 31
static bool CVE_2009_2844_VULN_is_mesh(struct cfg80211_bss *a,
const u8 *meshid, size_t meshidlen,
const u8 *meshcfg) 3
const u8 * ie ; 5
if ( ! is_zero_ether_addr ( a -> bssid ) )  7
ie = find_ie ( WLAN_EID_MESH_ID , a -> information_elements , a -> len_information_elements ); 10
if ( ! ie )  13
if ( ie [ 1 ] != meshidlen )  15
if ( memcmp ( ie + 2 , meshid , meshidlen ) )  17
ie = find_ie ( WLAN_EID_MESH_CONFIG , a -> information_elements , a -> len_information_elements ); 20
if ( ie [ 1 ] != IEEE80211_MESH_CONFIG_LEN )  23
return memcmp ( ie + 2 , meshcfg , IEEE80211_MESH_CONFIG_LEN - 2 ) == 0 ; 31
------------------------------
288 /home/speedy/test/source2slice/NVD/CVE_2009_2844_VULN_is_mesh.c memcmp 17
static bool CVE_2009_2844_VULN_is_mesh(struct cfg80211_bss *a,
const u8 *meshid, size_t meshidlen,
const u8 *meshcfg) 3
const u8 * ie ; 5
if ( ! is_zero_ether_addr ( a -> bssid ) )  7
ie = find_ie ( WLAN_EID_MESH_ID , a -> information_elements , a -> len_information_elements ); 10
if ( ! ie )  13
if ( ie [ 1 ] != meshidlen )  15
if ( memcmp ( ie + 2 , meshid , meshidlen ) )  17
------------------------------
289 /home/speedy/test/source2slice/NVD/CVE_2010_0307_PATCHED_load_elf_binary.c memcmp 145
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
char * elf_interpreter = NULL ; 6
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
int retval , i ; 10
unsigned int size ; 11
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
if ( elf_interpreter )  142
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
------------------------------
290 /home/speedy/test/source2slice/NVD/CVE_2010_0307_PATCHED_load_elf_binary.c memcmp 34
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
------------------------------
291 /home/speedy/test/source2slice/NVD/CVE_2010_0307_VULN_load_elf_binary.c memcmp 166
static int CVE_2010_0307_VULN_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
char * elf_interpreter = NULL ; 6
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
int retval , i ; 10
unsigned int size ; 11
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 124
retval = PTR_ERR ( interpreter ); 125
if ( IS_ERR ( interpreter ) )  126
if ( file_permission ( interpreter , MAY_READ ) < 0 )  134
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 135
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 137
if ( retval != BINPRM_BUF_SIZE )  139
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 146
elf_ppnt ++; 149
if ( elf_interpreter )  163
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  166
------------------------------
292 /home/speedy/test/source2slice/NVD/CVE_2010_0307_VULN_load_elf_binary.c memcmp 34
static int CVE_2010_0307_VULN_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
------------------------------
293 /home/speedy/test/source2slice/NVD/CVE_2013_4933_PATCHED_netmon_open.c memcmp 28
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
------------------------------
294 /home/speedy/test/source2slice/NVD/CVE_2013_4933_PATCHED_netmon_open.c memcmp 28
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
------------------------------
295 /home/speedy/test/source2slice/NVD/CVE_2013_4933_VULN_netmon_open.c memcmp 28
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
------------------------------
296 /home/speedy/test/source2slice/NVD/CVE_2013_4933_VULN_netmon_open.c memcmp 28
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
------------------------------
297 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c memcmp 484
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) )  484
------------------------------
298 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c memcmp 484
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) )  484
------------------------------
299 /home/speedy/test/source2slice/NVD/CVE_2014_4652_PATCHED_snd_ctl_elem_user_tlv.c memcmp 20
static int CVE_2014_4652_PATCHED_snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,
int op_flag,
unsigned int size,
unsigned int __user *tlv) 4
struct user_element * ue = kcontrol -> private_data ; 6
void * new_data ; 8
if ( op_flag > 0 )  10
if ( size > 1024 * 128 )  11
new_data = memdup_user ( tlv , size ); 14
if ( IS_ERR ( new_data ) )  15
change = ue -> tlv_data_size != size; 18
if ( ! change )  19
change = memcmp ( ue -> tlv_data , new_data , size ); 20
return change ; 44
------------------------------
300 /home/speedy/test/source2slice/NVD/CVE_2014_4652_VULN_snd_ctl_elem_user_tlv.c memcmp 19
static int CVE_2014_4652_VULN_snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,
int op_flag,
unsigned int size,
unsigned int __user *tlv) 4
struct user_element * ue = kcontrol -> private_data ; 6
void * new_data ; 8
if ( op_flag > 0 )  10
if ( size > 1024 * 128 )  11
new_data = memdup_user ( tlv , size ); 14
if ( IS_ERR ( new_data ) )  15
change = ue -> tlv_data_size != size; 17
if ( ! change )  18
change = memcmp ( ue -> tlv_data , new_data , size ); 19
return change ; 31
------------------------------
301 /home/speedy/test/source2slice/NVD/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c memcmp 64
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
302 /home/speedy/test/source2slice/NVD/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c memcmp 64
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
303 /home/speedy/test/source2slice/NVD/CVE_2015_3813_PATCHED_fragment_add_work.c memcmp 292
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
------------------------------
304 /home/speedy/test/source2slice/NVD/CVE_2015_3813_VULN_fragment_add_work.c memcmp 290
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
------------------------------
305 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c copy 47
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
int i ; 8
switch ( c -> srcFormat )  12
srcPtr += 2 * srcStride [ 0 ]; 34
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
for (i = 2; i < srcSliceH - 2; i += 2) 39
srcPtr += 2 * srcStride [ 0 ]; 41
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
------------------------------
306 /home/speedy/test/source2slice/NVD/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c copy 33
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
switch ( c -> srcFormat )  12
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
------------------------------
307 /home/speedy/test/source2slice/NVD/CVE_2007_1217_PATCHED_bufprint.c vsnprintf 32
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
308 /home/speedy/test/source2slice/NVD/CVE_2007_1217_PATCHED_bufprint.c vsnprintf 10
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
while ( ( ns - cdb -> pos ) <= n )  17
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
309 /home/speedy/test/source2slice/NVD/CVE_2015_1159_PATCHED_cgi_puts.c fputs 18
static void
CVE_2015_1159_PATCHED_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( * s == '>' )  11
if ( * s == '\"' )  13
if ( * s == '\'' )  15
if ( * s == '&' )  17
fputs ( "&amp;" , out ); 18
s ++; 22
------------------------------
310 /home/speedy/test/source2slice/NVD/CVE_2015_1159_PATCHED_cgi_puts.c fputs 16
static void
CVE_2015_1159_PATCHED_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( * s == '>' )  11
if ( * s == '\"' )  13
if ( * s == '\'' )  15
fputs ( "&#39;" , out ); 16
s ++; 22
------------------------------
311 /home/speedy/test/source2slice/NVD/CVE_2015_1159_PATCHED_cgi_puts.c fputs 14
static void
CVE_2015_1159_PATCHED_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( * s == '>' )  11
if ( * s == '\"' )  13
fputs ( "&quot;" , out ); 14
s ++; 22
------------------------------
312 /home/speedy/test/source2slice/NVD/CVE_2015_1159_PATCHED_cgi_puts.c fputs 12
static void
CVE_2015_1159_PATCHED_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( * s == '>' )  11
fputs ( "&gt;" , out ); 12
s ++; 22
------------------------------
313 /home/speedy/test/source2slice/NVD/CVE_2015_1159_PATCHED_cgi_puts.c fputs 10
static void
CVE_2015_1159_PATCHED_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
fputs ( "&lt;" , out ); 10
s ++; 22
------------------------------
314 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 50
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
if ( * s == '>' )  43
if ( * s == '\"' )  45
if ( * s == '\'' )  47
if ( * s == '&' )  49
fputs ( "&amp;" , out ); 50
s ++; 54
------------------------------
315 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 48
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
if ( * s == '>' )  43
if ( * s == '\"' )  45
if ( * s == '\'' )  47
fputs ( "&#39;" , out ); 48
s ++; 54
------------------------------
316 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 46
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
if ( * s == '>' )  43
if ( * s == '\"' )  45
fputs ( "&quot;" , out ); 46
s ++; 54
------------------------------
317 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 44
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
if ( * s == '>' )  43
fputs ( "&gt;" , out ); 44
s ++; 54
------------------------------
318 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 41
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
fputs ( "&lt;" , out ); 41
s ++; 54
------------------------------
319 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 37
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
fputs ( "</A>" , out ); 37
s += 3; 38
s ++; 54
------------------------------
320 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 33
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
fputs ( "\">" , out ); 33
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
s ++; 54
------------------------------
321 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 23
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
s += 9; 18
while ( * s && * s != '\"' )  20
if ( * s == '&' )  22
fputs ( "&amp;" , out ); 23
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
s ++; 54
------------------------------
322 /home/speedy/test/source2slice/NVD/CVE_2015_1159_VULN_cgi_puts.c fputs 17
static void
CVE_2015_1159_VULN_cgi_puts(const char *s,			/* I - String to output */
FILE       *out)		/* I - Output file */ 6
while ( * s )  7
if ( * s == '<' )  9
if ( ! _cups_strncasecmp ( s , "<A HREF=\"" , 9 ) )  15
fputs ( "<A HREF=\"" , out ); 17
s += 9; 18
while ( * s && * s != '\"' )  20
s ++; 27
if ( * s )  30
s ++; 31
if ( ! _cups_strncasecmp ( s , "</A>" , 4 ) )  35
s += 3; 38
s ++; 54
------------------------------
323 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcpy 110
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
switch ( pix_fmt_id )  171
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( pix_fmt_id == 0x14111100 )  259
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( pix_fmt_id == 0x42111100 )  292
if ( pix_fmt_id == 0x24111100 )  296
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
324 /home/speedy/test/source2slice/NVD/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcpy 109
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
switch ( pix_fmt_id )  171
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( pix_fmt_id == 0x14111100 )  259
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( pix_fmt_id == 0x42111100 )  292
if ( pix_fmt_id == 0x24111100 )  296
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
325 /home/speedy/test/source2slice/NVD/CVE-2015-5158_VULN_scsi_req_parse_cdb.c memcpy 23
int scsi_req_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf) 1
int rc ; 3
cmd -> lba = - 1; 5
cmd -> len = scsi_cdb_length ( buf ); 6
switch ( dev -> type )  8
rc = scsi_req_stream_xfer ( cmd , dev , buf ); 10
rc = scsi_req_medium_changer_xfer ( cmd , dev , buf ); 13
rc = scsi_req_xfer ( cmd , dev , buf ); 16
if ( rc != 0 )  20
memcpy ( cmd -> buf , buf , cmd -> len ); 23
scsi_cmd_xfer_mode ( cmd ); 24
cmd -> lba = scsi_cmd_lba ( cmd ); 25
------------------------------
326 /home/speedy/test/source2slice/NVD/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 114
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
if ( best_bytestream != original_bytestream )  113
memcpy ( original_bytestream , best_bytestream , best_bytestream_size ); 114
------------------------------
327 /home/speedy/test/source2slice/NVD/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 74
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
av_frame_free ( & diffFrame ); 120
return ret ; 121
------------------------------
328 /home/speedy/test/source2slice/NVD/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 61
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
------------------------------
329 /home/speedy/test/source2slice/NVD/CVE-2016-2330_VULN_gif_image_write_image.c memcpy 111
static int gif_image_write_image(AVCodecContext *avctx,
uint8_t **bytestream, uint8_t *end,
const uint32_t *palette,
const uint8_t *buf, const int linesize,
AVPacket *pkt) 5
GIFContext * s = avctx -> priv_data ; 7
int len = 0 , height = avctx -> height , width = avctx -> width , x , y ; 8
int x_start = 0 , y_start = 0 , trans = s -> transparent_index ; 9
int honor_transparency = ( s -> flags & GF_TRANSDIFF ) && s -> last_frame ; 10
const uint8_t * ptr ; 11
if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )  14
const uint8_t * ref = s -> last_frame -> data [ 0 ] ; 15
const int ref_linesize = s -> last_frame -> linesize [ 0 ] ; 16
int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ; 17
while ( y_start < y_end )  21
if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )  22
y_start ++; 24
while ( y_end > y_start )  26
if ( memcmp ( ref + y_end * ref_linesize , buf + y_end * linesize , width ) )  27
y_end --; 29
height = y_end + 1 - y_start; 31
while ( x_start < x_end )  34
int same_column = 1 ; 35
for (y = y_start; y <= y_end; y++) 36
if ( ref [ y * ref_linesize + x_start ] != buf [ y * linesize + x_start ] )  37
same_column = 0; 38
if ( ! same_column )  42
x_start ++; 44
while ( x_end > x_start )  46
int same_column = 1 ; 47
for (y = y_start; y <= y_end; y++) 48
if ( ref [ y * ref_linesize + x_end ] != buf [ y * linesize + x_end ] )  49
same_column = 0; 50
if ( ! same_column )  54
x_end --; 56
width = x_end + 1 - x_start; 58
if ( honor_transparency && trans < 0 )  82
trans = pick_palette_entry ( buf + y_start * linesize + x_start , linesize , width , height ); 83
if ( trans < 0 )  85
uint8_t * pal_exdata = s -> pal_exdata ; 88
if ( ! pal_exdata )  89
pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ); 90
if ( ! pal_exdata )  91
memcpy ( pal_exdata , s -> palette , AVPALETTE_SIZE ); 93
pal_exdata [ trans * 4 + 3 * ! HAVE_BIGENDIAN ] = 0x00; 94
if ( trans < 0 )  97
honor_transparency = 0; 98
ptr = buf + y_start * linesize + x_start; 105
if ( honor_transparency )  106
for (y = 0; y < height; y++) 110
memcpy ( s -> tmpl , ptr , width ); 111
if ( ref [ x ] == ptr [ x ] )  113
s -> tmpl [ x ] = trans; 114
len += ff_lzw_encode ( s -> lzw , s -> tmpl , width ); 115
ptr += linesize; 116
len += ff_lzw_encode_flush ( s -> lzw , flush_put_bits ); 125
ptr = s -> buf; 127
while ( len > 0 )  128
int size = FFMIN ( 255 , len ) ; 129
bytestream_put_byte ( bytestream , size ); 130
if ( end - * bytestream < size )  131
bytestream_put_buffer ( bytestream , ptr , size ); 133
ptr += size; 134
len -= size; 135
------------------------------
330 /home/speedy/test/source2slice/NVD/CVE-2016-2330_VULN_gif_image_write_image.c memcpy 93
static int gif_image_write_image(AVCodecContext *avctx,
uint8_t **bytestream, uint8_t *end,
const uint32_t *palette,
const uint8_t *buf, const int linesize,
AVPacket *pkt) 5
GIFContext * s = avctx -> priv_data ; 7
int len = 0 , height = avctx -> height , width = avctx -> width , x , y ; 8
int x_start = 0 , y_start = 0 , trans = s -> transparent_index ; 9
int honor_transparency = ( s -> flags & GF_TRANSDIFF ) && s -> last_frame ; 10
if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )  14
const uint8_t * ref = s -> last_frame -> data [ 0 ] ; 15
const int ref_linesize = s -> last_frame -> linesize [ 0 ] ; 16
int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ; 17
while ( y_start < y_end )  21
if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )  22
y_start ++; 24
while ( y_end > y_start )  26
if ( memcmp ( ref + y_end * ref_linesize , buf + y_end * linesize , width ) )  27
y_end --; 29
height = y_end + 1 - y_start; 31
while ( x_start < x_end )  34
int same_column = 1 ; 35
for (y = y_start; y <= y_end; y++) 36
if ( ref [ y * ref_linesize + x_start ] != buf [ y * linesize + x_start ] )  37
same_column = 0; 38
if ( ! same_column )  42
x_start ++; 44
while ( x_end > x_start )  46
int same_column = 1 ; 47
for (y = y_start; y <= y_end; y++) 48
if ( ref [ y * ref_linesize + x_end ] != buf [ y * linesize + x_end ] )  49
same_column = 0; 50
if ( ! same_column )  54
x_end --; 56
width = x_end + 1 - x_start; 58
if ( honor_transparency && trans < 0 )  82
trans = pick_palette_entry ( buf + y_start * linesize + x_start , linesize , width , height ); 83
if ( trans < 0 )  85
uint8_t * pal_exdata = s -> pal_exdata ; 88
if ( ! pal_exdata )  89
pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ); 90
if ( ! pal_exdata )  91
memcpy ( pal_exdata , s -> palette , AVPALETTE_SIZE ); 93
pal_exdata [ trans * 4 + 3 * ! HAVE_BIGENDIAN ] = 0x00; 94
if ( trans < 0 )  97
if ( ref [ x ] == ptr [ x ] )  113
s -> tmpl [ x ] = trans; 114
len += ff_lzw_encode ( s -> lzw , s -> tmpl , width ); 115
len += ff_lzw_encode_flush ( s -> lzw , flush_put_bits ); 125
ptr = s -> buf; 127
while ( len > 0 )  128
int size = FFMIN ( 255 , len ) ; 129
bytestream_put_byte ( bytestream , size ); 130
if ( end - * bytestream < size )  131
bytestream_put_buffer ( bytestream , ptr , size ); 133
ptr += size; 134
len -= size; 135
------------------------------
331 /home/speedy/test/source2slice/NVD/CVE-2016-4002_VULN_mipsnet_receive.c memcpy 14
static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size) 1
MIPSnetState * s = qemu_get_nic_opaque ( nc ) ; 3
if ( ! mipsnet_can_receive ( nc ) )  6
s -> busy = 1; 9
memcpy ( s -> rx_buffer , buf , size ); 14
s -> rx_count = size; 16
s -> rx_read = 0; 17
s -> intctl |= MIPSNET_INTCTL_RXDONE; 20
mipsnet_update_irq ( s ); 21
------------------------------
332 /home/speedy/test/source2slice/NVD/CVE-2016-5238_VULN_get_cmd.c memcpy 14
static uint32_t get_cmd(ESPState *s, uint8_t *buf) 1
uint32_t dmalen ; 3
if ( s -> dma )  7
dmalen = s -> ti_size; 13
memcpy ( buf , s -> ti_buf , dmalen ); 14
buf [ 0 ] = buf [ 2 ] >> 5; 15
------------------------------
333 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c memcpy 51
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
struct timespec now ; 5
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
now = current_kernel_time ( ); 43
if ( key -> expiry == 0 )  48
if ( now . tv_sec >= key -> expiry )  50
memcpy ( xbuf , "expd" , 5 ); 51
------------------------------
334 /home/speedy/test/source2slice/NVD/CVE-2016-7042_VULN_proc_keys_show.c memcpy 49
static int proc_keys_show(struct seq_file *m, void *v) 1
struct key * key = rb_entry ( _p , struct key , serial_node ) 4
key_ref_t key_ref , skey_ref ; 7
char xbuf [ 12 ] ; 8
int rc ; 9
struct keyring_search_context ctx =
. index_key . type = key -> type ,
. index_key . description = key -> description ,
. cred = current_cred ( ) ,
. match_data . cmp = lookup_user_key_possessed ,
. match_data . raw_data = key ,
. match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT ,
. flags = KEYRING_SEARCH_NO_STATE_CHECK , 18
key_ref = make_key_ref ( key , 0 ); 21
if ( key -> perm & KEY_POS_VIEW )  26
skey_ref = search_my_process_keyrings ( & ctx ); 27
if ( ! IS_ERR ( skey_ref ) )  28
key_ref = make_key_ref ( key , 1 ); 30
rc = key_task_permission ( key_ref , ctx . cred , KEY_NEED_VIEW ); 39
if ( rc < 0 )  40
if ( key -> expiry == 0 )  48
memcpy ( xbuf , "perm" , 5 ); 49
------------------------------
335 /home/speedy/test/source2slice/NVD/CVE-2016-7913_VULN_xc2028_set_config.c memcpy 17
static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) 1
struct xc2028_data * priv = fe -> tuner_priv ; 3
struct xc2028_ctrl * p = priv_cfg ; 4
memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ); 17
priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ); 19
if ( priv -> ctrl . fname == NULL )  20
if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) )  28
free_firmware ( priv ); 30
if ( priv -> ctrl . max_len < 9 )  32
priv -> ctrl . max_len = 13; 33
if ( priv -> state == XC2028_NO_FIRMWARE )  35
priv -> fname = priv -> ctrl . fname; 37
rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ); 41
if ( rc < 0 )  46
tuner_err ( "Failed to request firmware %s\n" , priv -> fname ); 47
return rc ; 55
------------------------------
336 /home/speedy/test/source2slice/NVD/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 170
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; 5
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 6
const struct brcmf_tlv * ssid_ie ; 7
const struct brcmf_tlv * country_ie ; 8
struct brcmf_ssid_le ssid_le ; 9
const struct brcmf_tlv * rsn_ie ; 11
const struct brcmf_vs_tlv * wpa_ie ; 12
struct brcmf_join_params join_params ; 13
enum nl80211_iftype dev_role ; 14
u16 chanspec ; 16
bool mbss ; 17
int is_11d ; 18
dev_role = ifp -> vif -> wdev . iftype; 27
mbss = ifp -> vif -> mbss; 28
country_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_COUNTRY ); 32
is_11d = country_ie ? 1 : 0; 35
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , settings -> ssid , settings -> ssid_len ); 51
ssid_le . SSID_len = cpu_to_le32 ( ( u32 ) settings -> ssid_len ); 52
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); 61
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); 65
if ( wpa_ie != NULL || rsn_ie != NULL )  68
if ( wpa_ie != NULL )  70
err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); 72
if ( err < 0 )  73
struct brcmf_vs_tlv * tmp_ie ; 76
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; 78
err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); 81
if ( err < 0 )  82
if ( ! mbss )  92
chanspec = chandef_to_chanspec ( & cfg -> d11inf , & settings -> chandef ); 93
err = brcmf_fil_iovar_int_set ( ifp , "chanspec" , chanspec ); 95
if ( err < 0 )  96
if ( is_11d != ifp -> vif -> is_11d )  102
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_REGULATORY , is_11d ); 103
if ( err < 0 )  105
if ( settings -> beacon_interval )  110
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_BCNPRD , settings -> beacon_interval ); 111
if ( err < 0 )  113
if ( settings -> dtim_period )  119
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_DTIMPRD , settings -> dtim_period ); 120
if ( err < 0 )  122
if ( ( dev_role == NL80211_IFTYPE_AP ) && ( ( ifp -> ifidx == 0 ) || ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_RSDB ) ) )  128
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_DOWN , 1 ); 131
if ( err < 0 )  132
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_INFRA , 1 ); 139
if ( err < 0 )  140
if ( WARN_ON ( is_11d != ifp -> vif -> is_11d ) )  144
if ( dev_role == NL80211_IFTYPE_AP )  149
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_AP , 1 ); 153
if ( err < 0 )  154
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_UP , 1 ); 158
if ( err < 0 )  159
memset ( & join_params , 0 , sizeof ( join_params ) ); 168
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
------------------------------
337 /home/speedy/test/source2slice/NVD/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 51
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
struct brcmf_ssid_le ssid_le ; 9
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
memcpy ( ssid_le . SSID , settings -> ssid , settings -> ssid_len ); 51
ssid_le . SSID_len = cpu_to_le32 ( ( u32 ) settings -> ssid_len ); 52
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
err = brcmf_fil_bsscfg_data_set ( ifp , "ssid" , & ssid_le , sizeof ( ssid_le ) ); 180
if ( err < 0 )  182
brcmf_err ( "setting ssid failed %d\n" , err ); 183
if ( err < 0 )  190
brcmf_err ( "bss_enable config failed %d\n" , err ); 191
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
------------------------------
338 /home/speedy/test/source2slice/NVD/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 47
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
const struct brcmf_tlv * ssid_ie ; 7
struct brcmf_ssid_le ssid_le ; 9
memset ( & ssid_le , 0 , sizeof ( ssid_le ) ); 37
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
------------------------------
339 /home/speedy/test/source2slice/NVD/CVE_2006_1525_PATCHED_inet_rtm_getroute.c memcpy 51
int CVE_2006_1525_PATCHED_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
int iif = 0 ; 8
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_IIF - 1 ] )  29
memcpy ( & iif , RTA_DATA ( rta [ RTA_IIF - 1 ] ) , sizeof ( int ) ); 30
if ( iif )  32
if ( rta [ RTA_OIF - 1 ] )  50
memcpy ( & oif , RTA_DATA ( rta [ RTA_OIF - 1 ] ) , sizeof ( int ) ); 51
fl . oif = oif; 52
err = ip_route_output_key ( & rt , & fl ); 53
if ( err )  55
if ( ! err )  66
if ( err < 0 )  68
if ( err > 0 )  74
return err ; 76
------------------------------
340 /home/speedy/test/source2slice/NVD/CVE_2006_1525_PATCHED_inet_rtm_getroute.c memcpy 30
int CVE_2006_1525_PATCHED_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_IIF - 1 ] )  29
memcpy ( & iif , RTA_DATA ( rta [ RTA_IIF - 1 ] ) , sizeof ( int ) ); 30
if ( iif )  32
struct net_device * dev = __dev_get_by_index ( iif ) ; 33
if ( ! dev )  35
skb -> dev = dev; 38
err = ip_route_input ( skb , dst , src , rtm -> rtm_tos , dev ); 40
rt = ( struct rtable * ) skb -> dst; 42
if ( ! err && rt -> u . dst . error )  43
err = - rt -> u . dst . error; 44
err = ip_route_output_key ( & rt , & fl ); 53
if ( err )  55
skb -> dst = & rt -> u . dst; 58
rt -> rt_flags |= RTCF_NOTIFY; 60
NETLINK_CB ( skb ) . dst_pid = NETLINK_CB ( in_skb ) . pid; 62
err = rt_fill_info ( skb , NETLINK_CB ( in_skb ) . pid , nlh -> nlmsg_seq , RTM_NEWROUTE , 0 , 0 ); 64
if ( ! err )  66
if ( err < 0 )  68
err = netlink_unicast ( rtnl , skb , NETLINK_CB ( in_skb ) . pid , MSG_DONTWAIT ); 73
if ( err > 0 )  74
return err ; 76
kfree_skb ( skb ); 79
------------------------------
341 /home/speedy/test/source2slice/NVD/CVE_2006_1525_PATCHED_inet_rtm_getroute.c memcpy 28
int CVE_2006_1525_PATCHED_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_DST - 1 ] )  27
memcpy ( & dst , RTA_DATA ( rta [ RTA_DST - 1 ] ) , 4 ); 28
------------------------------
342 /home/speedy/test/source2slice/NVD/CVE_2006_1525_PATCHED_inet_rtm_getroute.c memcpy 26
int CVE_2006_1525_PATCHED_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_SRC - 1 ] )  25
memcpy ( & src , RTA_DATA ( rta [ RTA_SRC - 1 ] ) , 4 ); 26
------------------------------
343 /home/speedy/test/source2slice/NVD/CVE_2006_1525_VULN_inet_rtm_getroute.c memcpy 48
int CVE_2006_1525_VULN_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
int iif = 0 ; 8
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_IIF - 1 ] )  26
memcpy ( & iif , RTA_DATA ( rta [ RTA_IIF - 1 ] ) , sizeof ( int ) ); 27
if ( iif )  29
if ( rta [ RTA_OIF - 1 ] )  47
memcpy ( & oif , RTA_DATA ( rta [ RTA_OIF - 1 ] ) , sizeof ( int ) ); 48
fl . oif = oif; 49
err = ip_route_output_key ( & rt , & fl ); 50
if ( err )  52
if ( ! err )  63
if ( err < 0 )  65
return err ; 73
------------------------------
344 /home/speedy/test/source2slice/NVD/CVE_2006_1525_VULN_inet_rtm_getroute.c memcpy 27
int CVE_2006_1525_VULN_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_IIF - 1 ] )  26
memcpy ( & iif , RTA_DATA ( rta [ RTA_IIF - 1 ] ) , sizeof ( int ) ); 27
if ( iif )  29
struct net_device * dev = __dev_get_by_index ( iif ) ; 30
if ( ! dev )  32
skb -> dev = dev; 35
err = ip_route_input ( skb , dst , src , rtm -> rtm_tos , dev ); 37
rt = ( struct rtable * ) skb -> dst; 39
if ( ! err && rt -> u . dst . error )  40
err = - rt -> u . dst . error; 41
err = ip_route_output_key ( & rt , & fl ); 50
if ( err )  52
skb -> dst = & rt -> u . dst; 55
rt -> rt_flags |= RTCF_NOTIFY; 57
NETLINK_CB ( skb ) . dst_pid = NETLINK_CB ( in_skb ) . pid; 59
err = rt_fill_info ( skb , NETLINK_CB ( in_skb ) . pid , nlh -> nlmsg_seq , RTM_NEWROUTE , 0 , 0 ); 61
if ( ! err )  63
if ( err < 0 )  65
err = netlink_unicast ( rtnl , skb , NETLINK_CB ( in_skb ) . pid , MSG_DONTWAIT ); 70
if ( err > 0 )  71
return err ; 73
------------------------------
345 /home/speedy/test/source2slice/NVD/CVE_2006_1525_VULN_inet_rtm_getroute.c memcpy 25
int CVE_2006_1525_VULN_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_DST - 1 ] )  24
memcpy ( & dst , RTA_DATA ( rta [ RTA_DST - 1 ] ) , 4 ); 25
err = ip_route_input ( skb , dst , src , rtm -> rtm_tos , dev ); 37
if ( ! err && rt -> u . dst . error )  40
if ( err )  52
if ( ! err )  63
if ( err < 0 )  65
return err ; 73
------------------------------
346 /home/speedy/test/source2slice/NVD/CVE_2006_1525_VULN_inet_rtm_getroute.c memcpy 23
int CVE_2006_1525_VULN_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg) 1
struct rtattr * * rta = arg ; 3
struct sk_buff * skb ; 10
skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ); 12
if ( ! skb )  13
if ( rta [ RTA_SRC - 1 ] )  22
memcpy ( & src , RTA_DATA ( rta [ RTA_SRC - 1 ] ) , 4 ); 23
err = ip_route_input ( skb , dst , src , rtm -> rtm_tos , dev ); 37
if ( ! err && rt -> u . dst . error )  40
if ( err )  52
if ( ! err )  63
if ( err < 0 )  65
return err ; 73
------------------------------
347 /home/speedy/test/source2slice/NVD/CVE_2006_2935_PATCHED_dvd_read_bca.c memcpy 21
static int CVE_2006_2935_PATCHED_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
int ret ; 3
u_char buf [ 4 + 188 ] ; 4
struct packet_command cgc ; 5
struct cdrom_device_ops * cdo = cdi -> ops ; 6
cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE; 9
cgc . cmd [ 7 ] = s -> type; 10
cgc . cmd [ 9 ] = cgc . buflen & 0xff; 11
if ( ret = cdo -> generic_packet ( cdi , & cgc ) )  13
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
------------------------------
348 /home/speedy/test/source2slice/NVD/CVE_2006_2935_VULN_dvd_read_bca.c memcpy 21
static int CVE_2006_2935_VULN_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
int ret ; 3
u_char buf [ 4 + 188 ] ; 4
struct packet_command cgc ; 5
struct cdrom_device_ops * cdo = cdi -> ops ; 6
cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE; 9
cgc . cmd [ 7 ] = s -> type; 10
cgc . cmd [ 9 ] = cgc . buflen = 0xff; 11
if ( ret = cdo -> generic_packet ( cdi , & cgc ) )  13
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
------------------------------
349 /home/speedy/test/source2slice/NVD/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c memcpy 58
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
if ( skb -> len < CAPI_MSG_BASELEN + 10 )  12
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 15
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 16
switch ( func )  18
msgnum = CAPIMSG_MSGID ( skb -> data ); 20
if ( skb -> len < CAPI_MSG_BASELEN + 11 + sizeof ( capi_profile ) )  45
msgnum = CAPIMSG_MSGID ( skb -> data ); 49
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  51
if ( ! info && ctrl )  57
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 58
capi_ctr_ready ( ctrl ); 62
if ( ! info && ctrl )  73
memset ( ctrl -> manu , 0 , CAPI_MANUFACTURER_LEN ); 77
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , len ); 78
if ( ! info && ctrl )  90
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 91
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 92
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 93
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 94
if ( ! info && ctrl )  105
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 109
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , len ); 110
------------------------------
350 /home/speedy/test/source2slice/NVD/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c memcpy 52
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
msgnum = CAPIMSG_MSGID ( skb -> data ); 17
msgnum = CAPIMSG_MSGID ( skb -> data ); 43
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  45
if ( ! info && ctrl )  51
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 52
capi_ctr_ready ( ctrl ); 56
------------------------------
351 /home/speedy/test/source2slice/NVD/CVE_2007_1217_PATCHED_bufprint.c memcpy 24
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
352 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c memcpy 431
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
isdn_ctrl c ; 5
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
int loop = 1 ; 347
p = ( char __user * ) iocts . arg; 349
i = 0; 350
while ( loop )  351
int j = 0 ; 352
while ( 1 )  354
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  355
get_user ( bname [ j ] , p ++ ); 357
switch ( bname [ j ] )  358
loop = 0; 360
bname [ j ] = '\0'; 363
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 364
j = ISDN_MSNLEN; 365
j ++; 368
if ( j >= ISDN_MSNLEN )  370
if ( ++ i > 9 )  373
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  400
cmd = ( ( cmd >> _IOC_NRSHIFT ) & _IOC_NRMASK ) & ISDN_DRVIOCTL_MASK; 401
if ( arg )  404
int i ; 405
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  407
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 409
if ( strlen ( iocts . drvid ) )  410
drvidx = - 1; 413
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 414
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  415
drvidx = i; 416
drvidx = 0; 420
if ( drvidx == - 1 )  421
if ( ! access_ok ( VERIFY_WRITE , argp , sizeof ( isdn_ioctl_struct ) ) )  423
c . driver = drvidx; 426
c . command = ISDN_CMD_IOCTL; 427
c . arg = cmd; 428
memcpy ( c . parm . num , & iocts . arg , sizeof ( ulong ) ); 429
memcpy ( & iocts . arg , c . parm . num , sizeof ( ulong ) ); 431
if ( copy_to_user ( argp , & iocts , sizeof ( isdn_ioctl_struct ) ) )  432
------------------------------
353 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c memcpy 429
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
isdn_ctrl c ; 5
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
int loop = 1 ; 347
p = ( char __user * ) iocts . arg; 349
i = 0; 350
while ( loop )  351
int j = 0 ; 352
while ( 1 )  354
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  355
get_user ( bname [ j ] , p ++ ); 357
switch ( bname [ j ] )  358
loop = 0; 360
bname [ j ] = '\0'; 363
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 364
j = ISDN_MSNLEN; 365
j ++; 368
if ( j >= ISDN_MSNLEN )  370
if ( ++ i > 9 )  373
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  400
cmd = ( ( cmd >> _IOC_NRSHIFT ) & _IOC_NRMASK ) & ISDN_DRVIOCTL_MASK; 401
if ( arg )  404
int i ; 405
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  407
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 409
if ( strlen ( iocts . drvid ) )  410
drvidx = - 1; 413
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 414
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  415
drvidx = i; 416
drvidx = 0; 420
if ( drvidx == - 1 )  421
if ( ! access_ok ( VERIFY_WRITE , argp , sizeof ( isdn_ioctl_struct ) ) )  423
c . driver = drvidx; 426
c . command = ISDN_CMD_IOCTL; 427
c . arg = cmd; 428
memcpy ( c . parm . num , & iocts . arg , sizeof ( ulong ) ); 429
ret = isdn_command ( & c ); 430
memcpy ( & iocts . arg , c . parm . num , sizeof ( ulong ) ); 431
if ( copy_to_user ( argp , & iocts , sizeof ( isdn_ioctl_struct ) ) )  432
return ret ; 434
------------------------------
354 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c memcpy 428
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
isdn_ctrl c ; 5
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
int loop = 1 ; 345
p = ( char __user * ) iocts . arg; 347
i = 0; 348
while ( loop )  349
int j = 0 ; 350
while ( 1 )  352
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  353
get_user ( bname [ j ] , p ++ ); 355
switch ( bname [ j ] )  356
loop = 0; 358
bname [ j ] = '\0'; 361
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 362
j = ISDN_MSNLEN; 363
j ++; 366
if ( j >= ISDN_MSNLEN )  368
if ( ++ i > 9 )  371
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  398
cmd = ( ( cmd >> _IOC_NRSHIFT ) & _IOC_NRMASK ) & ISDN_DRVIOCTL_MASK; 399
if ( arg )  402
int i ; 403
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  405
if ( strlen ( iocts . drvid ) )  407
drvidx = - 1; 410
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 411
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  412
drvidx = i; 413
drvidx = 0; 417
if ( drvidx == - 1 )  418
if ( ! access_ok ( VERIFY_WRITE , argp , sizeof ( isdn_ioctl_struct ) ) )  420
c . driver = drvidx; 423
c . command = ISDN_CMD_IOCTL; 424
c . arg = cmd; 425
memcpy ( c . parm . num , & iocts . arg , sizeof ( ulong ) ); 426
memcpy ( & iocts . arg , c . parm . num , sizeof ( ulong ) ); 428
if ( copy_to_user ( argp , & iocts , sizeof ( isdn_ioctl_struct ) ) )  429
------------------------------
355 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c memcpy 426
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
isdn_ctrl c ; 5
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
int loop = 1 ; 345
p = ( char __user * ) iocts . arg; 347
i = 0; 348
while ( loop )  349
int j = 0 ; 350
while ( 1 )  352
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  353
get_user ( bname [ j ] , p ++ ); 355
switch ( bname [ j ] )  356
loop = 0; 358
bname [ j ] = '\0'; 361
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 362
j = ISDN_MSNLEN; 363
j ++; 366
if ( j >= ISDN_MSNLEN )  368
if ( ++ i > 9 )  371
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  398
cmd = ( ( cmd >> _IOC_NRSHIFT ) & _IOC_NRMASK ) & ISDN_DRVIOCTL_MASK; 399
if ( arg )  402
int i ; 403
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  405
if ( strlen ( iocts . drvid ) )  407
drvidx = - 1; 410
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 411
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  412
drvidx = i; 413
drvidx = 0; 417
if ( drvidx == - 1 )  418
if ( ! access_ok ( VERIFY_WRITE , argp , sizeof ( isdn_ioctl_struct ) ) )  420
c . driver = drvidx; 423
c . command = ISDN_CMD_IOCTL; 424
c . arg = cmd; 425
memcpy ( c . parm . num , & iocts . arg , sizeof ( ulong ) ); 426
ret = isdn_command ( & c ); 427
memcpy ( & iocts . arg , c . parm . num , sizeof ( ulong ) ); 428
if ( copy_to_user ( argp , & iocts , sizeof ( isdn_ioctl_struct ) ) )  429
return ret ; 431
------------------------------
356 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 155
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
PRUint32 toCopy ; 149
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
if ( ! mDecoded )  161
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 162
if ( ! mDecoded )  163
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
if ( mCurLine == 0 )  225
mRowBytes = 0; 228
while ( aCount > 0 )  231
------------------------------
357 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 128
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
------------------------------
358 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 30
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
------------------------------
359 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 12
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
------------------------------
360 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memcpy 151
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 64
mCurLine = real_height; 69
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aBuffer ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aBuffer += toCopy; 126
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aBuffer ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 142
if ( rowSize % 4 )  143
rowSize += ( 4 - ( rowSize % 4 ) ); 144
PRUint32 toCopy ; 145
toCopy = rowSize - mRowBytes; 147
if ( toCopy )  148
if ( toCopy > aCount )  149
toCopy = aCount; 150
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 151
aCount -= toCopy; 152
aBuffer += toCopy; 153
mRowBytes += toCopy; 154
if ( ( rowSize - mRowBytes ) == 0 )  156
if ( ! mDecoded )  157
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 158
if ( ! mDecoded )  159
PRUint8 * p = mRow ; 163
idx = ( * p >> bit ) & 1; 172
SetPixel ( d , idx , mColors ); 173
Set4BitPixel ( d , * p , lpos , mColors ); 181
SetPixel ( d , * p , mColors ); 187
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 194
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 195
p += 2; 200
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 206
p += 2; 207
p ++; 210
if ( mCurLine == 0 )  221
mRowBytes = 0; 224
while ( aCount > 0 )  227
------------------------------
361 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memcpy 124
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 124
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 130
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 131
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 132
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 195
------------------------------
362 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memcpy 30
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 124
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 130
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 131
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 132
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 195
------------------------------
363 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c memcpy 12
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 124
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 130
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 131
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 132
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 195
------------------------------
364 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c memcpy 26
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
ast_mutex_init ( & s -> __lock ); 30
ast_mutex_lock ( & s -> __lock ); 31
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 40
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 46
time ( & s -> sessiontimeout ); 51
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
ast_mutex_unlock ( & s -> __lock ); 56
if ( s )  58
if ( process_message ( s , & m ) )  71
if ( s -> authenticated )  72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 75
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 77
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 81
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 83
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 89
ast_mutex_lock ( & s -> __lock ); 98
if ( s -> outputstr )  99
tmp = xml_translate ( s -> outputstr -> str , params ); 102
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
if ( tmp != s -> outputstr -> str )  116
free ( tmp ); 117
free ( s -> outputstr ); 118
s -> outputstr = NULL; 119
ast_mutex_unlock ( & s -> __lock ); 121
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
ast_mutex_lock ( & s -> __lock ); 132
if ( s -> needdestroy )  133
if ( s -> inuse == 1 )  134
if ( s -> waiting_thread != AST_PTHREADT_NULL )  139
pthread_kill ( s -> waiting_thread , SIGURG ); 140
s -> inuse --; 141
s -> inuse --; 144
ast_mutex_unlock ( & s -> __lock ); 145
destroy_session ( s ); 148
return retval ; 152
------------------------------
365 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c memcpy 26
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
ast_mutex_init ( & s -> __lock ); 30
ast_mutex_lock ( & s -> __lock ); 31
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 35
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 41
time ( & s -> sessiontimeout ); 46
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
ast_mutex_unlock ( & s -> __lock ); 51
if ( s )  53
if ( process_message ( s , & m ) )  66
if ( s -> authenticated )  67
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 70
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 76
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 78
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
ast_mutex_lock ( & s -> __lock ); 93
if ( s -> outputstr )  94
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
free ( s -> outputstr ); 113
s -> outputstr = NULL; 114
ast_mutex_unlock ( & s -> __lock ); 116
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
ast_mutex_lock ( & s -> __lock ); 127
if ( s -> needdestroy )  128
if ( s -> inuse == 1 )  129
if ( s -> waiting_thread != AST_PTHREADT_NULL )  134
pthread_kill ( s -> waiting_thread , SIGURG ); 135
s -> inuse --; 136
s -> inuse --; 139
ast_mutex_unlock ( & s -> __lock ); 140
destroy_session ( s ); 143
return retval ; 147
------------------------------
366 /home/speedy/test/source2slice/NVD/CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old.c memcpy 77
static int CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
int addrlen ; 12
void * addrs ; 14
void * buf ; 15
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 || getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) )  25
if ( 0 == getaddrs . assoc_id )  34
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 35
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 37
if ( ! asoc )  38
bp = & asoc -> base . bind_addr; 40
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 49
if ( ! addrs )  51
if ( sctp_list_single_entry ( & bp -> address_list ) )  57
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 59
if ( sctp_is_any ( & addr -> a ) )  60
buf = addrs; 68
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 74
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 76
memcpy ( buf , & temp , addrlen ); 77
buf += addrlen; 78
------------------------------
367 /home/speedy/test/source2slice/NVD/CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old.c memcpy 74
static int CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
void * addrs ; 14
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 || getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) )  25
if ( 0 == getaddrs . assoc_id )  34
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 35
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 37
if ( ! asoc )  38
bp = & asoc -> base . bind_addr; 40
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 49
if ( ! addrs )  51
if ( sctp_list_single_entry ( & bp -> address_list ) )  57
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 59
if ( sctp_is_any ( & addr -> a ) )  60
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 74
sctp_get_pf_specific ( sk -> sk_family ) -> addr_v4map ( sp , & temp ); 75
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 76
memcpy ( buf , & temp , addrlen ); 77
buf += addrlen; 78
bytes_copied += addrlen; 79
if ( copy_to_user ( to , addrs , bytes_copied ) )  86
------------------------------
368 /home/speedy/test/source2slice/NVD/CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old.c memcpy 75
static int CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
int addrlen ; 12
void * addrs ; 14
void * buf ; 15
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 )  25
if ( 0 == getaddrs . assoc_id )  32
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 33
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 35
if ( ! asoc )  36
bp = & asoc -> base . bind_addr; 38
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 47
if ( ! addrs )  49
if ( sctp_list_single_entry ( & bp -> address_list ) )  55
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 57
if ( sctp_is_any ( & addr -> a ) )  58
buf = addrs; 66
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 72
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 74
memcpy ( buf , & temp , addrlen ); 75
buf += addrlen; 76
------------------------------
369 /home/speedy/test/source2slice/NVD/CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old.c memcpy 72
static int CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
void * addrs ; 14
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 )  25
if ( 0 == getaddrs . assoc_id )  32
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 33
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 35
if ( ! asoc )  36
bp = & asoc -> base . bind_addr; 38
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 47
if ( ! addrs )  49
if ( sctp_list_single_entry ( & bp -> address_list ) )  55
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 57
if ( sctp_is_any ( & addr -> a ) )  58
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 72
sctp_get_pf_specific ( sk -> sk_family ) -> addr_v4map ( sp , & temp ); 73
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 74
memcpy ( buf , & temp , addrlen ); 75
buf += addrlen; 76
bytes_copied += addrlen; 77
if ( copy_to_user ( to , addrs , bytes_copied ) )  84
------------------------------
370 /home/speedy/test/source2slice/NVD/CVE_2008_3527_PATCHED_sysenter_setup.c memcpy 18
int __init CVE_2008_3527_PATCHED_sysenter_setup(void) 1
void * syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  11
memcpy ( syscall_page , & vsyscall_sysenter_start , & vsyscall_sysenter_end - & vsyscall_sysenter_start ); 18
------------------------------
371 /home/speedy/test/source2slice/NVD/CVE_2008_3527_PATCHED_sysenter_setup.c memcpy 12
int __init CVE_2008_3527_PATCHED_sysenter_setup(void) 1
void * syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  11
memcpy ( syscall_page , & vsyscall_int80_start , & vsyscall_int80_end - & vsyscall_int80_start ); 12
------------------------------
372 /home/speedy/test/source2slice/NVD/CVE_2008_3527_VULN_sysenter_setup.c memcpy 17
int __init CVE_2008_3527_VULN_sysenter_setup(void) 1
syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ); 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  10
memcpy ( syscall_page , & vsyscall_sysenter_start , & vsyscall_sysenter_end - & vsyscall_sysenter_start ); 17
------------------------------
373 /home/speedy/test/source2slice/NVD/CVE_2008_3527_VULN_sysenter_setup.c memcpy 11
int __init CVE_2008_3527_VULN_sysenter_setup(void) 1
syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ); 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  10
memcpy ( syscall_page , & vsyscall_int80_start , & vsyscall_int80_end - & vsyscall_int80_start ); 11
------------------------------
374 /home/speedy/test/source2slice/NVD/CVE_2008_4302_PATCHED_pipe_to_file.c memcpy 69
static int CVE_2008_4302_PATCHED_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
struct file * file = sd -> file ; 4
struct address_space * mapping = file -> f_mapping ; 5
unsigned int offset , this_len ; 6
struct page * page ; 7
pgoff_t index ; 8
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
index = sd -> pos >> PAGE_CACHE_SHIFT; 18
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
page = find_lock_page ( mapping , index ); 26
if ( ! page )  27
ret = - ENOMEM; 28
page = page_cache_alloc_cold ( mapping ); 29
if ( unlikely ( ! page ) )  30
ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ); 36
if ( unlikely ( ret ) )  38
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret == AOP_TRUNCATED_PAGE )  49
if ( buf -> page != page )  62
char * src = buf -> ops -> map ( pipe , buf , 1 ) ; 66
char * dst = kmap_atomic ( page , KM_USER1 ) ; 67
memcpy ( dst + offset , src + buf -> offset , this_len ); 69
kunmap_atomic ( dst , KM_USER1 ); 71
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
------------------------------
375 /home/speedy/test/source2slice/NVD/CVE_2008_4302_VULN_pipe_to_file.c memcpy 69
static int CVE_2008_4302_VULN_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
struct file * file = sd -> file ; 4
struct address_space * mapping = file -> f_mapping ; 5
unsigned int offset , this_len ; 6
struct page * page ; 7
pgoff_t index ; 8
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
index = sd -> pos >> PAGE_CACHE_SHIFT; 18
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
page = find_lock_page ( mapping , index ); 26
if ( ! page )  27
ret = - ENOMEM; 28
page = page_cache_alloc_cold ( mapping ); 29
if ( unlikely ( ! page ) )  30
ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ); 36
if ( unlikely ( ret ) )  38
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret == AOP_TRUNCATED_PAGE )  49
if ( buf -> page != page )  62
char * src = buf -> ops -> map ( pipe , buf , 1 ) ; 66
char * dst = kmap_atomic ( page , KM_USER1 ) ; 67
memcpy ( dst + offset , src + buf -> offset , this_len ); 69
kunmap_atomic ( dst , KM_USER1 ); 71
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
------------------------------
376 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 198
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
memcpy ( bss -> rsn_ie , elem , bss -> rsn_ie_len ); 198
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: RSN_IE" , bss -> rsn_ie , elem -> len ); 199
pos += elem -> len + 2; 209
bss -> last_scanned = jiffies; 213
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
------------------------------
377 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 179
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
pos += elem -> len + 2; 209
------------------------------
378 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 171
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
379 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 149
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
pos += elem -> len + 2; 209
------------------------------
380 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 125
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
381 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 118
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
382 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 103
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
383 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 95
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
lbs_deb_scan ( "got SSID IE: '%s', len %u\n" , escape_essid ( bss -> ssid , bss -> ssid_len ) , bss -> ssid_len ); 96
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
pos += elem -> len + 2; 209
------------------------------
384 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 39
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
lbs_deb_scan ( "process_bss: BSSID %s\n" , print_mac ( mac , bss -> bssid ) ); 40
bss -> rssi = * pos; 55
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
bss -> capability = get_unaligned_le16 ( pos ); 67
lbs_deb_scan ( "process_bss: capabilities 0x%04x\n" , bss -> capability ); 68
if ( bss -> capability & WLAN_CAPABILITY_PRIVACY )  71
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
------------------------------
385 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 198
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
memcpy ( bss -> rsn_ie , elem , bss -> rsn_ie_len ); 198
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: RSN_IE" , bss -> rsn_ie , elem -> len ); 199
pos += elem -> len + 2; 209
bss -> last_scanned = jiffies; 213
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
------------------------------
386 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 179
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
387 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 171
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
388 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 149
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
------------------------------
389 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 125
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
390 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 118
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
391 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 103
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
------------------------------
392 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 95
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
lbs_deb_scan ( "got SSID IE: '%s', len %u\n" , escape_essid ( bss -> ssid , bss -> ssid_len ) , bss -> ssid_len ); 96
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
pos += elem -> len + 2; 209
------------------------------
393 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 39
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
lbs_deb_scan ( "process_bss: BSSID %s\n" , print_mac ( mac , bss -> bssid ) ); 40
bss -> rssi = * pos; 55
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
bss -> capability = get_unaligned_le16 ( pos ); 67
lbs_deb_scan ( "process_bss: capabilities 0x%04x\n" , bss -> capability ); 68
if ( bss -> capability & WLAN_CAPABILITY_PRIVACY )  71
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
------------------------------
394 /home/speedy/test/source2slice/NVD/CVE_2009_0746_PATCHED_make_indexed_dir.c memcpy 52
static int CVE_2009_0746_PATCHED_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct inode * dir = dentry -> d_parent -> d_inode ; 4
struct buffer_head * bh2 ; 7
struct dx_root * root ; 8
struct ext4_dir_entry_2 * de , * de2 ; 11
char * data1 , * top ; 12
unsigned len ; 13
int retval ; 14
unsigned blocksize ; 15
struct fake_dirent * fde ; 18
blocksize = dir -> i_sb -> s_blocksize; 20
retval = ext4_journal_get_write_access ( handle , bh ); 22
if ( retval )  23
root = ( struct dx_root * ) bh -> b_data; 28
fde = & root -> dotdot; 31
de = ( struct ext4_dir_entry_2 * ) ( ( char * ) fde + ext4_rec_len_from_disk ( fde -> rec_len ) ); 32
if ( ( char * ) de >= ( ( ( char * ) root ) + blocksize ) )  34
len = ( ( char * ) root ) + blocksize - ( char * ) de; 41
bh2 = ext4_append ( handle , dir , & block , & retval ); 44
if ( ! ( bh2 ) )  45
data1 = bh2 -> b_data; 50
memcpy ( data1 , de , len ); 52
de = ( struct ext4_dir_entry_2 * ) data1; 53
top = data1 + len; 54
while ( ( char * ) ( de2 = ext4_next_entry ( de ) ) < top )  55
de = de2; 56
de -> rec_len = ext4_rec_len_to_disk ( data1 + blocksize - ( char * ) de ); 57
de -> rec_len = ext4_rec_len_to_disk ( blocksize - EXT4_DIR_REC_LEN ( 2 ) ); 60
if ( ! ( de ) )  80
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 83
------------------------------
395 /home/speedy/test/source2slice/NVD/CVE_2009_0746_VULN_make_indexed_dir.c memcpy 43
static int CVE_2009_0746_VULN_make_indexed_dir(handle_t *handle, struct dentry *dentry,
struct inode *inode, struct buffer_head *bh) 2
struct inode * dir = dentry -> d_parent -> d_inode ; 4
struct buffer_head * bh2 ; 7
struct dx_root * root ; 8
struct ext4_dir_entry_2 * de , * de2 ; 11
char * data1 , * top ; 12
unsigned len ; 13
int retval ; 14
unsigned blocksize ; 15
struct fake_dirent * fde ; 18
blocksize = dir -> i_sb -> s_blocksize; 20
retval = ext4_journal_get_write_access ( handle , bh ); 22
if ( retval )  23
root = ( struct dx_root * ) bh -> b_data; 28
bh2 = ext4_append ( handle , dir , & block , & retval ); 30
if ( ! ( bh2 ) )  31
data1 = bh2 -> b_data; 36
fde = & root -> dotdot; 39
de = ( struct ext4_dir_entry_2 * ) ( ( char * ) fde + ext4_rec_len_from_disk ( fde -> rec_len ) ); 40
len = ( ( char * ) root ) + blocksize - ( char * ) de; 42
memcpy ( data1 , de , len ); 43
de = ( struct ext4_dir_entry_2 * ) data1; 44
top = data1 + len; 45
while ( ( char * ) ( de2 = ext4_next_entry ( de ) ) < top )  46
de = de2; 47
de -> rec_len = ext4_rec_len_to_disk ( data1 + blocksize - ( char * ) de ); 48
de -> rec_len = ext4_rec_len_to_disk ( blocksize - EXT4_DIR_REC_LEN ( 2 ) ); 51
if ( ! ( de ) )  71
return add_dirent_to_buf ( handle , dentry , inode , de , bh ) ; 74
------------------------------
396 /home/speedy/test/source2slice/NVD/CVE_2009_1336_PATCHED_nfs_create_server.c memcpy 42
struct nfs_server *CVE_2009_1336_PATCHED_nfs_create_server(const struct nfs_mount_data *data,
struct nfs_fh *mntfh) 2
struct nfs_server * server ; 4
struct nfs_fattr fattr ; 5
int error ; 6
server = nfs_alloc_server ( ); 8
if ( ! server )  9
error = nfs_init_server ( server , data ); 13
if ( error < 0 )  14
error = nfs_probe_fsinfo ( server , mntfh , & fattr ); 22
if ( error < 0 )  23
if ( server -> nfs_client -> rpc_ops -> version == 3 )  25
if ( server -> namelen == 0 || server -> namelen > NFS3_MAXNAMLEN )  26
server -> namelen = NFS3_MAXNAMLEN; 27
if ( ! ( data -> flags & NFS_MOUNT_NORDIRPLUS ) )  28
server -> caps |= NFS_CAP_READDIRPLUS; 29
if ( server -> namelen == 0 || server -> namelen > NFS2_MAXNAMLEN )  31
server -> namelen = NFS2_MAXNAMLEN; 32
if ( ! ( fattr . valid & NFS_ATTR_FATTR ) )  35
error = server -> nfs_client -> rpc_ops -> getattr ( server , mntfh , & fattr ); 36
if ( error < 0 )  37
memcpy ( & server -> fsid , & fattr . fsid , sizeof ( server -> fsid ) ); 42
dprintk ( "Server FSID: %llx:%llx\n" , ( unsigned long long ) server -> fsid . major , ( unsigned long long ) server -> fsid . minor ); 44
BUG_ON ( ! server -> nfs_client ); 48
BUG_ON ( ! server -> nfs_client -> rpc_ops ); 49
BUG_ON ( ! server -> nfs_client -> rpc_ops -> file_inode_ops ); 50
list_add_tail ( & server -> client_link , & server -> nfs_client -> cl_superblocks ); 53
list_add_tail ( & server -> master_link , & nfs_volume_list ); 54
server -> mount_time = jiffies; 57
------------------------------
397 /home/speedy/test/source2slice/NVD/CVE_2009_1336_VULN_nfs_create_server.c memcpy 32
struct nfs_server *CVE_2009_1336_VULN_nfs_create_server(const struct nfs_mount_data *data,
struct nfs_fh *mntfh) 2
struct nfs_server * server ; 4
struct nfs_fattr fattr ; 5
int error ; 6
server = nfs_alloc_server ( ); 8
if ( ! server )  9
error = nfs_init_server ( server , data ); 13
if ( error < 0 )  14
error = nfs_probe_fsinfo ( server , mntfh , & fattr ); 22
if ( error < 0 )  23
if ( ! ( fattr . valid & NFS_ATTR_FATTR ) )  25
error = server -> nfs_client -> rpc_ops -> getattr ( server , mntfh , & fattr ); 26
if ( error < 0 )  27
memcpy ( & server -> fsid , & fattr . fsid , sizeof ( server -> fsid ) ); 32
dprintk ( "Server FSID: %llx:%llx\n" , ( unsigned long long ) server -> fsid . major , ( unsigned long long ) server -> fsid . minor ); 34
BUG_ON ( ! server -> nfs_client ); 38
BUG_ON ( ! server -> nfs_client -> rpc_ops ); 39
BUG_ON ( ! server -> nfs_client -> rpc_ops -> file_inode_ops ); 40
list_add_tail ( & server -> client_link , & server -> nfs_client -> cl_superblocks ); 43
list_add_tail ( & server -> master_link , & nfs_volume_list ); 44
server -> mount_time = jiffies; 47
return server ; 48
nfs_free_server ( server ); 51
------------------------------
398 /home/speedy/test/source2slice/NVD/CVE_2009_2287_PATCHED_kvm_arch_vcpu_ioctl_set_sregs.c memcpy 48
int CVE_2009_2287_PATCHED_kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
struct kvm_sregs *sregs) 2
vcpu -> arch . cr2 = sregs -> cr2; 17
if ( gfn_to_memslot ( vcpu -> kvm , sregs -> cr3 >> PAGE_SHIFT ) )  21
vcpu -> arch . cr3 = sregs -> cr3; 22
vcpu -> arch . cr0 = sregs -> cr0; 37
if ( ! irqchip_in_kernel ( vcpu -> kvm ) )  47
memcpy ( vcpu -> arch . irq_pending , sregs -> interrupt_bitmap , sizeof vcpu -> arch . irq_pending ); 48
vcpu -> arch . irq_summary = 0; 50
for (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i) 51
if ( vcpu -> arch . irq_pending [ i ] )  52
__set_bit ( i , & vcpu -> arch . irq_summary ); 53
kvm_set_segment ( vcpu , & sregs -> cs , VCPU_SREG_CS ); 68
kvm_set_segment ( vcpu , & sregs -> ds , VCPU_SREG_DS ); 69
kvm_set_segment ( vcpu , & sregs -> es , VCPU_SREG_ES ); 70
kvm_set_segment ( vcpu , & sregs -> fs , VCPU_SREG_FS ); 71
kvm_set_segment ( vcpu , & sregs -> gs , VCPU_SREG_GS ); 72
kvm_set_segment ( vcpu , & sregs -> ss , VCPU_SREG_SS ); 73
kvm_set_segment ( vcpu , & sregs -> tr , VCPU_SREG_TR ); 75
kvm_set_segment ( vcpu , & sregs -> ldt , VCPU_SREG_LDTR ); 76
if ( vcpu -> vcpu_id == 0 && kvm_rip_read ( vcpu ) == 0xfff0 && sregs -> cs . selector == 0xf000 && sregs -> cs . base == 0xffff0000 && ! ( vcpu -> arch . cr0 & X86_CR0_PE ) )  79
vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE; 82
vcpu_put ( vcpu ); 84
------------------------------
399 /home/speedy/test/source2slice/NVD/CVE_2009_2287_VULN_kvm_arch_vcpu_ioctl_set_sregs.c memcpy 42
int CVE_2009_2287_VULN_kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
struct kvm_sregs *sregs) 2
vcpu -> arch . cr2 = sregs -> cr2; 17
vcpu -> arch . cr3 = sregs -> cr3; 19
vcpu -> arch . cr0 = sregs -> cr0; 31
if ( ! irqchip_in_kernel ( vcpu -> kvm ) )  41
memcpy ( vcpu -> arch . irq_pending , sregs -> interrupt_bitmap , sizeof vcpu -> arch . irq_pending ); 42
vcpu -> arch . irq_summary = 0; 44
for (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i) 45
if ( vcpu -> arch . irq_pending [ i ] )  46
__set_bit ( i , & vcpu -> arch . irq_summary ); 47
kvm_set_segment ( vcpu , & sregs -> cs , VCPU_SREG_CS ); 62
kvm_set_segment ( vcpu , & sregs -> ds , VCPU_SREG_DS ); 63
kvm_set_segment ( vcpu , & sregs -> es , VCPU_SREG_ES ); 64
kvm_set_segment ( vcpu , & sregs -> fs , VCPU_SREG_FS ); 65
kvm_set_segment ( vcpu , & sregs -> gs , VCPU_SREG_GS ); 66
kvm_set_segment ( vcpu , & sregs -> ss , VCPU_SREG_SS ); 67
kvm_set_segment ( vcpu , & sregs -> tr , VCPU_SREG_TR ); 69
kvm_set_segment ( vcpu , & sregs -> ldt , VCPU_SREG_LDTR ); 70
if ( vcpu -> vcpu_id == 0 && kvm_rip_read ( vcpu ) == 0xfff0 && sregs -> cs . selector == 0xf000 && sregs -> cs . base == 0xffff0000 && ! ( vcpu -> arch . cr0 & X86_CR0_PE ) )  73
vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE; 76
vcpu_put ( vcpu ); 78
------------------------------
400 /home/speedy/test/source2slice/NVD/CVE_2009_3080_PATCHED_gdth_read_event.c memcpy 27
static int CVE_2009_3080_PATCHED_gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr) 1
gdth_evt_str * e ; 3
int eindex ; 4
if ( handle == - 1 )  9
eindex = eoldidx; 10
eindex = handle; 12
estr -> event_source = 0; 13
if ( eindex < 0 || eindex >= MAX_EVENTS )  15
e = & ebuffer [ eindex ]; 19
if ( e -> event_source != 0 )  20
memcpy ( estr , e , sizeof ( gdth_evt_str ) ); 27
------------------------------
401 /home/speedy/test/source2slice/NVD/CVE_2009_3080_VULN_gdth_read_event.c memcpy 27
static int CVE_2009_3080_VULN_gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr) 1
gdth_evt_str * e ; 3
int eindex ; 4
if ( handle == - 1 )  9
eindex = eoldidx; 10
eindex = handle; 12
estr -> event_source = 0; 13
if ( eindex >= MAX_EVENTS )  15
e = & ebuffer [ eindex ]; 19
if ( e -> event_source != 0 )  20
memcpy ( estr , e , sizeof ( gdth_evt_str ) ); 27
------------------------------
402 /home/speedy/test/source2slice/NVD/CVE_2009_4005_PATCHED_collect_rx_frame.c memcpy 23
static void
CVE_2009_4005_PATCHED_collect_rx_frame(usb_fifo * fifo, __u8 * data, int len, int finish) 2
if ( ! fifo -> skbuff )  12
fifo -> skbuff = dev_alloc_skb ( fifo -> max_size + 3 ); 13
if ( ! fifo -> skbuff )  14
if ( len )  21
if ( fifo -> skbuff -> len + len < fifo -> max_size )  22
memcpy ( skb_put ( fifo -> skbuff , len ) , data , len ); 23
------------------------------
403 /home/speedy/test/source2slice/NVD/CVE_2009_4005_VULN_collect_rx_frame.c memcpy 23
static void
CVE_2009_4005_VULN_collect_rx_frame(usb_fifo * fifo, __u8 * data, int len, int finish) 2
if ( ! fifo -> skbuff )  12
fifo -> skbuff = dev_alloc_skb ( fifo -> max_size + 3 ); 13
if ( ! fifo -> skbuff )  14
if ( len )  21
if ( fifo -> skbuff -> len + len < fifo -> max_size )  22
memcpy ( skb_put ( fifo -> skbuff , len ) , data , len ); 23
------------------------------
404 /home/speedy/test/source2slice/NVD/CVE_2010_0437_PATCHED_ip6_dst_lookup_tail.c memcpy 49
static int CVE_2010_0437_PATCHED_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ( * dst ) -> neighbour && ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
------------------------------
405 /home/speedy/test/source2slice/NVD/CVE_2010_0437_VULN_ip6_dst_lookup_tail.c memcpy 49
static int CVE_2010_0437_VULN_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
------------------------------
406 /home/speedy/test/source2slice/NVD/CVE_2010_2521_PATCHED_read_buf.c memcpy 38
static __be32 *CVE_2010_2521_PATCHED_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
argp -> p = page_address ( argp -> pagelist [ 0 ] ); 29
argp -> pagelist ++; 30
if ( argp -> pagelen < PAGE_SIZE )  31
argp -> end = argp -> p + ( argp -> pagelen >> 2 ); 32
argp -> pagelen = 0; 33
argp -> end = argp -> p + ( PAGE_SIZE >> 2 ); 35
argp -> pagelen -= PAGE_SIZE; 36
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
------------------------------
407 /home/speedy/test/source2slice/NVD/CVE_2010_2521_PATCHED_read_buf.c memcpy 27
static __be32 *CVE_2010_2521_PATCHED_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
return p ; 40
------------------------------
408 /home/speedy/test/source2slice/NVD/CVE_2010_2521_VULN_read_buf.c memcpy 38
static __be32 *CVE_2010_2521_VULN_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
argp -> p = page_address ( argp -> pagelist [ 0 ] ); 29
argp -> pagelist ++; 30
if ( argp -> pagelen < PAGE_SIZE )  31
argp -> end = p + ( argp -> pagelen >> 2 ); 32
argp -> pagelen = 0; 33
argp -> end = p + ( PAGE_SIZE >> 2 ); 35
argp -> pagelen -= PAGE_SIZE; 36
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
------------------------------
409 /home/speedy/test/source2slice/NVD/CVE_2010_2521_VULN_read_buf.c memcpy 27
static __be32 *CVE_2010_2521_VULN_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
argp -> end = p + ( argp -> pagelen >> 2 ); 32
argp -> pagelen = 0; 33
argp -> end = p + ( PAGE_SIZE >> 2 ); 35
argp -> pagelen -= PAGE_SIZE; 36
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
argp -> p += XDR_QUADLEN ( nbytes - avail ); 39
return p ; 40
------------------------------
410 /home/speedy/test/source2slice/NVD/CVE_2010_2537_PATCHED_btrfs_ioctl_clone.c memcpy 187
static noinline long CVE_2010_2537_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
ret = - EISDIR; 54
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
ret = - EXDEV; 58
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off + len > src -> i_size || off + len < off )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao ); 225
BUG_ON ( ret ); 230
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
key . offset ++; 274
if ( ret == 0 )  279
if ( ret )  288
return ret ; 299
------------------------------
411 /home/speedy/test/source2slice/NVD/CVE_2010_2537_VULN_btrfs_ioctl_clone.c memcpy 187
static noinline long CVE_2010_2537_VULN_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off >= src -> i_size || off + len > src -> i_size )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao ); 225
BUG_ON ( ret ); 230
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
key . offset ++; 274
if ( ret == 0 )  279
if ( ret )  288
return ret ; 299
------------------------------
412 /home/speedy/test/source2slice/NVD/CVE_2010_2538_PATCHED_btrfs_ioctl_clone.c memcpy 187
static noinline long CVE_2010_2538_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off + len > src -> i_size || off + len < off )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao ); 225
BUG_ON ( ret ); 230
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
key . offset ++; 274
if ( ret == 0 )  279
if ( ret )  288
return ret ; 299
------------------------------
413 /home/speedy/test/source2slice/NVD/CVE_2010_2538_VULN_btrfs_ioctl_clone.c memcpy 187
static noinline long CVE_2010_2538_VULN_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
ret = - EISDIR; 54
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
ret = - EXDEV; 58
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off >= src -> i_size || off + len > src -> i_size )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao ); 225
BUG_ON ( ret ); 230
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
key . offset ++; 274
if ( ret == 0 )  279
if ( ret )  288
return ret ; 299
------------------------------
414 /home/speedy/test/source2slice/NVD/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memcpy 293
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 293
s -> frame . palette_has_changed = 1; 295
s -> new_palette = 0; 296
* ( AVFrame * ) data = s -> frame; 300
------------------------------
415 /home/speedy/test/source2slice/NVD/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memcpy 265
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_ptr = y_ptr; 135
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_ptr += pixel_skip; 141
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
pixels [ pixel_ptr ++ ] = palette_idx1; 150
pixels [ pixel_ptr ++ ] = palette_idx2; 151
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
pixels [ pixel_ptr ++ ] = palette_idx1; 157
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_ptr = y_ptr; 177
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_ptr += pixel_skip; 185
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
pixels [ pixel_ptr ++ ] = palette_idx1; 192
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
pixels [ pixel_ptr ++ ] = palette_idx1; 199
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 212
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
pixel_ptr = y_ptr; 221
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixels [ pixel_ptr ++ ] = palette_idx1; 232
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixels [ pixel_ptr ++ ] = palette_idx1; 243
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 265
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
------------------------------
416 /home/speedy/test/source2slice/NVD/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memcpy 289
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 289
s -> frame . palette_has_changed = 1; 291
s -> new_palette = 0; 292
* ( AVFrame * ) data = s -> frame; 296
------------------------------
417 /home/speedy/test/source2slice/NVD/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memcpy 261
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_ptr = y_ptr; 133
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_ptr += pixel_skip; 138
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
pixels [ pixel_ptr ++ ] = palette_idx1; 147
pixels [ pixel_ptr ++ ] = palette_idx2; 148
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
pixels [ pixel_ptr ++ ] = palette_idx1; 154
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_ptr = y_ptr; 174
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_ptr += pixel_skip; 181
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
pixels [ pixel_ptr ++ ] = palette_idx1; 188
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
pixels [ pixel_ptr ++ ] = palette_idx1; 195
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 208
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
pixel_ptr = y_ptr; 217
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixels [ pixel_ptr ++ ] = palette_idx1; 228
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixels [ pixel_ptr ++ ] = palette_idx1; 239
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 261
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
------------------------------
418 /home/speedy/test/source2slice/NVD/CVE_2013_4936_PATCHED_IsDFP_Frame.c memcpy 25
static gboolean
CVE_2013_4936_PATCHED_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
if ( ! pinfo -> src . data || ! pinfo -> dst . data || pinfo -> dst . type != AT_ETHER || pinfo -> src . type != AT_ETHER )  18
memcpy ( & virtualFramebuffer [ 6 ] , pinfo -> src . data , 6 ); 25
------------------------------
419 /home/speedy/test/source2slice/NVD/CVE_2013_4936_PATCHED_IsDFP_Frame.c memcpy 24
static gboolean
CVE_2013_4936_PATCHED_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
if ( ! pinfo -> src . data || ! pinfo -> dst . data || pinfo -> dst . type != AT_ETHER || pinfo -> src . type != AT_ETHER )  18
memcpy ( & virtualFramebuffer [ 0 ] , pinfo -> dst . data , 6 ); 24
------------------------------
420 /home/speedy/test/source2slice/NVD/CVE_2013_4936_VULN_IsDFP_Frame.c memcpy 19
static gboolean
CVE_2013_4936_VULN_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
memcpy ( & virtualFramebuffer [ 6 ] , pinfo -> src . data , 6 ); 19
------------------------------
421 /home/speedy/test/source2slice/NVD/CVE_2013_4936_VULN_IsDFP_Frame.c memcpy 18
static gboolean
CVE_2013_4936_VULN_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
unsigned char virtualFramebuffer [ 16 ] ; 11
memcpy ( & virtualFramebuffer [ 0 ] , pinfo -> dst . data , 6 ); 18
------------------------------
422 /home/speedy/test/source2slice/NVD/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memcpy 180
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
flags = user_srbcmd -> flags; 69
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  82
data_dir = DMA_TO_DEVICE; 84
data_dir = DMA_BIDIRECTIONAL; 87
data_dir = DMA_FROM_DEVICE; 90
data_dir = DMA_NONE; 93
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 101
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 103
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  106
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  117
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  123
struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; 124
if ( actual_fibsize64 == fibsize )  130
struct user_sgmap * usg ; 172
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 173
if ( ! usg )  175
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 180
for (i = 0; i < usg->count; i++) 184
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
kfree ( usg ); 192
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 200
kfree ( usg ); 201
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
kfree ( usg ); 211
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
kfree ( usg ); 224
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
423 /home/speedy/test/source2slice/NVD/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memcpy 80
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
srbfib -> hw_fib_va -> header . XferState &= ~cpu_to_le32 ( FastResponseCapable ); 38
srbcmd = ( struct aac_srb * ) fib_data ( srbfib ); 40
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
flags = user_srbcmd -> flags; 69
srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ); 72
srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ); 73
srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ); 74
srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ); 75
srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ); 76
srbcmd -> flags = cpu_to_le32 ( flags ); 77
srbcmd -> retry_limit = 0; 78
srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ); 79
memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ); 80
dprintk ( ( KERN_DEBUG "aacraid: too many sg entries %d\n" ,
le32_to_cpu ( srbcmd -> sg . count ) ) ) 97
struct sgmap64 * psg = ( struct sgmap64 * ) & srbcmd -> sg ; 125
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
424 /home/speedy/test/source2slice/NVD/CVE_2013_6380_VULN_aac_send_raw_srb.c memcpy 179
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
flags = user_srbcmd -> flags; 68
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  81
data_dir = DMA_TO_DEVICE; 83
data_dir = DMA_BIDIRECTIONAL; 86
data_dir = DMA_FROM_DEVICE; 89
data_dir = DMA_NONE; 92
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 100
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 102
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  105
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  116
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  122
struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; 123
if ( actual_fibsize64 == fibsize )  129
struct user_sgmap * usg ; 171
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 172
if ( ! usg )  174
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 179
for (i = 0; i < usg->count; i++) 183
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
kfree ( usg ); 191
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 199
kfree ( usg ); 200
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
kfree ( usg ); 210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
kfree ( usg ); 223
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) 321
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) 333
dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) 343
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
------------------------------
425 /home/speedy/test/source2slice/NVD/CVE_2013_6380_VULN_aac_send_raw_srb.c memcpy 79
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
srbfib -> hw_fib_va -> header . XferState &= ~cpu_to_le32 ( FastResponseCapable ); 38
srbcmd = ( struct aac_srb * ) fib_data ( srbfib ); 40
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
flags = user_srbcmd -> flags; 68
srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ); 71
srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ); 72
srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ); 73
srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ); 74
srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ); 75
srbcmd -> flags = cpu_to_le32 ( flags ); 76
srbcmd -> retry_limit = 0; 77
srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ); 78
memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ); 79
------------------------------
426 /home/speedy/test/source2slice/NVD/CVE_2013_6381_PATCHED_qeth_snmp_command.c memcpy 42
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 39
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 41
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 42
------------------------------
427 /home/speedy/test/source2slice/NVD/CVE_2013_6381_VULN_qeth_snmp_command.c memcpy 38
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 35
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 37
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 38
------------------------------
428 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c memcpy 625
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
h -> list_count = 1; 479
h -> list_count = 0; 481
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & h -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
h -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & h -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
h0 -> last_slice_type = slice_type; 624
memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ); 625
h -> slice_num = ++ h0 -> current_slice; 626
if ( h -> slice_num )  628
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y; 629
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES )  630
av_log ( h -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 634
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 639
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
for (k = 0; k < h->short_ref_count; k++) 645
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
for (k = 0; k < h->long_ref_count; k++) 650
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
if ( h -> ref_count [ 0 ] )  670
h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ]; 670
if ( h -> ref_count [ 1 ] )  671
h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ]; 671
h -> er . ref_count = h -> ref_count [ 0 ]; 672
if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO )  674
av_log ( h -> avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? "F" : h -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 675
------------------------------
429 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c memcpy 625
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  213
if ( ! h0 -> cur_pic_ptr )  221
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 305
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h -> short_ref_count )  330
if ( prev )  331
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 335
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 337
if ( h0 -> first_field )  344
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  350
h0 -> cur_pic_ptr = NULL; 353
h0 -> first_field = FIELD_PICTURE ( h ); 354
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  356
h0 -> first_field = 1; 362
h0 -> cur_pic_ptr = NULL; 363
h0 -> first_field = 0; 366
h0 -> first_field = FIELD_PICTURE ( h ); 371
if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  374
if ( h264_frame_start ( h ) < 0 )  375
if ( FIELD_PICTURE ( h ) )  384
for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) 385
memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); 388
h0 -> last_slice_type = - 1; 391
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  393
for (i = 0; i < h->slice_context_count; i++) 398
if ( h -> thread_context [ i ] )  399
ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); 400
if ( ret < 0 )  401
h -> cur_pic_ptr -> frame_num = h -> frame_num; 405
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  408
h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; 413
h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); 414
if ( h -> picture_structure == PICT_BOTTOM_FIELD )  415
h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; 416
if ( h -> picture_structure == PICT_FRAME )  419
h -> curr_pic_num = h -> frame_num; 420
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 421
h -> curr_pic_num = 2 * h -> frame_num + 1; 423
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 424
if ( h -> sps . poc_type == 0 )  430
h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); 431
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  433
h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); 434
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  437
h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); 438
if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  440
h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); 441
if ( h -> pps . redundant_pic_cnt_present )  446
h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); 447
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 450
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 451
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  453
unsigned max [ 2 ] ; 454
max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); 458
num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); 459
if ( num_ref_idx_active_override_flag )  461
h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; 462
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  463
h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; 464
h -> ref_count [ 1 ] = 1; 467
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  470
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 472
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  476
h -> list_count = 2; 477
h -> list_count = 1; 479
h -> list_count = 0; 481
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  491
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & h -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
h -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & h -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
h0 -> last_slice_type = slice_type; 624
memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ); 625
h -> slice_num = ++ h0 -> current_slice; 626
if ( h -> slice_num )  628
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y; 629
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES )  630
av_log ( h -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 634
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 639
if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] )  642
AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; 644
for (k = 0; k < h->short_ref_count; k++) 645
if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  646
for (k = 0; k < h->long_ref_count; k++) 650
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf )  651
id_list [ i ] = h -> short_ref_count + k; 652
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 658
for (i = 0; i < 16; i++) 660
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 661
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 663
for (i = 16; i < 48; i++) 665
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ); 666
if ( h -> ref_count [ 0 ] )  670
h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ]; 670
if ( h -> ref_count [ 1 ] )  671
h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ]; 671
h -> er . ref_count = h -> ref_count [ 0 ]; 672
if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO )  674
av_log ( h -> avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? "F" : h -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 675
------------------------------
430 /home/speedy/test/source2slice/NVD/CVE_2013_7011_PATCHED_read_header.c memcpy 197
static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
int i , j , context_count = - 1 ; 4
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; 10
unsigned v = get_symbol ( c , state , 0 ) ; 11
if ( v >= 2 )  12
f -> version = v; 16
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 17
if ( f -> ac > 1 )  18
for (i = 1; i < 256; i++) 19
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 20
f -> colorspace = get_symbol ( c , state , 0 ); 23
if ( f -> version > 0 )  25
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 26
chroma_planes = get_rac ( c , state ); 28
chroma_h_shift = get_symbol ( c , state , 0 ); 29
chroma_v_shift = get_symbol ( c , state , 0 ); 30
transparency = get_rac ( c , state ); 31
if ( f -> plane_count )  33
if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  34
f -> chroma_planes = chroma_planes; 43
f -> chroma_h_shift = chroma_h_shift; 44
f -> chroma_v_shift = chroma_v_shift; 45
f -> transparency = transparency; 46
f -> plane_count = 2 + f -> transparency; 48
if ( f -> colorspace == 0 )  51
if ( ! f -> transparency && ! f -> chroma_planes )  52
if ( f -> avctx -> bits_per_raw_sample <= 8 )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 56
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  57
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  58
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 59
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 60
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 61
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 62
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 64
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  69
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  70
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 71
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 72
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 73
if ( f -> avctx -> bits_per_raw_sample == 9 )  78
f -> packed_at_lsb = 1; 79
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  80
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 81
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 83
if ( f -> avctx -> bits_per_raw_sample == 10 )  88
f -> packed_at_lsb = 1; 89
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  90
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 91
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 92
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 93
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 100
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 101
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 102
if ( f -> colorspace == 1 )  108
if ( f -> chroma_h_shift || f -> chroma_v_shift )  109
if ( f -> avctx -> bits_per_raw_sample == 9 )  114
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 115
if ( f -> avctx -> bits_per_raw_sample == 10 )  116
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 117
if ( f -> avctx -> bits_per_raw_sample == 12 )  118
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 119
if ( f -> avctx -> bits_per_raw_sample == 14 )  120
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 121
if ( f -> transparency )  123
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 123
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 124
if ( f -> version < 2 )  132
context_count = read_quant_tables ( c , f -> quant_table ); 133
if ( context_count < 0 )  134
if ( f -> version < 3 )  138
f -> slice_count = get_symbol ( c , state , 0 ); 139
const uint8_t * p = c -> bytestream_end ; 141
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 144
int trailer = 3 + 5 * ! ! f -> ec ; 145
int size = AV_RB24 ( p - trailer ) ; 146
if ( size + trailer > p - c -> bytestream_start )  147
p -= size + trailer; 149
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  152
for (j = 0; j < f->slice_count; j++) 157
FFV1Context * fs = f -> slice_context [ j ] ; 158
fs -> ac = f -> ac; 159
fs -> packed_at_lsb = f -> packed_at_lsb; 160
fs -> slice_damaged = 0; 162
if ( f -> version == 2 )  164
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 165
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 166
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 167
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 168
fs -> slice_x /= f -> num_h_slices; 170
fs -> slice_y /= f -> num_v_slices; 171
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 172
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 173
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  174
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  177
for (i = 0; i < f->plane_count; i++) 182
PlaneContext * const p = & fs -> plane [ i ] 183
if ( f -> version == 2 )  185
int idx = get_symbol ( c , state , 0 ) ; 186
if ( idx > ( unsigned ) f -> quant_table_count )  187
p -> quant_table_index = idx; 192
context_count = f -> context_count [ idx ]; 195
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 197
if ( f -> version <= 2 )  200
if ( p -> context_count < context_count )  202
av_freep ( & p -> state ); 203
av_freep ( & p -> vlc_state ); 204
p -> context_count = context_count; 206
------------------------------
431 /home/speedy/test/source2slice/NVD/CVE_2013_7011_PATCHED_read_header.c memcpy 193
static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; 10
unsigned v = get_symbol ( c , state , 0 ) ; 11
if ( v >= 2 )  12
f -> version = v; 16
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 17
if ( f -> ac > 1 )  18
for (i = 1; i < 256; i++) 19
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 20
f -> colorspace = get_symbol ( c , state , 0 ); 23
if ( f -> version > 0 )  25
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 26
chroma_planes = get_rac ( c , state ); 28
chroma_h_shift = get_symbol ( c , state , 0 ); 29
chroma_v_shift = get_symbol ( c , state , 0 ); 30
transparency = get_rac ( c , state ); 31
if ( f -> plane_count )  33
if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  34
f -> chroma_planes = chroma_planes; 43
f -> chroma_h_shift = chroma_h_shift; 44
f -> chroma_v_shift = chroma_v_shift; 45
f -> transparency = transparency; 46
f -> plane_count = 2 + f -> transparency; 48
if ( f -> colorspace == 0 )  51
if ( ! f -> transparency && ! f -> chroma_planes )  52
if ( f -> avctx -> bits_per_raw_sample <= 8 )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 56
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  57
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  58
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 59
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 60
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 61
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 62
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 64
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  69
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  70
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 71
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 72
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 73
if ( f -> avctx -> bits_per_raw_sample == 9 )  78
f -> packed_at_lsb = 1; 79
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  80
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 81
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 83
if ( f -> avctx -> bits_per_raw_sample == 10 )  88
f -> packed_at_lsb = 1; 89
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  90
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 91
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 92
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 93
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 100
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 101
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 102
if ( f -> colorspace == 1 )  108
if ( f -> chroma_h_shift || f -> chroma_v_shift )  109
if ( f -> avctx -> bits_per_raw_sample == 9 )  114
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 115
if ( f -> avctx -> bits_per_raw_sample == 10 )  116
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 117
if ( f -> avctx -> bits_per_raw_sample == 12 )  118
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 119
if ( f -> avctx -> bits_per_raw_sample == 14 )  120
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 121
if ( f -> transparency )  123
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 123
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 124
if ( f -> version < 2 )  132
context_count = read_quant_tables ( c , f -> quant_table ); 133
if ( context_count < 0 )  134
if ( f -> version < 3 )  138
f -> slice_count = get_symbol ( c , state , 0 ); 139
const uint8_t * p = c -> bytestream_end ; 141
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 144
int trailer = 3 + 5 * ! ! f -> ec ; 145
int size = AV_RB24 ( p - trailer ) ; 146
if ( size + trailer > p - c -> bytestream_start )  147
p -= size + trailer; 149
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  152
for (j = 0; j < f->slice_count; j++) 157
FFV1Context * fs = f -> slice_context [ j ] ; 158
fs -> ac = f -> ac; 159
fs -> packed_at_lsb = f -> packed_at_lsb; 160
fs -> slice_damaged = 0; 162
if ( f -> version == 2 )  164
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 165
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 166
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 167
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 168
fs -> slice_x /= f -> num_h_slices; 170
fs -> slice_y /= f -> num_v_slices; 171
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 172
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 173
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  174
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  177
for (i = 0; i < f->plane_count; i++) 182
PlaneContext * const p = & fs -> plane [ i ] 183
if ( f -> version == 2 )  185
int idx = get_symbol ( c , state , 0 ) ; 186
if ( idx > ( unsigned ) f -> quant_table_count )  187
p -> quant_table_index = idx; 192
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 193
------------------------------
432 /home/speedy/test/source2slice/NVD/CVE_2013_7011_VULN_read_header.c memcpy 180
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
int i , j , context_count = - 1 ; 4
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
433 /home/speedy/test/source2slice/NVD/CVE_2013_7011_VULN_read_header.c memcpy 176
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
------------------------------
434 /home/speedy/test/source2slice/NVD/CVE_2013_7023_PATCHED_ff_combine_frame.c memcpy 48
int CVE_2013_7023_PATCHED_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
* buf_size = pc -> overread_index = pc -> index + next; 35
if ( pc -> index )  39
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 40
if ( ! new_buffer )  41
pc -> buffer = new_buffer; 46
if ( next > - FF_INPUT_BUFFER_PADDING_SIZE )  47
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 48
pc -> index = 0; 50
* buf = pc -> buffer; 51
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 56
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 57
pc -> overread ++; 58
if ( pc -> overread )  61
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 62
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 64
------------------------------
435 /home/speedy/test/source2slice/NVD/CVE_2013_7023_PATCHED_ff_combine_frame.c memcpy 30
int CVE_2013_7023_PATCHED_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> index = 0; 26
pc -> buffer = new_buffer; 29
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 30
pc -> index += * buf_size; 31
------------------------------
436 /home/speedy/test/source2slice/NVD/CVE_2013_7023_VULN_ff_combine_frame.c memcpy 44
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
if ( next > - FF_INPUT_BUFFER_PADDING_SIZE )  43
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
------------------------------
437 /home/speedy/test/source2slice/NVD/CVE_2013_7023_VULN_ff_combine_frame.c memcpy 28
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
------------------------------
438 /home/speedy/test/source2slice/NVD/CVE_2013_7265_PATCHED_pn_recvmsg.c memcpy 35
static int CVE_2013_7265_PATCHED_pn_recvmsg(struct kiocb *iocb, struct sock *sk,
struct msghdr *msg, size_t len, int noblock,
int flags, int *addr_len) 3
int copylen ; 8
if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  10
skb = skb_recv_datagram ( sk , flags , noblock , & rval ); 14
if ( skb == NULL )  15
copylen = skb -> len; 20
if ( len < copylen )  21
msg -> msg_flags |= MSG_TRUNC; 22
copylen = len; 23
rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ); 26
if ( rval )  27
if ( msg -> msg_name != NULL )  34
memcpy ( msg -> msg_name , & sa , sizeof ( sa ) ); 35
------------------------------
439 /home/speedy/test/source2slice/NVD/CVE_2013_7265_VULN_pn_recvmsg.c memcpy 38
static int CVE_2013_7265_VULN_pn_recvmsg(struct kiocb *iocb, struct sock *sk,
struct msghdr *msg, size_t len, int noblock,
int flags, int *addr_len) 3
int copylen ; 8
if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  10
skb = skb_recv_datagram ( sk , flags , noblock , & rval ); 17
if ( skb == NULL )  18
copylen = skb -> len; 23
if ( len < copylen )  24
msg -> msg_flags |= MSG_TRUNC; 25
copylen = len; 26
rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ); 29
if ( rval )  30
if ( msg -> msg_name != NULL )  37
memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ); 38
------------------------------
440 /home/speedy/test/source2slice/NVD/CVE_2013_7266_PATCHED_mISDN_sock_recvmsg.c memcpy 50
static int
CVE_2013_7266_PATCHED_mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 3
struct sk_buff * skb ; 5
struct sock * sk = sock -> sk ; 6
int copied , err ; 8
if ( flags & ( MSG_OOB ) )  14
if ( sk -> sk_state == MISDN_CLOSED )  17
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 20
if ( ! skb )  21
copied = skb -> len + MISDN_HEADER_LEN; 42
if ( len < copied )  43
memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ); 50
------------------------------
441 /home/speedy/test/source2slice/NVD/CVE_2013_7266_VULN_mISDN_sock_recvmsg.c memcpy 55
static int
CVE_2013_7266_VULN_mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 3
struct sk_buff * skb ; 5
struct sock * sk = sock -> sk ; 6
int copied , err ; 9
if ( flags & ( MSG_OOB ) )  15
if ( sk -> sk_state == MISDN_CLOSED )  18
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 21
if ( ! skb )  22
copied = skb -> len + MISDN_HEADER_LEN; 47
if ( len < copied )  48
memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ); 55
------------------------------
442 /home/speedy/test/source2slice/NVD/CVE_2013_7268_PATCHED_ipx_recvmsg.c memcpy 58
static int CVE_2013_7268_PATCHED_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; 6
struct sk_buff * skb ; 8
int copied , rc ; 9
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
rc = - ENOTCONN; 32
if ( sock_flag ( sk , SOCK_ZAPPED ) )  33
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
copied = size; 44
msg -> msg_flags |= MSG_TRUNC; 45
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( sipx )  55
sipx -> sipx_family = AF_IPX; 56
sipx -> sipx_port = ipx -> ipx_source . sock; 57
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 58
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 59
sipx -> sipx_type = ipx -> ipx_type; 60
sipx -> sipx_zero = 0; 61
msg -> msg_namelen = sizeof ( * sipx ); 62
------------------------------
443 /home/speedy/test/source2slice/NVD/CVE_2013_7268_PATCHED_ipx_recvmsg.c memcpy 23
static int CVE_2013_7268_PATCHED_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( skb -> tstamp . tv64 )  52
sk -> sk_stamp = skb -> tstamp; 53
sipx -> sipx_port = ipx -> ipx_source . sock; 57
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 58
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 59
sipx -> sipx_type = ipx -> ipx_type; 60
sipx -> sipx_zero = 0; 61
msg -> msg_namelen = sizeof ( * sipx ); 62
rc = copied; 64
skb_free_datagram ( sk , skb ); 67
release_sock ( sk ); 69
return rc ; 70
------------------------------
444 /home/speedy/test/source2slice/NVD/CVE_2013_7268_VULN_ipx_recvmsg.c memcpy 60
static int CVE_2013_7268_VULN_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; 6
struct sk_buff * skb ; 8
int copied , rc ; 9
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
if ( sock_flag ( sk , SOCK_ZAPPED ) )  33
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
copied = size; 44
msg -> msg_flags |= MSG_TRUNC; 45
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( sipx )  57
sipx -> sipx_family = AF_IPX; 58
sipx -> sipx_port = ipx -> ipx_source . sock; 59
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 60
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 61
sipx -> sipx_type = ipx -> ipx_type; 62
sipx -> sipx_zero = 0; 63
------------------------------
445 /home/speedy/test/source2slice/NVD/CVE_2013_7268_VULN_ipx_recvmsg.c memcpy 23
static int CVE_2013_7268_VULN_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( skb -> tstamp . tv64 )  52
sk -> sk_stamp = skb -> tstamp; 53
sipx -> sipx_port = ipx -> ipx_source . sock; 59
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 60
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 61
sipx -> sipx_type = ipx -> ipx_type; 62
sipx -> sipx_zero = 0; 63
rc = copied; 65
skb_free_datagram ( sk , skb ); 68
release_sock ( sk ); 70
return rc ; 71
------------------------------
446 /home/speedy/test/source2slice/NVD/CVE_2013_7270_PATCHED_packet_recvmsg.c memcpy 116
static int CVE_2013_7270_PATCHED_packet_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 2
struct sock * sk = sock -> sk ; 4
struct sk_buff * skb ; 5
int copied , err ; 6
err = - EINVAL; 9
if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) )  10
if ( pkt_sk ( sk ) -> ifindex < 0 )  15
if ( flags & MSG_ERRQUEUE )  19
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 33
if ( skb == NULL )  41
if ( pkt_sk ( sk ) -> has_vnet_hdr )  44
struct virtio_net_hdr vnet_hdr = { 0 } ; 45
vnet_hdr_len = sizeof ( vnet_hdr ); 48
if ( len < vnet_hdr_len )  49
len -= vnet_hdr_len; 52
if ( skb_is_gso ( skb ) )  54
struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; 55
vnet_hdr . hdr_len = skb_headlen ( skb ); 58
vnet_hdr . gso_size = sinfo -> gso_size; 59
if ( sinfo -> gso_type & SKB_GSO_TCPV4 )  60
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4; 61
if ( sinfo -> gso_type & SKB_GSO_TCPV6 )  62
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6; 63
if ( sinfo -> gso_type & SKB_GSO_UDP )  64
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP; 65
if ( sinfo -> gso_type & SKB_GSO_FCOE )  66
if ( sinfo -> gso_type & SKB_GSO_TCP_ECN )  70
vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN; 71
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE; 73
if ( skb -> ip_summed == CHECKSUM_PARTIAL )  75
if ( skb -> ip_summed == CHECKSUM_UNNECESSARY )  79
vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID; 80
err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ); 83
if ( err < 0 )  85
copied = skb -> len; 93
if ( copied > len )  94
copied = len; 95
msg -> msg_flags |= MSG_TRUNC; 96
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 99
if ( err )  100
if ( msg -> msg_name )  105
if ( sock -> type == SOCK_PACKET )  109
msg -> msg_namelen = sizeof ( struct sockaddr_pkt ); 110
msg -> msg_namelen = sll -> sll_halen +
offsetof ( struct sockaddr_ll , sll_addr ) 114
memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ); 116
put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ); 137
------------------------------
447 /home/speedy/test/source2slice/NVD/CVE_2013_7270_VULN_packet_recvmsg.c memcpy 119
static int CVE_2013_7270_VULN_packet_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 2
struct sock * sk = sock -> sk ; 4
struct sk_buff * skb ; 5
int copied , err ; 6
struct sockaddr_ll * sll ; 7
err = - EINVAL; 10
if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) )  11
if ( pkt_sk ( sk ) -> ifindex < 0 )  16
if ( flags & MSG_ERRQUEUE )  20
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 34
if ( skb == NULL )  42
if ( pkt_sk ( sk ) -> has_vnet_hdr )  45
struct virtio_net_hdr vnet_hdr = { 0 } ; 46
err = - EINVAL; 48
vnet_hdr_len = sizeof ( vnet_hdr ); 49
if ( len < vnet_hdr_len )  50
len -= vnet_hdr_len; 53
if ( skb_is_gso ( skb ) )  55
struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; 56
vnet_hdr . hdr_len = skb_headlen ( skb ); 59
vnet_hdr . gso_size = sinfo -> gso_size; 60
if ( sinfo -> gso_type & SKB_GSO_TCPV4 )  61
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4; 62
if ( sinfo -> gso_type & SKB_GSO_TCPV6 )  63
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6; 64
if ( sinfo -> gso_type & SKB_GSO_UDP )  65
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP; 66
if ( sinfo -> gso_type & SKB_GSO_FCOE )  67
if ( sinfo -> gso_type & SKB_GSO_TCP_ECN )  71
vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN; 72
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE; 74
if ( skb -> ip_summed == CHECKSUM_PARTIAL )  76
if ( skb -> ip_summed == CHECKSUM_UNNECESSARY )  80
vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID; 81
err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ); 84
if ( err < 0 )  86
sll = & PACKET_SKB_CB ( skb ) -> sa . ll; 95
if ( sock -> type == SOCK_PACKET )  96
msg -> msg_namelen = sizeof ( struct sockaddr_pkt ); 97
msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) 99
copied = skb -> len; 106
if ( copied > len )  107
copied = len; 108
msg -> msg_flags |= MSG_TRUNC; 109
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 112
if ( err )  113
if ( msg -> msg_name )  118
memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ); 119
put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ); 139
------------------------------
448 /home/speedy/test/source2slice/NVD/CVE_2014_0160_PATCHED_dtls1_process_heartbeat.c memcpy 44
int
CVE_2014_0160_PATCHED_dtls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )  15
hbtype = * p ++; 17
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )  19
pl = p; 21
if ( hbtype == TLS1_HB_REQUEST )  23
unsigned char * buffer , * bp ; 25
unsigned int write_length = 1 + 2 + payload + padding ; 26
if ( write_length > SSL3_RT_MAX_PLAIN_LENGTH )  31
buffer = OPENSSL_malloc ( write_length ); 38
bp = buffer; 39
* bp ++ = TLS1_HB_RESPONSE; 42
memcpy ( bp , pl , payload ); 44
bp += payload; 45
RAND_pseudo_bytes ( bp , padding ); 47
------------------------------
449 /home/speedy/test/source2slice/NVD/CVE_2014_0160_PATCHED_tls1_process_heartbeat.c memcpy 38
int
CVE_2014_0160_PATCHED_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )  15
hbtype = * p ++; 17
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )  19
pl = p; 21
if ( hbtype == TLS1_HB_REQUEST )  23
unsigned char * buffer , * bp ; 25
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 32
bp = buffer; 33
* bp ++ = TLS1_HB_RESPONSE; 36
memcpy ( bp , pl , payload ); 38
bp += payload; 39
RAND_pseudo_bytes ( bp , padding ); 41
------------------------------
450 /home/speedy/test/source2slice/NVD/CVE_2014_0160_VULN_dtls1_process_heartbeat.c memcpy 34
int
CVE_2014_0160_VULN_dtls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
pl = p; 12
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
------------------------------
451 /home/speedy/test/source2slice/NVD/CVE_2014_0160_VULN_tls1_process_heartbeat.c memcpy 34
int
CVE_2014_0160_VULN_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
pl = p; 12
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
------------------------------
452 /home/speedy/test/source2slice/NVD/CVE_2014_1509_PATCHED__cairo_dwrite_load_truetype_table.c memcpy 27
cairo_int_status_t
CVE_2014_1509_PATCHED__cairo_dwrite_load_truetype_table(void                 *scaled_font,
unsigned long         tag,
long                  offset,
unsigned char        *buffer,
unsigned long        *length) 6
const void * data ; 11
UINT32 size ; 12
BOOL exists ; 14
if ( ! exists )  21
if ( buffer && * length && ( UINT32 ) offset < size )  25
size = MIN ( size - ( UINT32 ) offset , * length ); 26
memcpy ( buffer , ( const char * ) data + offset , size ); 27
------------------------------
453 /home/speedy/test/source2slice/NVD/CVE_2014_1509_VULN__cairo_dwrite_load_truetype_table.c memcpy 27
cairo_int_status_t
CVE_2014_1509_VULN__cairo_dwrite_load_truetype_table(void                 *scaled_font,
unsigned long         tag,
long                  offset,
unsigned char        *buffer,
unsigned long        *length) 6
const void * data ; 11
UINT32 size ; 12
BOOL exists ; 14
if ( ! exists )  21
if ( buffer )  26
memcpy ( buffer , data , size ); 27
------------------------------
454 /home/speedy/test/source2slice/NVD/CVE_2014_2099_PATCHED_msrle_decode_frame.c memcpy 44
static int CVE_2014_2099_PATCHED_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int istride = FFALIGN ( avctx -> width * avctx -> bits_per_coded_sample , 32 ) / 8 ; 8
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
if ( avctx -> height * istride == avpkt -> size )  29
int linesize = av_image_get_linesize ( avctx -> pix_fmt , avctx -> width , 0 ) ; 30
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ; 32
int i , j ; 33
for (i = 0; i < avctx->height; i++) 35
if ( avctx -> bits_per_coded_sample == 4 )  36
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
buf -= istride; 46
ptr += s -> frame -> linesize [ 0 ]; 47
------------------------------
455 /home/speedy/test/source2slice/NVD/CVE_2014_2099_PATCHED_msrle_decode_frame.c memcpy 25
static int CVE_2014_2099_PATCHED_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
ptr += s -> frame -> linesize [ 0 ]; 47
bytestream2_init ( & s -> gb , buf , buf_size ); 50
ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , avctx -> bits_per_coded_sample , & s -> gb ); 51
if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 )  54
return ret ; 55
------------------------------
456 /home/speedy/test/source2slice/NVD/CVE_2014_2099_PATCHED_msrle_decode_frame.c memcpy 22
static int CVE_2014_2099_PATCHED_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
ptr += s -> frame -> linesize [ 0 ]; 47
bytestream2_init ( & s -> gb , buf , buf_size ); 50
ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , avctx -> bits_per_coded_sample , & s -> gb ); 51
if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 )  54
return ret ; 55
------------------------------
457 /home/speedy/test/source2slice/NVD/CVE_2014_2099_VULN_msrle_decode_frame.c memcpy 44
static int CVE_2014_2099_VULN_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int istride = FFALIGN ( avctx -> width * avctx -> bits_per_coded_sample , 32 ) / 8 ; 8
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
if ( avctx -> height * istride == avpkt -> size )  29
int linesize = ( avctx -> width * avctx -> bits_per_coded_sample + 7 ) / 8 ; 30
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ; 32
int i , j ; 33
for (i = 0; i < avctx->height; i++) 35
if ( avctx -> bits_per_coded_sample == 4 )  36
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
buf -= istride; 46
ptr += s -> frame -> linesize [ 0 ]; 47
------------------------------
458 /home/speedy/test/source2slice/NVD/CVE_2014_2099_VULN_msrle_decode_frame.c memcpy 25
static int CVE_2014_2099_VULN_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
ptr += s -> frame -> linesize [ 0 ]; 47
bytestream2_init ( & s -> gb , buf , buf_size ); 50
ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , avctx -> bits_per_coded_sample , & s -> gb ); 51
if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 )  54
return ret ; 55
------------------------------
459 /home/speedy/test/source2slice/NVD/CVE_2014_2099_VULN_msrle_decode_frame.c memcpy 22
static int CVE_2014_2099_VULN_msrle_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
MsrleContext * s = avctx -> priv_data ; 7
int ret ; 9
s -> buf = buf; 11
s -> size = buf_size; 12
if ( ( ret = ff_reget_buffer ( avctx , s -> frame ) ) < 0 )  14
if ( avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8 )  17
const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ; 18
if ( pal )  20
s -> frame -> palette_has_changed = 1; 21
memcpy ( s -> pal , pal , AVPALETTE_SIZE ); 22
memcpy ( s -> frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ); 25
uint8_t * ptr = s -> frame -> data [ 0 ] ; 31
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 38
ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF; 39
ptr [ j + 0 ] = buf [ j >> 1 ] >> 4; 42
memcpy ( ptr , buf , linesize ); 44
ptr += s -> frame -> linesize [ 0 ]; 47
bytestream2_init ( & s -> gb , buf , buf_size ); 50
ff_msrle_decode ( avctx , ( AVPicture * ) s -> frame , avctx -> bits_per_coded_sample , & s -> gb ); 51
if ( ( ret = av_frame_ref ( data , s -> frame ) ) < 0 )  54
return ret ; 55
------------------------------
460 /home/speedy/test/source2slice/NVD/CVE_2014_3183_PATCHED_logi_dj_ll_raw_request.c memcpy 23
static int CVE_2014_3183_PATCHED_logi_dj_ll_raw_request(struct hid_device *hid,
unsigned char reportnum, __u8 *buf,
size_t count, unsigned char report_type,
int reqtype) 4
struct dj_device * djdev = hid -> driver_data ; 6
u8 * out_buf ; 8
if ( buf [ 0 ] != REPORT_TYPE_LEDS )  11
out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ); 14
if ( ! out_buf )  15
if ( count > DJREPORT_SHORT_LENGTH - 2 )  18
count = DJREPORT_SHORT_LENGTH - 2; 19
out_buf [ 0 ] = REPORT_ID_DJ_SHORT; 21
out_buf [ 1 ] = djdev -> device_index; 22
memcpy ( out_buf + 2 , buf , count ); 23
ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ); 25
kfree ( out_buf ); 28
return ret ; 29
------------------------------
461 /home/speedy/test/source2slice/NVD/CVE_2014_3183_VULN_logi_dj_ll_raw_request.c memcpy 23
static int CVE_2014_3183_VULN_logi_dj_ll_raw_request(struct hid_device *hid,
unsigned char reportnum, __u8 *buf,
size_t count, unsigned char report_type,
int reqtype) 4
struct dj_device * djdev = hid -> driver_data ; 6
u8 * out_buf ; 8
if ( buf [ 0 ] != REPORT_TYPE_LEDS )  11
out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ); 14
if ( ! out_buf )  15
if ( count < DJREPORT_SHORT_LENGTH - 2 )  18
count = DJREPORT_SHORT_LENGTH - 2; 19
out_buf [ 0 ] = REPORT_ID_DJ_SHORT; 21
out_buf [ 1 ] = djdev -> device_index; 22
memcpy ( out_buf + 2 , buf , count ); 23
ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ); 25
kfree ( out_buf ); 28
return ret ; 29
------------------------------
462 /home/speedy/test/source2slice/NVD/CVE_2014_3185_PATCHED_command_port_read_callback.c memcpy 40
static void CVE_2014_3185_PATCHED_command_port_read_callback(struct urb *urb) 1
struct usb_serial_port * command_port = urb -> context ; 3
struct whiteheat_command_private * command_info ; 4
int status = urb -> status ; 5
unsigned char * data = urb -> transfer_buffer ; 6
command_info = usb_get_serial_port_data ( command_port ); 9
if ( ! command_info )  10
if ( ! urb -> actual_length )  14
if ( status )  18
if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE )  28
if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE )  31
if ( data [ 0 ] == WHITEHEAT_EVENT )  34
if ( ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) )  38
memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ); 40
command_info -> command_finished = WHITEHEAT_CMD_COMPLETE; 42
wake_up ( & command_info -> wait_command ); 43
------------------------------
463 /home/speedy/test/source2slice/NVD/CVE_2014_3185_VULN_command_port_read_callback.c memcpy 35
static void CVE_2014_3185_VULN_command_port_read_callback(struct urb *urb) 1
struct usb_serial_port * command_port = urb -> context ; 3
struct whiteheat_command_private * command_info ; 4
int status = urb -> status ; 5
unsigned char * data = urb -> transfer_buffer ; 6
command_info = usb_get_serial_port_data ( command_port ); 9
if ( ! command_info )  10
if ( status )  14
if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE )  24
if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE )  27
if ( data [ 0 ] == WHITEHEAT_EVENT )  30
if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS )  34
memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ); 35
command_info -> command_finished = WHITEHEAT_CMD_COMPLETE; 37
wake_up ( & command_info -> wait_command ); 38
------------------------------
464 /home/speedy/test/source2slice/NVD/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c memcpy 177
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( s -> tlsext_debug_cb )  37
s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ); 38
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( s -> session -> tlsext_ecpointformatlist != NULL )  66
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 66
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
n2s ( sdata , s -> s3 -> server_opaque_prf_input_len ); 112
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input != NULL )  119
OPENSSL_free ( s -> s3 -> server_opaque_prf_input ); 120
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
if ( ! s -> hit && tlsext_servername == 1 )  221
if ( s -> tlsext_hostname )  223
if ( s -> session -> tlsext_hostname == NULL )  225
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 227
if ( ! s -> session -> tlsext_hostname )  228
if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  253
------------------------------
465 /home/speedy/test/source2slice/NVD/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c memcpy 73
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
if ( s -> session -> tlsext_hostname == NULL )  225
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 227
if ( ! s -> session -> tlsext_hostname )  228
if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  253
------------------------------
466 /home/speedy/test/source2slice/NVD/CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext.c memcpy 174
int CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( s -> tlsext_debug_cb )  37
s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ); 38
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
s -> session -> tlsext_ecpointformatlist_length = 0; 63
if ( s -> session -> tlsext_ecpointformatlist != NULL )  64
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 64
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  65
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 70
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 71
sdata = s -> session -> tlsext_ecpointformatlist; 74
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 75
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 76
if ( type == TLSEXT_TYPE_session_ticket )  82
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  84
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  90
s -> tlsext_ticket_expected = 1; 96
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  99
unsigned char * sdata = data ; 102
if ( size < 2 )  104
n2s ( sdata , s -> s3 -> server_opaque_prf_input_len ); 109
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  110
if ( s -> s3 -> server_opaque_prf_input != NULL )  116
OPENSSL_free ( s -> s3 -> server_opaque_prf_input ); 117
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  118
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 119
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 121
if ( s -> s3 -> server_opaque_prf_input == NULL )  123
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  130
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  136
s -> tlsext_status_expected = 1; 142
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  145
unsigned char * selected ; 148
unsigned char selected_len ; 149
if ( s -> ctx -> next_proto_select_cb == NULL )  152
if ( ! ssl_next_proto_validate ( data , size ) )  158
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  163
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 168
if ( ! s -> next_proto_negotiated )  169
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 174
s -> next_proto_negotiated_len = selected_len; 175
s -> s3 -> next_proto_neg_seen = 1; 176
if ( type == TLSEXT_TYPE_renegotiate )  179
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  181
if ( type == TLSEXT_TYPE_heartbeat )  186
switch ( data [ 0 ] )  188
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 195
if ( type == TLSEXT_TYPE_use_srtp )  202
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  204
data += size; 209
if ( ! s -> hit && tlsext_servername == 1 )  218
if ( s -> tlsext_hostname )  220
if ( s -> session -> tlsext_hostname == NULL )  222
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 224
if ( ! s -> session -> tlsext_hostname )  225
if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  250
------------------------------
467 /home/speedy/test/source2slice/NVD/CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext.c memcpy 71
int CVE_2014_3509_VULN_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
s -> session -> tlsext_ecpointformatlist_length = 0; 63
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  65
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 70
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 71
sdata = s -> session -> tlsext_ecpointformatlist; 74
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 75
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 76
if ( type == TLSEXT_TYPE_session_ticket )  82
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  84
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  90
s -> tlsext_ticket_expected = 1; 96
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  99
unsigned char * sdata = data ; 102
if ( size < 2 )  104
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  110
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  118
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 119
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 121
if ( s -> s3 -> server_opaque_prf_input == NULL )  123
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  130
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  136
s -> tlsext_status_expected = 1; 142
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  145
unsigned char * selected ; 148
unsigned char selected_len ; 149
if ( s -> ctx -> next_proto_select_cb == NULL )  152
if ( ! ssl_next_proto_validate ( data , size ) )  158
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  163
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 168
if ( ! s -> next_proto_negotiated )  169
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 174
s -> next_proto_negotiated_len = selected_len; 175
s -> s3 -> next_proto_neg_seen = 1; 176
if ( type == TLSEXT_TYPE_renegotiate )  179
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  181
if ( type == TLSEXT_TYPE_heartbeat )  186
switch ( data [ 0 ] )  188
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 195
if ( type == TLSEXT_TYPE_use_srtp )  202
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  204
data += size; 209
if ( s -> session -> tlsext_hostname == NULL )  222
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 224
if ( ! s -> session -> tlsext_hostname )  225
if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  250
------------------------------
468 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c memcpy 380
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int i ; 18
unsigned int csl , sil , cl ; 19
int n = 0 , j ; 20
int type = 0 ; 21
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
memcpy ( buf , p , n ); 36
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  47
type = 1; 48
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  81
type = 1; 83
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  92
type = 1; 93
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  126
v [ 1 ] = 0xff; 127
v [ 1 ] = p [ 10 ]; 129
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  130
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  132
s -> version = TLS1_2_VERSION; 135
type = 3; 136
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  138
s -> version = TLS1_1_VERSION; 141
type = 3; 142
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  144
s -> version = TLS1_VERSION; 146
type = 3; 147
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  149
s -> version = SSL3_VERSION; 151
type = 3; 152
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  158
s -> version = SSL3_VERSION; 160
type = 3; 161
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  163
s -> version = TLS1_VERSION; 167
type = 3; 168
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  172
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  180
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  188
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  196
type = 2; 201
p = s -> packet; 202
v [ 0 ] = p [ 3 ]; 203
v [ 1 ] = p [ 4 ]; 204
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 218
if ( n > ( 1024 * 4 ) )  219
if ( n < 9 )  224
j = ssl23_read_bytes ( s , n + 2 ); 230
if ( j <= 0 )  234
p = s -> packet; 240
p += 5; 241
d = ( unsigned char * ) s -> init_buf -> data; 245
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  246
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 255
d += 3; 258
* ( d ++ ) = SSL3_VERSION_MAJOR; 261
* ( d ++ ) = v [ 1 ]; 262
i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl; 266
memset ( d , 0 , SSL3_RANDOM_SIZE ); 267
d += SSL3_RANDOM_SIZE; 269
* ( d ++ ) = 0; 272
d += 2; 277
for (i=0; i<csl; i+=3) 278
if ( p [ i ] != 0 )  280
* ( d ++ ) = p [ i + 1 ]; 281
* ( d ++ ) = p [ i + 2 ]; 282
* ( d ++ ) = 1; 288
* ( d ++ ) = 0; 289
p = p + csl + sil + cl; 293
while ( p < s -> packet + s -> packet_length )  294
* ( d ++ ) = * ( p ++ ); 296
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 300
s -> s3 -> tmp . reuse_message = 1; 304
s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO; 305
s -> s3 -> tmp . message_size = i; 306
if ( type == 1 )  312
if ( ( type == 2 ) || ( type == 3 ) )  360
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  364
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 367
if ( type == 3 )  369
s -> rstate = SSL_ST_READ_HEADER; 373
s -> packet_length = n; 374
if ( s -> s3 -> rbuf . buf == NULL )  375
if ( ! ssl3_setup_read_buffer ( s ) )  376
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 379
memcpy ( s -> packet , buf , n ); 380
s -> s3 -> rbuf . left = n; 381
s -> s3 -> rbuf . offset = 0; 382
s -> handshake_func = s -> method -> ssl_accept; 401
s -> init_num = 0; 410
return ( SSL_accept ( s ) ) ; 413
------------------------------
469 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c memcpy 268
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int i ; 18
unsigned int csl , sil , cl ; 19
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  126
v [ 1 ] = 0xff; 127
v [ 1 ] = p [ 10 ]; 129
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  130
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  132
s -> version = TLS1_2_VERSION; 135
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  138
s -> version = TLS1_1_VERSION; 141
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  144
s -> version = TLS1_VERSION; 146
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  149
s -> version = SSL3_VERSION; 151
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  158
s -> version = SSL3_VERSION; 160
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  163
s -> version = TLS1_VERSION; 167
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  172
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  180
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  188
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  196
p = s -> packet; 202
v [ 0 ] = p [ 3 ]; 203
v [ 1 ] = p [ 4 ]; 204
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 218
if ( n > ( 1024 * 4 ) )  219
if ( n < 9 )  224
j = ssl23_read_bytes ( s , n + 2 ); 230
if ( j <= 0 )  234
p = s -> packet; 240
p += 5; 241
d = ( unsigned char * ) s -> init_buf -> data; 245
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  246
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 255
d += 3; 258
* ( d ++ ) = SSL3_VERSION_MAJOR; 261
* ( d ++ ) = v [ 1 ]; 262
i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl; 266
memset ( d , 0 , SSL3_RANDOM_SIZE ); 267
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 268
------------------------------
470 /home/speedy/test/source2slice/NVD/CVE_2014_3511_PATCHED_ssl23_get_client_hello.c memcpy 36
int CVE_2014_3511_PATCHED_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
unsigned char * p , * d , * d_len , * dd ; 17
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
memcpy ( buf , p , n ); 36
memcpy ( s -> packet , buf , n ); 380
s -> s3 -> rbuf . left = n; 381
s -> s3 -> rbuf . offset = 0; 382
s -> handshake_func = s -> method -> ssl_accept; 401
s -> init_num = 0; 410
if ( buf != buf_space )  412
OPENSSL_free ( buf ); 412
return ( SSL_accept ( s ) ) ; 413
if ( buf != buf_space )  415
OPENSSL_free ( buf ); 415
------------------------------
471 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c memcpy 364
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int i ; 18
unsigned int csl , sil , cl ; 19
int n = 0 , j ; 20
int type = 0 ; 21
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
memcpy ( buf , p , n ); 36
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  47
type = 1; 48
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  81
type = 1; 83
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) )  92
type = 1; 93
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
v [ 0 ] = p [ 1 ]; 107
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  130
v [ 1 ] = 0xff; 131
v [ 1 ] = p [ 10 ]; 133
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  134
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  136
s -> version = TLS1_2_VERSION; 139
type = 3; 140
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  142
s -> version = TLS1_1_VERSION; 145
type = 3; 146
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  148
s -> version = TLS1_VERSION; 150
type = 3; 151
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  153
s -> version = SSL3_VERSION; 155
type = 3; 156
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  162
s -> version = SSL3_VERSION; 164
type = 3; 165
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  167
s -> version = TLS1_VERSION; 171
type = 3; 172
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  176
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  184
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  192
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  200
type = 2; 205
p = s -> packet; 206
v [ 0 ] = p [ 3 ]; 207
v [ 1 ] = p [ 4 ]; 208
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 210
if ( n > ( 1024 * 4 ) )  211
j = ssl23_read_bytes ( s , n + 2 ); 217
if ( j <= 0 )  218
p = s -> packet; 224
p += 5; 225
d = ( unsigned char * ) s -> init_buf -> data; 229
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  230
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 239
d += 3; 242
* ( d ++ ) = SSL3_VERSION_MAJOR; 245
* ( d ++ ) = v [ 1 ]; 246
i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl; 250
memset ( d , 0 , SSL3_RANDOM_SIZE ); 251
d += SSL3_RANDOM_SIZE; 253
* ( d ++ ) = 0; 256
d += 2; 261
for (i=0; i<csl; i+=3) 262
if ( p [ i ] != 0 )  264
* ( d ++ ) = p [ i + 1 ]; 265
* ( d ++ ) = p [ i + 2 ]; 266
* ( d ++ ) = 1; 272
* ( d ++ ) = 0; 273
p = p + csl + sil + cl; 277
while ( p < s -> packet + s -> packet_length )  278
* ( d ++ ) = * ( p ++ ); 280
i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4; 284
s -> s3 -> tmp . reuse_message = 1; 288
s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO; 289
s -> s3 -> tmp . message_size = i; 290
if ( type == 1 )  296
if ( ( type == 2 ) || ( type == 3 ) )  344
if ( ! ssl_init_wbio_buffer ( s , 1 ) )  348
s -> state = SSL3_ST_SR_CLNT_HELLO_A; 351
if ( type == 3 )  353
s -> rstate = SSL_ST_READ_HEADER; 357
s -> packet_length = n; 358
if ( s -> s3 -> rbuf . buf == NULL )  359
if ( ! ssl3_setup_read_buffer ( s ) )  360
s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ); 363
memcpy ( s -> packet , buf , n ); 364
s -> s3 -> rbuf . left = n; 365
s -> s3 -> rbuf . offset = 0; 366
s -> handshake_func = s -> method -> ssl_accept; 385
s -> init_num = 0; 394
return ( SSL_accept ( s ) ) ; 397
------------------------------
472 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c memcpy 252
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
unsigned char * p , * d , * d_len , * dd ; 17
unsigned int i ; 18
unsigned int csl , sil , cl ; 19
int v [ 2 ] ; 22
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) )  38
if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) )  43
if ( p [ 3 ] == SSL3_VERSION_MAJOR )  50
if ( p [ 4 ] >= TLS1_VERSION_MINOR )  54
if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  56
s -> version = TLS1_2_VERSION; 59
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 60
if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  62
s -> version = TLS1_1_VERSION; 65
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 67
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  69
s -> version = TLS1_VERSION; 71
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 73
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  75
s -> version = SSL3_VERSION; 77
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 79
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  86
s -> version = SSL3_VERSION; 88
s -> state = SSL23_ST_SR_CLNT_HELLO_B; 90
if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) )  97
v [ 0 ] = p [ 1 ]; 107
if ( p [ 3 ] == 0 && p [ 4 ] < 6 )  116
if ( p [ 9 ] > SSL3_VERSION_MAJOR )  130
v [ 1 ] = 0xff; 131
v [ 1 ] = p [ 10 ]; 133
if ( v [ 1 ] >= TLS1_VERSION_MINOR )  134
if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) )  136
s -> version = TLS1_2_VERSION; 139
if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) )  142
s -> version = TLS1_1_VERSION; 145
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  148
s -> version = TLS1_VERSION; 150
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  153
s -> version = SSL3_VERSION; 155
if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) )  162
s -> version = SSL3_VERSION; 164
if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) )  167
s -> version = TLS1_VERSION; 171
if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) )  176
if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 )  184
if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) )  192
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B )  200
p = s -> packet; 206
v [ 0 ] = p [ 3 ]; 207
v [ 1 ] = p [ 4 ]; 208
n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ]; 210
if ( n > ( 1024 * 4 ) )  211
j = ssl23_read_bytes ( s , n + 2 ); 217
if ( j <= 0 )  218
p = s -> packet; 224
p += 5; 225
d = ( unsigned char * ) s -> init_buf -> data; 229
if ( ( csl + sil + cl + 11 ) != s -> packet_length )  230
* ( d ++ ) = SSL3_MT_CLIENT_HELLO; 239
d += 3; 242
* ( d ++ ) = SSL3_VERSION_MAJOR; 245
* ( d ++ ) = v [ 1 ]; 246
i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl; 250
memset ( d , 0 , SSL3_RANDOM_SIZE ); 251
memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ); 252
------------------------------
473 /home/speedy/test/source2slice/NVD/CVE_2014_3511_VULN_ssl23_get_client_hello.c memcpy 36
int CVE_2014_3511_VULN_ssl23_get_client_hello(SSL *s) 1
char buf_space [ 11 ] ; 3
char * buf = & ( buf_space [ 0 ] ) ; 16
unsigned char * p , * d , * d_len , * dd ; 17
if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A )  24
if ( ! ssl3_setup_buffers ( s ) )  29
n = ssl23_read_bytes ( s , sizeof buf_space ); 31
if ( n != sizeof buf_space )  32
p = s -> packet; 34
memcpy ( buf , p , n ); 36
memcpy ( s -> packet , buf , n ); 364
s -> s3 -> rbuf . left = n; 365
s -> s3 -> rbuf . offset = 0; 366
s -> handshake_func = s -> method -> ssl_accept; 385
s -> init_num = 0; 394
if ( buf != buf_space )  396
OPENSSL_free ( buf ); 396
return ( SSL_accept ( s ) ) ; 397
if ( buf != buf_space )  399
OPENSSL_free ( buf ); 399
------------------------------
474 /home/speedy/test/source2slice/NVD/CVE_2014_3631_PATCHED_assoc_array_gc.c memcpy 45
int CVE_2014_3631_PATCHED_assoc_array_gc(struct assoc_array *array,
const struct assoc_array_ops *ops,
bool (*iterator)(void *object, void *iterator_data),
void *iterator_data) 4
struct assoc_array_shortcut * shortcut , * new_s ; 6
struct assoc_array_node * node , * new_n ; 7
struct assoc_array_edit * edit ; 8
struct assoc_array_ptr * cursor , * ptr ; 9
struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; 10
int keylen , slot , nr_free , next_slot , i ; 12
if ( ! array -> root )  16
edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ); 19
if ( ! edit )  20
new_root = new_parent = NULL; 28
new_ptr_pp = & new_root; 29
cursor = array -> root; 30
if ( assoc_array_ptr_is_shortcut ( cursor ) )  36
shortcut = assoc_array_ptr_to_shortcut ( cursor ); 37
keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ); 38
keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; 39
new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ); 40
if ( ! new_s )  42
pr_devel ( "dup shortcut %p -> %p\n" , shortcut , new_s ); 44
memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ); 45
new_s -> back_pointer = new_parent; 47
new_s -> parent_slot = shortcut -> parent_slot; 48
* new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ); 49
new_ptr_pp = & new_s -> next_node; 50
cursor = shortcut -> next_node; 51
node = assoc_array_ptr_to_node ( cursor ); 55
new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ); 56
if ( ! new_n )  57
pr_devel ( "dup node %p -> %p\n" , node , new_n ); 59
new_n -> back_pointer = new_parent; 60
new_n -> parent_slot = node -> parent_slot; 61
* new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ); 62
slot = 0; 64
for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) 68
ptr = node -> slots [ slot ]; 69
if ( ! ptr )  70
if ( assoc_array_ptr_is_leaf ( ptr ) )  73
if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) )  74
new_n -> slots [ slot ] = ptr; 79
new_ptr_pp = & new_n -> slots [ slot ]; 83
cursor = ptr; 84
pr_devel ( "-- compress node %p --\n" , new_n ); 88
new_n -> nr_leaves_on_branch = 0; 93
nr_free = 0; 94
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 95
ptr = new_n -> slots [ slot ]; 96
if ( ! ptr )  97
nr_free ++; 98
if ( assoc_array_ptr_is_leaf ( ptr ) )  99
new_n -> nr_leaves_on_branch ++; 100
pr_devel ( "free=%d, leaves=%lu\n" , nr_free , new_n -> nr_leaves_on_branch ); 102
next_slot = 0; 105
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 106
struct assoc_array_shortcut * s ; 107
struct assoc_array_node * child ; 108
ptr = new_n -> slots [ slot ]; 110
if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) )  111
s = NULL; 114
if ( assoc_array_ptr_is_shortcut ( ptr ) )  115
s = assoc_array_ptr_to_shortcut ( ptr ); 116
ptr = s -> next_node; 117
child = assoc_array_ptr_to_node ( ptr ); 120
new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch; 121
if ( child -> nr_leaves_on_branch <= nr_free + 1 )  123
pr_devel ( "[%d] fold node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 125
BUG_ON ( s ); 132
new_n -> slots [ slot ] = NULL; 134
nr_free ++; 135
if ( slot < next_slot )  136
next_slot = slot; 137
for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) 138
struct assoc_array_ptr * p = child -> slots [ i ] ; 139
if ( ! p )  140
BUG_ON ( assoc_array_ptr_is_meta ( p ) ); 142
while ( new_n -> slots [ next_slot ] )  143
next_slot ++; 144
BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ); 145
new_n -> slots [ next_slot ++ ] = p; 146
nr_free --; 147
kfree ( child ); 149
pr_devel ( "[%d] retain node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 151
pr_devel ( "after: %lu\n" , new_n -> nr_leaves_on_branch ); 157
nr_leaves_on_tree = new_n -> nr_leaves_on_branch; 159
if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 )  162
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 163
if ( ptr = new_n -> slots [ slot ] )  164
if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) )  167
pr_devel ( "excise node %p with 1 shortcut\n" , new_n ); 169
new_s = assoc_array_ptr_to_shortcut ( ptr ); 170
new_parent = new_n -> back_pointer; 171
slot = new_n -> parent_slot; 172
kfree ( new_n ); 173
if ( ! new_parent )  174
new_s -> back_pointer = NULL; 175
new_s -> parent_slot = 0; 176
new_root = ptr; 177
if ( assoc_array_ptr_is_shortcut ( new_parent ) )  181
struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; 183
new_parent = new_s -> back_pointer = s -> back_pointer; 188
slot = new_s -> parent_slot = s -> parent_slot; 189
kfree ( s ); 190
if ( ! new_parent )  191
new_s -> back_pointer = NULL; 192
new_s -> parent_slot = 0; 193
new_root = ptr; 194
new_s -> back_pointer = new_parent; 199
new_s -> parent_slot = slot; 200
new_n = assoc_array_ptr_to_node ( new_parent ); 201
new_n -> slots [ slot ] = ptr; 202
ptr = new_n -> back_pointer; 210
if ( ! ptr )  211
if ( assoc_array_ptr_is_shortcut ( ptr ) )  214
new_s = assoc_array_ptr_to_shortcut ( ptr ); 215
new_parent = new_s -> back_pointer; 216
slot = new_s -> parent_slot; 217
if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT )  219
struct assoc_array_node * n ; 220
new_n -> back_pointer = new_parent; 223
new_n -> parent_slot = slot; 224
kfree ( new_s ); 225
if ( ! new_parent )  226
new_root = assoc_array_node_to_ptr ( new_n ); 227
n = assoc_array_ptr_to_node ( new_parent ); 231
n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ); 232
new_parent = ptr; 235
new_n = assoc_array_ptr_to_node ( new_parent ); 237
ptr = node -> back_pointer; 240
if ( assoc_array_ptr_is_shortcut ( ptr ) )  241
shortcut = assoc_array_ptr_to_shortcut ( ptr ); 242
slot = shortcut -> parent_slot; 243
cursor = shortcut -> back_pointer; 244
if ( ! cursor )  245
slot = node -> parent_slot; 248
cursor = ptr; 249
BUG_ON ( ! cursor ); 251
node = assoc_array_ptr_to_node ( cursor ); 252
slot ++; 253
edit -> set [ 0 ] . to = new_root; 257
assoc_array_apply_edit ( edit ); 258
edit -> array -> nr_leaves_on_tree = nr_leaves_on_tree; 259
------------------------------
475 /home/speedy/test/source2slice/NVD/CVE_2014_3631_VULN_assoc_array_gc.c memcpy 45
int CVE_2014_3631_VULN_assoc_array_gc(struct assoc_array *array,
const struct assoc_array_ops *ops,
bool (*iterator)(void *object, void *iterator_data),
void *iterator_data) 4
struct assoc_array_shortcut * shortcut , * new_s ; 6
struct assoc_array_node * node , * new_n ; 7
struct assoc_array_edit * edit ; 8
struct assoc_array_ptr * cursor , * ptr ; 9
struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; 10
int keylen , slot , nr_free , next_slot , i ; 12
if ( ! array -> root )  16
edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ); 19
if ( ! edit )  20
new_root = new_parent = NULL; 28
new_ptr_pp = & new_root; 29
cursor = array -> root; 30
if ( assoc_array_ptr_is_shortcut ( cursor ) )  36
shortcut = assoc_array_ptr_to_shortcut ( cursor ); 37
keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ); 38
keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; 39
new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ); 40
if ( ! new_s )  42
pr_devel ( "dup shortcut %p -> %p\n" , shortcut , new_s ); 44
memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ); 45
new_s -> back_pointer = new_parent; 47
new_s -> parent_slot = shortcut -> parent_slot; 48
* new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ); 49
new_ptr_pp = & new_s -> next_node; 50
cursor = shortcut -> next_node; 51
node = assoc_array_ptr_to_node ( cursor ); 55
new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ); 56
if ( ! new_n )  57
pr_devel ( "dup node %p -> %p\n" , node , new_n ); 59
new_n -> back_pointer = new_parent; 60
new_n -> parent_slot = node -> parent_slot; 61
* new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ); 62
slot = 0; 64
for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) 68
ptr = node -> slots [ slot ]; 69
if ( ! ptr )  70
if ( assoc_array_ptr_is_leaf ( ptr ) )  73
if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) )  74
new_n -> slots [ slot ] = ptr; 79
new_ptr_pp = & new_n -> slots [ slot ]; 83
cursor = ptr; 84
pr_devel ( "-- compress node %p --\n" , new_n ); 88
new_n -> nr_leaves_on_branch = 0; 93
nr_free = 0; 94
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 95
ptr = new_n -> slots [ slot ]; 96
if ( ! ptr )  97
nr_free ++; 98
if ( assoc_array_ptr_is_leaf ( ptr ) )  99
new_n -> nr_leaves_on_branch ++; 100
pr_devel ( "free=%d, leaves=%lu\n" , nr_free , new_n -> nr_leaves_on_branch ); 102
next_slot = 0; 105
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 106
struct assoc_array_shortcut * s ; 107
struct assoc_array_node * child ; 108
ptr = new_n -> slots [ slot ]; 110
if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) )  111
s = NULL; 114
if ( assoc_array_ptr_is_shortcut ( ptr ) )  115
s = assoc_array_ptr_to_shortcut ( ptr ); 116
ptr = s -> next_node; 117
child = assoc_array_ptr_to_node ( ptr ); 120
new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch; 121
if ( child -> nr_leaves_on_branch <= nr_free + 1 )  123
pr_devel ( "[%d] fold node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 125
BUG_ON ( s ); 132
new_n -> slots [ slot ] = NULL; 134
nr_free ++; 135
if ( slot < next_slot )  136
next_slot = slot; 137
for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) 138
struct assoc_array_ptr * p = child -> slots [ i ] ; 139
if ( ! p )  140
BUG_ON ( assoc_array_ptr_is_meta ( p ) ); 142
while ( new_n -> slots [ next_slot ] )  143
next_slot ++; 144
BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ); 145
new_n -> slots [ next_slot ++ ] = p; 146
nr_free --; 147
kfree ( child ); 149
pr_devel ( "[%d] retain node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 151
pr_devel ( "after: %lu\n" , new_n -> nr_leaves_on_branch ); 157
nr_leaves_on_tree = new_n -> nr_leaves_on_branch; 159
if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 )  162
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 163
if ( ptr = new_n -> slots [ slot ] )  164
if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) )  167
pr_devel ( "excise node %p with 1 shortcut\n" , new_n ); 169
new_s = assoc_array_ptr_to_shortcut ( ptr ); 170
new_parent = new_n -> back_pointer; 171
slot = new_n -> parent_slot; 172
kfree ( new_n ); 173
if ( ! new_parent )  174
new_s -> back_pointer = NULL; 175
new_s -> parent_slot = 0; 176
new_root = ptr; 177
if ( assoc_array_ptr_is_shortcut ( new_parent ) )  181
struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; 183
new_parent = new_s -> back_pointer = s -> back_pointer; 188
slot = new_s -> parent_slot = s -> parent_slot; 189
kfree ( s ); 190
if ( ! new_parent )  191
new_s -> back_pointer = NULL; 192
new_s -> parent_slot = 0; 193
new_root = ptr; 194
new_s -> back_pointer = new_parent; 199
new_s -> parent_slot = slot; 200
new_n = assoc_array_ptr_to_node ( new_parent ); 201
new_n -> slots [ slot ] = ptr; 202
ptr = new_n -> back_pointer; 210
if ( ! ptr )  211
if ( assoc_array_ptr_is_shortcut ( ptr ) )  214
new_s = assoc_array_ptr_to_shortcut ( ptr ); 215
new_parent = new_s -> back_pointer; 216
slot = new_s -> parent_slot; 217
if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT )  219
struct assoc_array_node * n ; 220
new_n -> back_pointer = new_parent; 223
new_n -> parent_slot = slot; 224
kfree ( new_s ); 225
if ( ! new_parent )  226
new_root = assoc_array_node_to_ptr ( new_n ); 227
n = assoc_array_ptr_to_node ( new_parent ); 231
n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ); 232
new_parent = ptr; 235
new_n = assoc_array_ptr_to_node ( new_parent ); 237
ptr = node -> back_pointer; 240
if ( assoc_array_ptr_is_shortcut ( ptr ) )  241
shortcut = assoc_array_ptr_to_shortcut ( ptr ); 242
slot = shortcut -> parent_slot; 243
cursor = shortcut -> back_pointer; 244
slot = node -> parent_slot; 246
cursor = ptr; 247
BUG_ON ( ! ptr ); 249
node = assoc_array_ptr_to_node ( cursor ); 250
slot ++; 251
edit -> set [ 0 ] . to = new_root; 255
assoc_array_apply_edit ( edit ); 256
edit -> array -> nr_leaves_on_tree = nr_leaves_on_tree; 257
assoc_array_destroy_subtree ( new_root , edit -> ops ); 262
kfree ( edit ); 263
------------------------------
476 /home/speedy/test/source2slice/NVD/CVE_2014_4174_PATCHED_libpcap_dump.c memcpy 71
static gboolean CVE_2014_4174_PATCHED_libpcap_dump(wtap_dumper *wdh,
const struct wtap_pkthdr *phdr,
const guint8 *pd, int *err) 3
const union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; 5
struct pcaprec_ss990915_hdr rec_hdr ; 6
int phdrsize ; 8
phdrsize = pcap_get_phdr_size ( wdh -> encap , pseudo_header ); 10
rec_hdr . hdr . ts_sec = ( guint32 ) phdr -> ts . secs; 12
if ( wdh -> tsprecision == WTAP_FILE_TSPREC_NSEC )  13
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs; 14
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs / 1000; 16
rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize; 18
rec_hdr . hdr . orig_len = phdr -> len + phdrsize; 19
if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE )  21
switch ( wdh -> file_type )  26
rec_hdr . ifindex = 0; 54
rec_hdr . protocol = 0; 55
rec_hdr . pkt_type = 0; 56
rec_hdr . ifindex = 0; 61
rec_hdr . protocol = 0; 62
rec_hdr . pkt_type = 0; 63
rec_hdr . cpu1 = 0; 64
rec_hdr . cpu2 = 0; 65
memcpy ( & rec_hdr . ifindex , pseudo_header -> nokia . stuff , 4 ); 71
rec_hdr . protocol = 0; 73
rec_hdr . pkt_type = 0; 74
rec_hdr . cpu1 = 0; 75
rec_hdr . cpu2 = 0; 76
if ( ! wtap_dump_file_write ( wdh , & rec_hdr , hdr_size , err ) )  88
------------------------------
477 /home/speedy/test/source2slice/NVD/CVE_2014_4174_VULN_libpcap_dump.c memcpy 71
static gboolean CVE_2014_4174_VULN_libpcap_dump(wtap_dumper *wdh,
const struct wtap_pkthdr *phdr,
const guint8 *pd, int *err) 3
const union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; 5
struct pcaprec_ss990915_hdr rec_hdr ; 6
int phdrsize ; 8
phdrsize = pcap_get_phdr_size ( wdh -> encap , pseudo_header ); 10
rec_hdr . hdr . ts_sec = ( guint32 ) phdr -> ts . secs; 12
if ( wdh -> tsprecision == WTAP_FILE_TSPREC_NSEC )  13
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs; 14
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs / 1000; 16
rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize; 18
rec_hdr . hdr . orig_len = phdr -> len + phdrsize; 19
if ( rec_hdr . hdr . incl_len > WTAP_MAX_PACKET_SIZE || rec_hdr . hdr . orig_len > WTAP_MAX_PACKET_SIZE )  21
switch ( wdh -> file_type )  26
rec_hdr . ifindex = 0; 54
rec_hdr . protocol = 0; 55
rec_hdr . pkt_type = 0; 56
rec_hdr . ifindex = 0; 61
rec_hdr . protocol = 0; 62
rec_hdr . pkt_type = 0; 63
rec_hdr . cpu1 = 0; 64
rec_hdr . cpu2 = 0; 65
memcpy ( & rec_hdr . ifindex , pseudo_header -> nokia . stuff , 4 ); 71
rec_hdr . protocol = 0; 73
rec_hdr . pkt_type = 0; 74
rec_hdr . cpu1 = 0; 75
rec_hdr . cpu2 = 0; 76
if ( ! wtap_dump_file_write ( wdh , & rec_hdr , hdr_size , err ) )  88
------------------------------
478 /home/speedy/test/source2slice/NVD/CVE_2014_4654_PATCHED_snd_ctl_elem_add.c memcpy 29
static int CVE_2014_4654_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( info -> count < 1 )  11
info -> id . numid = 0; 17
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
if ( replace )  20
err = snd_ctl_remove_user_ctl ( file , & info -> id ); 21
if ( err )  22
if ( card -> user_ctl_count >= MAX_USER_CONTROLS )  26
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
------------------------------
479 /home/speedy/test/source2slice/NVD/CVE_2014_4654_VULN_snd_ctl_elem_add.c memcpy 36
static int CVE_2014_4654_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
480 /home/speedy/test/source2slice/NVD/CVE_2014_4655_PATCHED_snd_ctl_elem_add.c memcpy 29
static int CVE_2014_4655_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( info -> count < 1 )  11
info -> id . numid = 0; 17
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
if ( replace )  20
err = snd_ctl_remove_user_ctl ( file , & info -> id ); 21
if ( err )  22
if ( card -> user_ctl_count >= MAX_USER_CONTROLS )  26
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
------------------------------
481 /home/speedy/test/source2slice/NVD/CVE_2014_4655_VULN_snd_ctl_elem_add.c memcpy 36
static int CVE_2014_4655_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
482 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memcpy 111
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
if ( s -> ham )  108
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
buf += avctx -> width + ( avctx -> width & 1 ); 112
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
------------------------------
483 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memcpy 105
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 104
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
buf += avctx -> width + ( avctx -> width % 2 ); 106
------------------------------
484 /home/speedy/test/source2slice/NVD/CVE_2014_5272_PATCHED_decode_frame.c memcpy 64
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; 59
int raw_width = avctx -> width * ( av_get_bits_per_pixel ( desc ) >> 3 ) ; 60
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 63
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
buf += raw_width; 65
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
------------------------------
485 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memcpy 111
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
if ( s -> ham )  108
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
buf += avctx -> width + ( avctx -> width & 1 ); 112
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
------------------------------
486 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memcpy 105
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 104
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
buf += avctx -> width + ( avctx -> width % 2 ); 106
------------------------------
487 /home/speedy/test/source2slice/NVD/CVE_2014_5272_VULN_decode_frame.c memcpy 64
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) 1
int ret = get_buffer_internal ( avctx , frame , flags ) ; 3
return ret ; 6
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; 59
int raw_width = avctx -> width * ( av_get_bits_per_pixel ( desc ) >> 3 ) ; 60
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 63
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
buf += raw_width; 65
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
------------------------------
488 /home/speedy/test/source2slice/NVD/CVE_2014_5471_PATCHED_isofs_read_inode.c memcpy 40
static int CVE_2014_5471_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
bh = sb_bread ( inode -> i_sb , ++ block ); 37
if ( ! bh )  38
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
------------------------------
489 /home/speedy/test/source2slice/NVD/CVE_2014_5471_PATCHED_isofs_read_inode.c memcpy 35
static int CVE_2014_5471_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
de = tmpde; 41
if ( de -> flags [ - high_sierra ] & 2 )  51
ei -> i_section_size = isonum_733 ( de -> size ); 84
if ( de -> flags [ - high_sierra ] & 0x80 )  85
ei -> i_next_section_block = 0; 91
ei -> i_next_section_offset = 0; 92
inode -> i_size = isonum_733 ( de -> size ); 93
inode -> i_size &= 0x00ffffff; 103
if ( de -> interleave [ 0 ] )  105
inode -> i_size = 0; 107
if ( de -> file_unit_size [ 0 ] != 0 )  112
printk ( KERN_DEBUG "ISOFS: File unit size != 0 for ISO file (%ld).\n" ,
inode -> i_ino ) 114
if ( ( de -> flags [ - high_sierra ] & ~2 ) != 0 )  120
printk ( KERN_DEBUG "ISOFS: Unusual flag settings for ISO file "
"(%ld %x).\n" ,
inode -> i_ino , de -> flags [ - high_sierra ] ) 123
inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ); 127
inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0; 130
ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ); 134
inode -> i_blocks = ( inode -> i_size + 511 ) >> 9; 138
parse_rock_ridge_inode ( de , inode , relocated ); 146
inode -> i_uid = sbi -> s_uid; 149
inode -> i_gid = sbi -> s_gid; 151
if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE )  154
inode -> i_mode = S_IFDIR | sbi -> s_dmode; 156
if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE )  157
inode -> i_mode = S_IFREG | sbi -> s_fmode; 159
if ( S_ISREG ( inode -> i_mode ) )  162
inode -> i_fop = & generic_ro_fops; 163
switch ( ei -> i_file_format )  164
inode -> i_data . a_ops = & zisofs_aops; 167
inode -> i_data . a_ops = & isofs_aops; 171
if ( S_ISDIR ( inode -> i_mode ) )  174
if ( S_ISLNK ( inode -> i_mode ) )  177
init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ); 182
kfree ( tmpde ); 186
------------------------------
490 /home/speedy/test/source2slice/NVD/CVE_2014_5471_VULN_isofs_read_inode.c memcpy 40
static int CVE_2014_5471_VULN_isofs_read_inode(struct inode *inode) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
bh = sb_bread ( inode -> i_sb , ++ block ); 37
if ( ! bh )  38
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
------------------------------
491 /home/speedy/test/source2slice/NVD/CVE_2014_5471_VULN_isofs_read_inode.c memcpy 35
static int CVE_2014_5471_VULN_isofs_read_inode(struct inode *inode) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
------------------------------
492 /home/speedy/test/source2slice/NVD/CVE_2014_5472_PATCHED_isofs_read_inode.c memcpy 40
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
bh = sb_bread ( inode -> i_sb , ++ block ); 37
if ( ! bh )  38
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
------------------------------
493 /home/speedy/test/source2slice/NVD/CVE_2014_5472_PATCHED_isofs_read_inode.c memcpy 35
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
------------------------------
494 /home/speedy/test/source2slice/NVD/CVE_2014_5472_VULN_isofs_read_inode.c memcpy 40
static int CVE_2014_5472_VULN_isofs_read_inode(struct inode *inode) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
bh = sb_bread ( inode -> i_sb , ++ block ); 37
if ( ! bh )  38
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
------------------------------
495 /home/speedy/test/source2slice/NVD/CVE_2014_5472_VULN_isofs_read_inode.c memcpy 35
static int CVE_2014_5472_VULN_isofs_read_inode(struct inode *inode) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
de = tmpde; 41
if ( de -> flags [ - high_sierra ] & 2 )  51
ei -> i_section_size = isonum_733 ( de -> size ); 84
if ( de -> flags [ - high_sierra ] & 0x80 )  85
ei -> i_next_section_block = 0; 91
ei -> i_next_section_offset = 0; 92
inode -> i_size = isonum_733 ( de -> size ); 93
inode -> i_size &= 0x00ffffff; 103
if ( de -> interleave [ 0 ] )  105
inode -> i_size = 0; 107
if ( de -> file_unit_size [ 0 ] != 0 )  112
printk ( KERN_DEBUG "ISOFS: File unit size != 0 for ISO file (%ld).\n" ,
inode -> i_ino ) 114
if ( ( de -> flags [ - high_sierra ] & ~2 ) != 0 )  120
printk ( KERN_DEBUG "ISOFS: Unusual flag settings for ISO file "
"(%ld %x).\n" ,
inode -> i_ino , de -> flags [ - high_sierra ] ) 123
inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ); 127
inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0; 130
ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ); 134
inode -> i_blocks = ( inode -> i_size + 511 ) >> 9; 138
parse_rock_ridge_inode ( de , inode ); 146
inode -> i_uid = sbi -> s_uid; 149
inode -> i_gid = sbi -> s_gid; 151
if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE )  154
inode -> i_mode = S_IFDIR | sbi -> s_dmode; 156
if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE )  157
inode -> i_mode = S_IFREG | sbi -> s_fmode; 159
if ( S_ISREG ( inode -> i_mode ) )  162
inode -> i_fop = & generic_ro_fops; 163
switch ( ei -> i_file_format )  164
inode -> i_data . a_ops = & zisofs_aops; 167
inode -> i_data . a_ops = & isofs_aops; 171
if ( S_ISDIR ( inode -> i_mode ) )  174
if ( S_ISLNK ( inode -> i_mode ) )  177
init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ); 182
kfree ( tmpde ); 186
------------------------------
496 /home/speedy/test/source2slice/NVD/CVE_2015_2922_PATCHED_ndisc_router_discovery.c memcpy 260
static void CVE_2015_2922_PATCHED_ndisc_router_discovery(struct sk_buff *skb) 1
struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; 3
struct neighbour * neigh = NULL ; 4
struct inet6_dev * in6_dev ; 5
int lifetime ; 7
struct ndisc_options ndopts ; 8
int optlen ; 9
__u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; 12
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) )  16
if ( optlen < 0 )  20
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST )  26
in6_dev = __in6_dev_get ( skb -> dev ); 36
if ( in6_dev == NULL )  37
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
if ( ! accept_ra ( in6_dev ) )  48
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  53
if ( in6_dev -> if_flags & IF_RS_SENT )  57
in6_dev -> if_flags |= IF_RA_RCVD; 62
in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ); 69
if ( ! in6_dev -> cnf . accept_ra_defrtr )  76
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  79
lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ); 82
pref = ra_msg -> icmph . icmp6_router_pref; 85
if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref )  87
pref = ICMPV6_ROUTER_PREF_MEDIUM; 89
rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ); 92
if ( rt )  94
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 95
if ( ! neigh )  96
if ( rt && lifetime == 0 )  104
rt = NULL; 106
if ( rt == NULL && lifetime )  109
rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ); 112
if ( rt == NULL )  113
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 120
if ( neigh == NULL )  121
neigh -> flags |= NTF_ROUTER; 128
if ( ra_msg -> icmph . icmp6_hop_limit )  135
if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit )  139
in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit; 140
if ( in6_dev -> nd_parms )  155
unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; 156
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ )  158
rtime = ( rtime * HZ ) / 1000; 159
if ( rtime < HZ / 10 )  160
rtime = HZ / 10; 161
in6_dev -> nd_parms -> retrans_time = rtime; 162
in6_dev -> tstamp = jiffies; 163
rtime = ntohl ( ra_msg -> reachable_time ); 167
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) )  168
rtime = ( rtime * HZ ) / 1000; 169
if ( rtime < HZ / 10 )  171
rtime = HZ / 10; 172
if ( rtime != in6_dev -> nd_parms -> base_reachable_time )  174
in6_dev -> nd_parms -> base_reachable_time = rtime; 175
in6_dev -> nd_parms -> gc_staletime = 3 * rtime; 176
in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ); 177
in6_dev -> tstamp = jiffies; 178
if ( ! neigh )  190
neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ); 191
if ( neigh )  193
if ( ndopts . nd_opts_src_lladdr )  195
lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ); 196
if ( ! lladdr )  198
if ( ! accept_ra ( in6_dev ) )  211
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  241
if ( ndopts . nd_opts_mtu )  256
__be32 n ; 257
memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ); 260
mtu = ntohl ( n ); 261
if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu )  263
ND_PRINTK ( 2 , warn , "RA: invalid mtu: %d\n" , mtu ); 264
if ( in6_dev -> cnf . mtu6 != mtu )  265
in6_dev -> cnf . mtu6 = mtu; 266
dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ); 269
rt6_mtu_change ( skb -> dev , mtu ); 271
------------------------------
497 /home/speedy/test/source2slice/NVD/CVE_2015_2922_VULN_ndisc_router_discovery.c memcpy 253
static void CVE_2015_2922_VULN_ndisc_router_discovery(struct sk_buff *skb) 1
struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; 3
struct neighbour * neigh = NULL ; 4
struct inet6_dev * in6_dev ; 5
int lifetime ; 7
struct ndisc_options ndopts ; 8
int optlen ; 9
__u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; 12
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) )  16
if ( optlen < 0 )  20
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST )  26
in6_dev = __in6_dev_get ( skb -> dev ); 36
if ( in6_dev == NULL )  37
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
if ( ! accept_ra ( in6_dev ) )  48
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  53
if ( in6_dev -> if_flags & IF_RS_SENT )  57
in6_dev -> if_flags |= IF_RA_RCVD; 62
in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ); 69
if ( ! in6_dev -> cnf . accept_ra_defrtr )  76
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  79
lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ); 82
pref = ra_msg -> icmph . icmp6_router_pref; 85
if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref )  87
pref = ICMPV6_ROUTER_PREF_MEDIUM; 89
rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ); 92
if ( rt )  94
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 95
if ( ! neigh )  96
if ( rt && lifetime == 0 )  104
rt = NULL; 106
if ( rt == NULL && lifetime )  109
rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ); 112
if ( rt == NULL )  113
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 120
if ( neigh == NULL )  121
neigh -> flags |= NTF_ROUTER; 128
if ( ra_msg -> icmph . icmp6_hop_limit )  135
in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit; 136
if ( in6_dev -> nd_parms )  148
unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; 149
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ )  151
rtime = ( rtime * HZ ) / 1000; 152
if ( rtime < HZ / 10 )  153
rtime = HZ / 10; 154
in6_dev -> nd_parms -> retrans_time = rtime; 155
in6_dev -> tstamp = jiffies; 156
rtime = ntohl ( ra_msg -> reachable_time ); 160
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) )  161
rtime = ( rtime * HZ ) / 1000; 162
if ( rtime < HZ / 10 )  164
rtime = HZ / 10; 165
if ( rtime != in6_dev -> nd_parms -> base_reachable_time )  167
in6_dev -> nd_parms -> base_reachable_time = rtime; 168
in6_dev -> nd_parms -> gc_staletime = 3 * rtime; 169
in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ); 170
in6_dev -> tstamp = jiffies; 171
if ( ! neigh )  183
neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ); 184
if ( neigh )  186
if ( ndopts . nd_opts_src_lladdr )  188
lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ); 189
if ( ! lladdr )  191
if ( ! accept_ra ( in6_dev ) )  204
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  234
if ( ndopts . nd_opts_mtu )  249
__be32 n ; 250
memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ); 253
mtu = ntohl ( n ); 254
if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu )  256
ND_PRINTK ( 2 , warn , "RA: invalid mtu: %d\n" , mtu ); 257
if ( in6_dev -> cnf . mtu6 != mtu )  258
in6_dev -> cnf . mtu6 = mtu; 259
dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ); 262
rt6_mtu_change ( skb -> dev , mtu ); 264
------------------------------
498 /home/speedy/test/source2slice/NVD/CVE_2015_3811_PATCHED_wcp_uncompress.c memcpy 195
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int len , i ; 8
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 * dst , * src , * buf_start , * buf_end , comp_flag_bits = 0 ; 11
guint16 data_offset , data_cnt ; 12
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
wcp_pdata_t * pdata_ptr ; 16
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
dst = buf_ptr -> buf_cur; 41
len = 0; 42
i = - 1; 43
while ( offset < cnt )  45
if ( -- i >= 0 )  47
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
src += 3; 87
offset += 3; 88
data_cnt = ( * src >> 4 ) + 1; 96
src += 2; 106
offset += 2; 107
if ( data_offset + 1 > buf_ptr -> initialized )  109
if ( data_offset + 1 < data_cnt )  116
if ( ! pinfo -> fd -> flags . visited )  122
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
if ( ++ len > MAX_WCP_BUF_LEN )  139
if ( ! pinfo -> fd -> flags . visited )  147
* dst = * src; 153
if ( dst ++ == buf_end )  154
dst = buf_start; 155
if ( buf_ptr -> initialized < MAX_WIN_BUF_LEN )  156
buf_ptr -> initialized ++; 157
comp_flag_bits <<= 1; 164
comp_flag_bits = * src ++; 172
offset ++; 176
i = 8; 178
if ( pinfo -> fd -> flags . visited )  182
pdata_ptr = wmem_new ( wmem_file_scope ( ) , wcp_pdata_t ); 194
memcpy ( & pdata_ptr -> buffer , buf_ptr -> buf_cur , len ); 195
pdata_ptr -> len = len; 196
p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_wcp , 0 , ( void * ) pdata_ptr ); 198
tvb = tvb_new_child_real_data ( src_tvb , pdata_ptr -> buffer , pdata_ptr -> len , pdata_ptr -> len ); 203
add_new_data_source ( pinfo , tvb , "Uncompressed WCP" ); 206
return tvb ; 207
------------------------------
499 /home/speedy/test/source2slice/NVD/CVE_2015_3811_VULN_wcp_uncompress.c memcpy 180
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int len , i ; 8
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 * dst , * src , * buf_start , * buf_end , comp_flag_bits = 0 ; 11
guint16 data_offset , data_cnt ; 12
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
wcp_pdata_t * pdata_ptr ; 16
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
dst = buf_ptr -> buf_cur; 41
len = 0; 42
i = - 1; 43
while ( offset < cnt )  45
if ( -- i >= 0 )  47
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
src += 3; 87
offset += 3; 88
data_cnt = ( * src >> 4 ) + 1; 96
src += 2; 106
offset += 2; 107
if ( ! pinfo -> fd -> flags . visited )  109
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
if ( ++ len > MAX_WCP_BUF_LEN )  126
if ( ! pinfo -> fd -> flags . visited )  134
* dst = * src; 140
if ( dst ++ == buf_end )  141
dst = buf_start; 142
comp_flag_bits <<= 1; 149
comp_flag_bits = * src ++; 157
offset ++; 161
i = 8; 163
if ( pinfo -> fd -> flags . visited )  167
pdata_ptr = wmem_new ( wmem_file_scope ( ) , wcp_pdata_t ); 179
memcpy ( & pdata_ptr -> buffer , buf_ptr -> buf_cur , len ); 180
pdata_ptr -> len = len; 181
p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_wcp , 0 , ( void * ) pdata_ptr ); 183
tvb = tvb_new_child_real_data ( src_tvb , pdata_ptr -> buffer , pdata_ptr -> len , pdata_ptr -> len ); 188
add_new_data_source ( pinfo , tvb , "Uncompressed WCP" ); 191
return tvb ; 192
------------------------------
500 /home/speedy/test/source2slice/NVD/CVE_2015_3813_PATCHED_fragment_add_work.c memcpy 306
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
------------------------------
501 /home/speedy/test/source2slice/NVD/CVE_2015_3813_VULN_fragment_add_work.c memcpy 304
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
------------------------------
502 /home/speedy/test/source2slice/NVD/CVE_2015_4001_PATCHED_oz_hcd_get_desc_cnf.c memcpy 22
void CVE_2015_4001_PATCHED_oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,
u8 length, u16 offset, u16 total_size) 2
struct oz_port * port = hport ; 4
struct urb * urb ; 5
urb = oz_find_urb_by_id ( port , 0 , req_id ); 10
if ( ! urb )  11
if ( status == 0 )  13
unsigned int copy_len ; 14
unsigned int required_size = urb -> transfer_buffer_length ; 15
if ( required_size > total_size )  17
required_size = total_size; 18
copy_len = required_size - offset; 19
if ( length <= copy_len )  20
copy_len = length; 21
memcpy ( urb -> transfer_buffer + offset , desc , copy_len ); 22
struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; 25
unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; 27
if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) )  29
if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) )  31
oz_dequeue_ep_urb ( port , 0 , 0 , urb ); 35
urb -> actual_length = total_size; 42
oz_complete_urb ( port -> ozhcd -> hcd , urb , 0 ); 43
------------------------------
503 /home/speedy/test/source2slice/NVD/CVE_2015_4001_VULN_oz_hcd_get_desc_cnf.c memcpy 22
void CVE_2015_4001_VULN_oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,
int length, int offset, int total_size) 2
struct oz_port * port = hport ; 4
struct urb * urb ; 5
urb = oz_find_urb_by_id ( port , 0 , req_id ); 10
if ( ! urb )  11
if ( status == 0 )  13
int copy_len ; 14
int required_size = urb -> transfer_buffer_length ; 15
if ( required_size > total_size )  17
required_size = total_size; 18
copy_len = required_size - offset; 19
if ( length <= copy_len )  20
copy_len = length; 21
memcpy ( urb -> transfer_buffer + offset , desc , copy_len ); 22
struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; 25
unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; 27
if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) )  29
if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) )  31
oz_dequeue_ep_urb ( port , 0 , 0 , urb ); 35
------------------------------
504 /home/speedy/test/source2slice/NVD/CVE_2010_2431_PATCHED_cupsFileOpen.c close 98
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_PATCHED_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
cups_file_t * fp ; 7
int fd ; 8
char hostname [ 1024 ] , * portname ; 9
http_addrlist_t * addrlist ; 11
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = cups_open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY ); 33
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 38
fd = cups_open ( filename , O_WRONLY | O_LARGEFILE | O_BINARY ); 42
if ( fd < 0 && errno == ENOENT )  43
fd = cups_open ( filename , O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE | O_BINARY ); 45
if ( fd < 0 && errno == EEXIST )  47
fd = cups_open ( filename , O_WRONLY | O_LARGEFILE | O_BINARY ); 48
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  57
* portname ++ = '\0'; 58
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  66
if ( ! httpAddrConnect ( addrlist , & fd ) )  73
if ( fd < 0 )  86
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  93
if ( * mode == 's' )  95
close ( fd ); 98
------------------------------
505 /home/speedy/test/source2slice/NVD/CVE_2010_2431_VULN_cupsFileOpen.c close 87
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
cups_file_t * fp ; 7
int fd ; 8
char hostname [ 1024 ] , * portname ; 9
http_addrlist_t * addrlist ; 11
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ); 33
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 37
fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ); 41
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
if ( * mode == 's' )  84
close ( fd ); 87
------------------------------
506 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strchr 411
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
char * p ; 245
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  400
if ( arg )  404
char * p ; 406
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  407
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 409
if ( strlen ( iocts . drvid ) )  410
if ( p = strchr ( iocts . drvid , ',' ) )  411
* p = 0; 412
------------------------------
507 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strchr 251
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
------------------------------
508 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strchr 408
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
char * p ; 245
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  398
if ( arg )  402
char * p ; 404
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  405
if ( strlen ( iocts . drvid ) )  407
if ( p = strchr ( iocts . drvid , ',' ) )  408
* p = 0; 409
------------------------------
509 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strchr 250
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  243
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  353
get_user ( bname [ j ] , p ++ ); 355
------------------------------
510 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c strchr 36
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
------------------------------
511 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c strchr 33
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
------------------------------
512 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c strchr 36
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
------------------------------
513 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c strchr 33
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
------------------------------
514 /home/speedy/test/source2slice/NVD/CVE_2010_1224_PATCHED_ast_append_ha.c strchr 29
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
------------------------------
515 /home/speedy/test/source2slice/NVD/CVE_2010_1224_PATCHED_ast_append_ha.c strchr 20
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
if ( ! inet_aton ( nm , & ha -> netmask ) )  46
------------------------------
516 /home/speedy/test/source2slice/NVD/CVE_2010_1224_VULN_ast_append_ha.c strchr 29
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
------------------------------
517 /home/speedy/test/source2slice/NVD/CVE_2010_1224_VULN_ast_append_ha.c strchr 20
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
if ( ! inet_aton ( nm , & ha -> netmask ) )  39
------------------------------
518 /home/speedy/test/source2slice/NVD/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strchr 36
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
char * p2 ; 9
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
------------------------------
519 /home/speedy/test/source2slice/NVD/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strchr 32
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
------------------------------
520 /home/speedy/test/source2slice/NVD/CVE_2013_6378_VULN_lbs_debugfs_write.c strchr 32
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
char * p2 ; 9
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
------------------------------
521 /home/speedy/test/source2slice/NVD/CVE_2013_6378_VULN_lbs_debugfs_write.c strchr 28
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
------------------------------
522 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strchr 143
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = lstat ( filename , filestats ); 81
if ( ! status && S_ISLNK ( filestats -> st_mode ) )  89
if ( ! status && ! ( filestats -> st_mode & S_IROTH ) )  100
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  110
if ( status && language [ 0 ] )  125
if ( language [ 3 ] )  131
language [ 0 ] = '\0'; 132
language [ 0 ] = '\0'; 134
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 141
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  143
* ptr = '\0'; 144
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
status = stat ( filename , filestats ); 150
if ( status )  153
strlcpy ( ptr , "index.class" , plen ); 155
status = stat ( filename , filestats ); 156
if ( status )  161
strlcpy ( ptr , "index.pl" , plen ); 163
status = stat ( filename , filestats ); 164
if ( status )  169
strlcpy ( ptr , "index.php" , plen ); 171
status = stat ( filename , filestats ); 172
if ( status )  177
strlcpy ( ptr , "index.pyc" , plen ); 179
status = stat ( filename , filestats ); 180
if ( status )  183
strlcpy ( ptr , "index.py" , plen ); 185
status = stat ( filename , filestats ); 186
while ( status && language [ 0 ] )  191
------------------------------
523 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strchr 78
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = lstat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
* ptr = '\0'; 144
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
strlcpy ( ptr , "index.class" , plen ); 155
strlcpy ( ptr , "index.pl" , plen ); 163
strlcpy ( ptr , "index.php" , plen ); 171
strlcpy ( ptr , "index.pyc" , plen ); 179
strlcpy ( ptr , "index.py" , plen ); 185
------------------------------
524 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strchr 66
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
* ptr = '\0'; 79
* ptr = '\0'; 144
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
strlcpy ( ptr , "index.class" , plen ); 155
strlcpy ( ptr , "index.pl" , plen ); 163
strlcpy ( ptr , "index.php" , plen ); 171
strlcpy ( ptr , "index.pyc" , plen ); 179
strlcpy ( ptr , "index.py" , plen ); 185
------------------------------
525 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strchr 46
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char * ptr ; 10
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  46
* ptr = '\0'; 47
* ptr = '\0'; 67
* ptr = '\0'; 79
* ptr = '\0'; 144
plen = len - ( ptr - filename ); 147
strlcpy ( ptr , "index.html" , plen ); 149
strlcpy ( ptr , "index.class" , plen ); 155
strlcpy ( ptr , "index.pl" , plen ); 163
strlcpy ( ptr , "index.php" , plen ); 171
strlcpy ( ptr , "index.pyc" , plen ); 179
strlcpy ( ptr , "index.py" , plen ); 185
------------------------------
526 /home/speedy/test/source2slice/NVD/CVE_2014_3537_PATCHED_get_file.c strchr 23
static char *				/* O  - Real filename */
CVE_2014_3537_PATCHED_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
------------------------------
527 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strchr 122
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
language [ 0 ] = '\0'; 75
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
status = stat ( filename , filestats ); 81
if ( ! status && S_ISDIR ( filestats -> st_mode ) )  89
if ( status && language [ 0 ] )  104
if ( language [ 3 ] )  110
language [ 0 ] = '\0'; 111
language [ 0 ] = '\0'; 113
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 120
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  122
* ptr = '\0'; 123
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
status = stat ( filename , filestats ); 129
if ( status )  132
strlcpy ( ptr , "index.class" , plen ); 134
status = stat ( filename , filestats ); 135
if ( status )  140
strlcpy ( ptr , "index.pl" , plen ); 142
status = stat ( filename , filestats ); 143
if ( status )  148
strlcpy ( ptr , "index.php" , plen ); 150
status = stat ( filename , filestats ); 151
if ( status )  156
strlcpy ( ptr , "index.pyc" , plen ); 158
status = stat ( filename , filestats ); 159
if ( status )  162
strlcpy ( ptr , "index.py" , plen ); 164
status = stat ( filename , filestats ); 165
while ( status && language [ 0 ] )  170
------------------------------
528 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strchr 78
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( status = stat ( filename , filestats ) ) != 0 )  69
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 76
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  78
* ptr = '\0'; 79
* ptr = '\0'; 123
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
strlcpy ( ptr , "index.class" , plen ); 134
strlcpy ( ptr , "index.pl" , plen ); 142
strlcpy ( ptr , "index.php" , plen ); 150
strlcpy ( ptr , "index.pyc" , plen ); 158
strlcpy ( ptr , "index.py" , plen ); 164
------------------------------
529 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strchr 66
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
int status ; 9
char * ptr ; 10
char language [ 7 ] ; 12
language [ 0 ] = '\0'; 19
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( language , sizeof ( language ) , "/%s" , con -> language -> language ); 40
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( status = stat ( filename , filestats ) ) != 0 && language [ 0 ] && strncmp ( con -> uri , "/ppd/" , 5 ) && strncmp ( con -> uri , "/admin/conf/" , 12 ) && strncmp ( con -> uri , "/admin/log/" , 11 ) )  54
language [ 3 ] = '\0'; 63
snprintf ( filename , len , "%s%s%s" , DocumentRoot , language , con -> uri ); 64
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  66
* ptr = '\0'; 67
* ptr = '\0'; 79
* ptr = '\0'; 123
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
strlcpy ( ptr , "index.class" , plen ); 134
strlcpy ( ptr , "index.pl" , plen ); 142
strlcpy ( ptr , "index.php" , plen ); 150
strlcpy ( ptr , "index.pyc" , plen ); 158
strlcpy ( ptr , "index.py" , plen ); 164
------------------------------
530 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strchr 46
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
char * ptr ; 10
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
if ( ! strncmp ( con -> uri , "/admin/conf/" , 12 ) )  25
if ( ! strncmp ( con -> uri , "/admin/log/" , 11 ) )  27
if ( ! strncmp ( con -> uri + 11 , "access_log" , 10 ) && AccessLog [ 0 ] == '/' )  29
if ( ! strncmp ( con -> uri + 11 , "error_log" , 9 ) && ErrorLog [ 0 ] == '/' )  31
if ( ! strncmp ( con -> uri + 11 , "page_log" , 8 ) && PageLog [ 0 ] == '/' )  33
if ( con -> language )  38
snprintf ( filename , len , "%s%s" , DocumentRoot , con -> uri ); 44
if ( ( ptr = strchr ( filename , '?' ) ) != NULL )  46
* ptr = '\0'; 47
* ptr = '\0'; 67
* ptr = '\0'; 79
* ptr = '\0'; 123
plen = len - ( ptr - filename ); 126
strlcpy ( ptr , "index.html" , plen ); 128
strlcpy ( ptr , "index.class" , plen ); 134
strlcpy ( ptr , "index.pl" , plen ); 142
strlcpy ( ptr , "index.php" , plen ); 150
strlcpy ( ptr , "index.pyc" , plen ); 158
strlcpy ( ptr , "index.py" , plen ); 164
------------------------------
531 /home/speedy/test/source2slice/NVD/CVE_2014_3537_VULN_get_file.c strchr 23
static char *				/* O  - Real filename */
CVE_2014_3537_VULN_get_file(cupsd_client_t *con,		/* I  - Client connection */
struct stat    *filestats,	/* O  - File information */
char           *filename,	/* IO - Filename buffer */
int            len)		/* I  - Buffer length */ 8
if ( ! strncmp ( con -> uri , "/ppd/" , 5 ) )  21
if ( ! strncmp ( con -> uri , "/rss/" , 5 ) && ! strchr ( con -> uri + 5 , '/' ) )  23
------------------------------
532 /home/speedy/test/source2slice/NVD/CVE_2015_4652_PATCHED_de_bcd_num.c strchr 50
static guint16
CVE_2015_4652_PATCHED_de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted) 2
guint8 extension ; 5
guint32 curr_offset , num_string_len ; 6
const char * digit_str ; 8
curr_offset = offset; 11
extension = tvb_get_guint8 ( tvb , curr_offset ) & 0x80; 13
curr_offset ++; 17
if ( ! extension )  19
curr_offset ++; 25
num_string_len = len - ( curr_offset - offset ); 30
digit_str = tvb_bcd_dig_to_wmem_packet_str ( tvb , curr_offset , num_string_len , NULL , FALSE ); 37
if ( strchr ( digit_str , '?' ) )  50
------------------------------
533 /home/speedy/test/source2slice/NVD/CVE_2014_1642_PATCHED_pirq_guest_bind.c xmalloc 36
int CVE_2014_1642_PATCHED_pirq_guest_bind(struct vcpu *v, struct pirq *pirq, int will_share) 1
struct irq_desc * desc ; 4
irq_guest_action_t * action , * newaction = NULL ; 5
desc = pirq_spin_lock_irq_desc ( pirq , NULL ); 12
if ( desc == NULL )  13
action = ( irq_guest_action_t * ) desc -> action; 19
if ( ! ( desc -> status & IRQ_GUEST ) )  22
if ( desc -> action != NULL )  24
if ( newaction == NULL )  33
if ( ( newaction = xmalloc ( irq_guest_action_t ) ) != NULL && zalloc_cpumask_var ( & newaction -> cpu_eoi_map ) )  36
xfree ( newaction ); 39
action = newaction; 46
desc -> action = ( struct irqaction * ) action; 47
action -> nr_guests = 0; 50
action -> in_flight = 0; 51
action -> shareable = will_share; 52
action -> ack_type = pirq_acktype ( v -> domain , pirq -> pirq ); 53
init_timer ( & action -> eoi_timer , irq_guest_eoi_timer_fn , desc , 0 ); 54
desc -> status |= IRQ_GUEST; 56
desc -> status &= ~IRQ_DISABLED; 57
desc -> handler -> startup ( desc ); 58
if ( ! opt_noirqbalance && ( desc -> handler -> set_affinity != NULL ) )  61
desc -> handler -> set_affinity ( desc , cpumask_of ( v -> processor ) ); 62
if ( ! will_share || ! action -> shareable )  64
if ( action -> nr_guests == 0 )  73
if ( action -> nr_guests == IRQ_MAX_GUESTS )  86
action -> guest [ action -> nr_guests ++ ] = v -> domain; 95
if ( action -> ack_type != ACKTYPE_NONE )  97
if ( newaction != NULL )  105
free_cpumask_var ( newaction -> cpu_eoi_map ); 107
xfree ( newaction ); 108
------------------------------
534 /home/speedy/test/source2slice/NVD/CVE_2014_1642_VULN_pirq_guest_bind.c xmalloc 36
int CVE_2014_1642_VULN_pirq_guest_bind(struct vcpu *v, struct pirq *pirq, int will_share) 1
struct irq_desc * desc ; 4
irq_guest_action_t * action , * newaction = NULL ; 5
desc = pirq_spin_lock_irq_desc ( pirq , NULL ); 12
if ( desc == NULL )  13
action = ( irq_guest_action_t * ) desc -> action; 19
if ( ! ( desc -> status & IRQ_GUEST ) )  22
if ( desc -> action != NULL )  24
if ( newaction == NULL )  33
if ( ( newaction = xmalloc ( irq_guest_action_t ) ) != NULL && zalloc_cpumask_var ( & newaction -> cpu_eoi_map ) )  36
xfree ( newaction ); 39
action = newaction; 47
desc -> action = ( struct irqaction * ) action; 48
action -> nr_guests = 0; 51
action -> in_flight = 0; 52
action -> shareable = will_share; 53
action -> ack_type = pirq_acktype ( v -> domain , pirq -> pirq ); 54
init_timer ( & action -> eoi_timer , irq_guest_eoi_timer_fn , desc , 0 ); 55
desc -> status |= IRQ_GUEST; 57
desc -> status &= ~IRQ_DISABLED; 58
desc -> handler -> startup ( desc ); 59
if ( ! opt_noirqbalance && ( desc -> handler -> set_affinity != NULL ) )  62
desc -> handler -> set_affinity ( desc , cpumask_of ( v -> processor ) ); 63
if ( ! will_share || ! action -> shareable )  65
if ( action -> nr_guests == 0 )  74
if ( action -> nr_guests == IRQ_MAX_GUESTS )  87
action -> guest [ action -> nr_guests ++ ] = v -> domain; 96
if ( action -> ack_type != ACKTYPE_NONE )  98
spin_unlock_irq ( & desc -> lock ); 104
if ( newaction != NULL )  106
free_cpumask_var ( newaction -> cpu_eoi_map ); 108
xfree ( newaction ); 109
------------------------------
535 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c alloca 66
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
------------------------------
536 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c alloca 61
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
------------------------------
537 /home/speedy/test/source2slice/NVD/CVE-2015-0811_VULN_read_tag_lutType.c assert 26
static struct lutType *read_tag_lutType(struct mem_source *src, struct tag_index index, uint32_t tag_id) 1
struct tag * tag = find_tag ( index , tag_id ) ; 3
uint32_t offset = tag -> offset ; 4
uint32_t type = read_u32 ( src , offset ) ; 5
if ( type == LUT8_TYPE )  17
if ( type == LUT16_TYPE )  21
assert ( 0 ); 26
------------------------------
538 /home/speedy/test/source2slice/NVD/CVE-2015-4511_VULN_ne_parse.c assert 34
ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset) 1
int r ; 3
int64_t * data_offset ; 4
uint64_t id , size , peeked_id ; 5
struct ebml_element_desc * element ; 6
if ( ! ctx -> ancestor )  8
if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )  12
r = ne_peek_element ( ctx , & id , & size ); 17
if ( r != 1 )  18
peeked_id = id; 20
element = ne_find_element ( id , ctx -> ancestor -> node ); 22
if ( element )  23
if ( element -> flags & DESC_FLAG_SUSPEND )  24
r = ne_read_element ( ctx , & id , & size ); 31
if ( r != 1 )  32
assert ( id == peeked_id ); 34
if ( element -> flags & DESC_FLAG_OFFSET )  36
data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset ); 37
* data_offset = ne_io_tell ( ctx -> io ); 38
if ( * data_offset < 0 )  39
if ( element -> type == TYPE_MASTER )  45
if ( element -> flags & DESC_FLAG_MULTI )  46
if ( ne_read_master ( ctx , element ) < 0 )  47
if ( ne_read_single_master ( ctx , element ) < 0 )  50
r = ne_read_simple ( ctx , element , size ); 55
if ( r < 0 )  56
if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )  59
if ( top_level && ctx -> ancestor -> node == top_level )  61
r = ne_read_element ( ctx , & id , & size ); 68
if ( r != 1 )  69
r = ne_io_read_skip ( ctx -> io , size ); 74
if ( r != 1 )  75
------------------------------
539 /home/speedy/test/source2slice/NVD/CVE-2015-4511_VULN_ne_parse.c assert 25
ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset) 1
int r ; 3
int64_t * data_offset ; 4
uint64_t id , size , peeked_id ; 5
struct ebml_element_desc * element ; 6
if ( ! ctx -> ancestor )  8
if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )  12
r = ne_peek_element ( ctx , & id , & size ); 17
if ( r != 1 )  18
element = ne_find_element ( id , ctx -> ancestor -> node ); 22
if ( element )  23
if ( element -> flags & DESC_FLAG_SUSPEND )  24
assert ( element -> type == TYPE_BINARY ); 25
r = ne_read_element ( ctx , & id , & size ); 31
if ( r != 1 )  32
if ( element -> flags & DESC_FLAG_OFFSET )  36
data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset ); 37
* data_offset = ne_io_tell ( ctx -> io ); 38
if ( * data_offset < 0 )  39
if ( element -> type == TYPE_MASTER )  45
if ( element -> flags & DESC_FLAG_MULTI )  46
if ( ne_read_master ( ctx , element ) < 0 )  47
if ( ne_read_single_master ( ctx , element ) < 0 )  50
r = ne_read_simple ( ctx , element , size ); 55
if ( r < 0 )  56
if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )  59
if ( top_level && ctx -> ancestor -> node == top_level )  61
r = ne_read_element ( ctx , & id , & size ); 68
if ( r != 1 )  69
r = ne_io_read_skip ( ctx -> io , size ); 74
if ( r != 1 )  75
------------------------------
540 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 347
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ); 347
------------------------------
541 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 346
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ); 346
------------------------------
542 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 345
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr ); 345
------------------------------
543 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 254
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ); 254
------------------------------
544 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 253
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ); 253
------------------------------
545 /home/speedy/test/source2slice/NVD/CVE_2013_7008_PATCHED_decode_slice_header.c assert 252
static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr ); 252
------------------------------
546 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 347
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ); 347
------------------------------
547 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 346
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ); 346
------------------------------
548 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 345
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int last_pic_structure , last_pic_droppable ; 7
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
last_pic_structure = h0 -> picture_structure; 193
last_pic_droppable = h0 -> droppable; 194
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
h -> picture_structure = PICT_FRAME; 197
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( get_bits1 ( & h -> gb ) )  203
h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); 204
h -> picture_structure = PICT_FRAME; 206
h -> mb_aff_frame = h -> sps . mb_aff; 207
h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; 210
if ( h0 -> current_slice != 0 )  212
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  230
int unwrap_prev_frame_num = h -> prev_frame_num ; 231
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 232
if ( unwrap_prev_frame_num > h -> frame_num )  234
unwrap_prev_frame_num -= max_frame_num; 235
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  237
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 238
if ( unwrap_prev_frame_num < 0 )  239
unwrap_prev_frame_num += max_frame_num; 240
h -> prev_frame_num = unwrap_prev_frame_num; 242
if ( h0 -> first_field )  251
if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  263
if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  271
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  282
if ( last_pic_droppable != h -> droppable )  292
h -> picture_structure = last_pic_structure; 295
h -> droppable = last_pic_droppable; 296
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  303
if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  308
for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) 309
h -> last_pocs [ i ] = INT_MIN; 310
if ( h264_frame_start ( h ) < 0 )  311
h -> prev_frame_num ++; 313
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 314
h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; 315
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  318
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  321
if ( h0 -> first_field )  344
assert ( h0 -> cur_pic_ptr ); 345
------------------------------
549 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 254
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ); 254
------------------------------
550 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 253
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ); 253
------------------------------
551 /home/speedy/test/source2slice/NVD/CVE_2013_7008_VULN_decode_slice_header.c assert 252
static int CVE_2013_7008_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
unsigned int first_mb_in_slice ; 3
unsigned int pps_id ; 4
int num_ref_idx_active_override_flag , ret ; 5
unsigned int slice_type , tmp , i , j ; 6
int must_reinit ; 8
int needs_reinit = 0 ; 9
h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; 11
h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; 12
first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); 14
if ( first_mb_in_slice == 0 )  16
h0 -> current_slice = 0; 21
if ( ! h0 -> first_field )  22
h -> cur_pic_ptr = NULL; 27
slice_type = get_ue_golomb_31 ( & h -> gb ); 31
if ( slice_type > 9 )  32
if ( slice_type > 4 )  38
slice_type -= 5; 39
h -> slice_type_fixed = 0; 42
slice_type = golomb_to_pict_type [ slice_type ]; 44
h -> slice_type = slice_type; 45
h -> slice_type_nos = slice_type & 3; 46
h -> pict_type = h -> slice_type; 49
pps_id = get_ue_golomb ( & h -> gb ); 51
if ( pps_id >= MAX_PPS_COUNT )  52
if ( ! h0 -> pps_buffers [ pps_id ] )  56
h -> pps = * h0 -> pps_buffers [ pps_id ]; 62
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  64
if ( h -> pps . sps_id != h -> current_sps_id ||
h0 -> sps_buffers [ h -> pps . sps_id ] -> new )
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 73
h -> current_sps_id = h -> pps . sps_id; 75
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 76
if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  78
needs_reinit = 1; 83
if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  85
h -> bit_depth_luma = h -> sps . bit_depth_luma; 87
h -> chroma_format_idc = h -> sps . chroma_format_idc; 88
needs_reinit = 1; 89
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  91
h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 95
h -> avctx -> level = h -> sps . level_idc; 96
h -> avctx -> refs = h -> sps . ref_frame_count; 97
must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); 99
if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  108
must_reinit = 1; 109
h -> mb_width = h -> sps . mb_width; 111
h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 112
h -> mb_num = h -> mb_width * h -> mb_height; 113
h -> mb_stride = h -> mb_width + 1; 114
h -> b_stride = h -> mb_width * 4; 116
h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 118
h -> width = 16 * h -> mb_width; 120
h -> height = 16 * h -> mb_height; 121
ret = init_dimensions ( h ); 123
if ( ret < 0 )  124
if ( h -> sps . video_signal_type_present_flag )  127
h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 128
if ( h -> sps . colour_description_present_flag )  130
if ( h -> avctx -> colorspace != h -> sps . colorspace )  131
needs_reinit = 1; 132
h -> avctx -> color_primaries = h -> sps . color_primaries; 133
h -> avctx -> color_trc = h -> sps . color_trc; 134
h -> avctx -> colorspace = h -> sps . colorspace; 135
if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  139
if ( h != h0 )  145
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  153
h -> avctx -> pix_fmt = ret; 155
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  160
if ( ! h -> context_initialized )  166
if ( h != h0 )  167
if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  173
h -> avctx -> pix_fmt = ret; 175
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  177
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  184
h -> dequant_coeff_pps = pps_id; 185
h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); 189
h -> mb_mbaff = 0; 191
h -> mb_aff_frame = 0; 192
h -> droppable = h -> nal_ref_idc == 0; 195
if ( h -> sps . frame_mbs_only_flag )  196
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  199
if ( h0 -> current_slice != 0 )  212
if ( h0 -> first_field )  251
assert ( h0 -> cur_pic_ptr ); 252
------------------------------
552 /home/speedy/test/source2slice/NVD/CVE_2007_1217_VULN_bufprint.c vsprintf 5
static void CVE_2007_1217_VULN_bufprint(char *fmt,...) 1
va_list f ; 3
vsprintf ( p , fmt , f ); 5
p += strlen ( p ); 7
------------------------------
553 /home/speedy/test/source2slice/NVD/CVE-2015-0811_VULN_read_tag_lutType.c malloc 44
static struct lutType *read_tag_lutType(struct mem_source *src, struct tag_index index, uint32_t tag_id) 1
struct tag * tag = find_tag ( index , tag_id ) ; 3
uint32_t offset = tag -> offset ; 4
uint32_t type = read_u32 ( src , offset ) ; 5
uint16_t num_input_table_entries ; 6
uint16_t num_output_table_entries ; 7
uint8_t in_chan , grid_points , out_chan ; 8
uint32_t clut_size ; 10
struct lutType * lut ; 12
if ( type == LUT8_TYPE )  17
num_input_table_entries = 256; 18
num_output_table_entries = 256; 19
if ( type == LUT16_TYPE )  21
num_input_table_entries = read_u16 ( src , offset + 48 ); 22
num_output_table_entries = read_u16 ( src , offset + 50 ); 23
in_chan = read_u8 ( src , offset + 8 ); 31
out_chan = read_u8 ( src , offset + 9 ); 32
grid_points = read_u8 ( src , offset + 10 ); 33
clut_size = pow ( grid_points , in_chan ); 35
if ( clut_size > MAX_CLUT_SIZE )  36
if ( in_chan != 3 || out_chan != 3 )  40
lut = malloc ( sizeof ( struct lutType ) + ( num_input_table_entries * in_chan + clut_size * out_chan + num_output_table_entries * out_chan ) * sizeof ( float ) ); 44
if ( ! lut )  45
lut -> input_table = & lut -> table_data [ 0 ]; 50
lut -> clut_table = & lut -> table_data [ in_chan * num_input_table_entries ]; 51
lut -> output_table = & lut -> table_data [ in_chan * num_input_table_entries + clut_size * out_chan ]; 52
lut -> num_input_table_entries = num_input_table_entries; 54
lut -> num_output_table_entries = num_output_table_entries; 55
lut -> num_input_channels = read_u8 ( src , offset + 8 ); 56
lut -> num_output_channels = read_u8 ( src , offset + 9 ); 57
lut -> num_clut_grid_points = read_u8 ( src , offset + 10 ); 58
lut -> e00 = read_s15Fixed16Number ( src , offset + 12 ); 59
lut -> e01 = read_s15Fixed16Number ( src , offset + 16 ); 60
lut -> e02 = read_s15Fixed16Number ( src , offset + 20 ); 61
lut -> e10 = read_s15Fixed16Number ( src , offset + 24 ); 62
lut -> e11 = read_s15Fixed16Number ( src , offset + 28 ); 63
lut -> e12 = read_s15Fixed16Number ( src , offset + 32 ); 64
lut -> e20 = read_s15Fixed16Number ( src , offset + 36 ); 65
lut -> e21 = read_s15Fixed16Number ( src , offset + 40 ); 66
lut -> e22 = read_s15Fixed16Number ( src , offset + 44 ); 67
for (i = 0; i < lut->num_input_table_entries * in_chan; i++) 69
lut -> input_table [ i ] = uInt8Number_to_float ( read_uInt8Number ( src , offset + 52 + i * entry_size ) ); 71
lut -> input_table [ i ] = uInt16Number_to_float ( read_uInt16Number ( src , offset + 52 + i * entry_size ) ); 73
clut_offset = offset + 52 + lut -> num_input_table_entries * in_chan * entry_size; 77
for (i = 0; i < clut_size * out_chan; i+=3) 78
lut -> clut_table [ i + 0 ] = uInt8Number_to_float ( read_uInt8Number ( src , clut_offset + i * entry_size + 0 ) ); 80
lut -> clut_table [ i + 1 ] = uInt8Number_to_float ( read_uInt8Number ( src , clut_offset + i * entry_size + 1 ) ); 81
lut -> clut_table [ i + 2 ] = uInt8Number_to_float ( read_uInt8Number ( src , clut_offset + i * entry_size + 2 ) ); 82
lut -> clut_table [ i + 0 ] = uInt16Number_to_float ( read_uInt16Number ( src , clut_offset + i * entry_size + 0 ) ); 84
lut -> clut_table [ i + 1 ] = uInt16Number_to_float ( read_uInt16Number ( src , clut_offset + i * entry_size + 2 ) ); 85
lut -> clut_table [ i + 2 ] = uInt16Number_to_float ( read_uInt16Number ( src , clut_offset + i * entry_size + 4 ) ); 86
output_offset = clut_offset + clut_size * out_chan * entry_size; 90
for (i = 0; i < lut->num_output_table_entries * out_chan; i++) 91
lut -> output_table [ i ] = uInt8Number_to_float ( read_uInt8Number ( src , output_offset + i * entry_size ) ); 93
lut -> output_table [ i ] = uInt16Number_to_float ( read_uInt16Number ( src , output_offset + i * entry_size ) ); 95
return lut ; 99
------------------------------
554 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c malloc 162
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
PRUint32 toCopy ; 149
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
aCount -= toCopy; 156
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
if ( ! mDecoded )  161
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 162
if ( ! mDecoded )  163
PRUint8 * d = mDecoded ; 168
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
if ( mCurLine == 0 )  225
mRowBytes = 0; 228
while ( aCount > 0 )  231
------------------------------
555 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c malloc 158
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 64
mCurLine = real_height; 69
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 142
if ( rowSize % 4 )  143
rowSize += ( 4 - ( rowSize % 4 ) ); 144
PRUint32 toCopy ; 145
toCopy = rowSize - mRowBytes; 147
if ( toCopy )  148
if ( toCopy > aCount )  149
toCopy = aCount; 150
aCount -= toCopy; 152
mRowBytes += toCopy; 154
if ( ( rowSize - mRowBytes ) == 0 )  156
if ( ! mDecoded )  157
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 158
if ( ! mDecoded )  159
PRUint8 * d = mDecoded ; 164
SetPixel ( d , idx , mColors ); 173
Set4BitPixel ( d , * p , lpos , mColors ); 181
SetPixel ( d , * p , mColors ); 187
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 195
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 206
if ( mCurLine == 0 )  221
mRowBytes = 0; 224
while ( aCount > 0 )  227
------------------------------
556 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c malloc 108
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
557 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c malloc 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
558 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c malloc 580
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar * c = destpath ; 584
NS_tstrcpy ( c , gWorkingDirPath ); 585
c += NS_tstrlen ( gWorkingDirPath ); 586
NS_tstrcat ( c , NS_T ( "/" ) ); 589
c += NS_tstrlen ( NS_T ( "/" ) ); 590
* c = NS_T ( '\0' ); 592
c ++; 593
gDestPath = destpath; 595
------------------------------
559 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c malloc 580
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar * c = destpath ; 584
NS_tstrcpy ( c , gWorkingDirPath ); 585
c += NS_tstrlen ( gWorkingDirPath ); 586
NS_tstrcat ( c , NS_T ( "/" ) ); 589
c += NS_tstrlen ( NS_T ( "/" ) ); 590
* c = NS_T ( '\0' ); 592
c ++; 593
gDestPath = destpath; 595
------------------------------
560 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c calloc 252
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
mDecoding = mDecoded; 255
SetPixel ( mDecoding , byte , mColors ); 285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mDecoding = mDecoded; 305
mDecoding += byte * GFXBYTESPERPIXEL; 356
SetPixel ( mDecoding , byte , mColors ); 383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
------------------------------
561 /home/speedy/test/source2slice/NVD/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c calloc 245
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mAlphaPtr = mAlpha; 304
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
while ( aCount > 0 && mStateData > 0 )  380
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
------------------------------
562 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c calloc 248
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  229
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  230
if ( ! mAlpha )  236
PRUint32 alpha ; 237
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 241
if ( ! mAlpha )  242
if ( ! mDecoded )  247
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 248
if ( ! mDecoded )  249
mDecoding = mDecoded; 251
SetPixel ( mDecoding , byte , mColors ); 281
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 286
mDecoding = mDecoded; 301
mDecoding += byte * GFXBYTESPERPIXEL; 352
SetPixel ( mDecoding , byte , mColors ); 379
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 386
------------------------------
563 /home/speedy/test/source2slice/NVD/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c calloc 241
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ mNumColors ]; 49
if ( ! mColors )  50
if ( mBIH . width < 0 )  61
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 71
if ( ! mRow )  75
PRUint8 bpc ; 91
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 92
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  93
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  98
mPos ++; 114
aCount --; 114
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  118
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 121
if ( toCopy > aCount )  122
toCopy = aCount; 123
mPos += toCopy; 125
aCount -= toCopy; 127
while ( aCount && ( mPos < mBFH . dataoffset ) )  135
mPos ++; 136
aCount --; 136
if ( aCount && ++ mPos >= mBFH . dataoffset )  138
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  141
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  229
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  230
if ( ! mAlpha )  236
PRUint32 alpha ; 237
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 241
if ( ! mAlpha )  242
mAlphaPtr = mAlpha; 244
if ( mStateData != RLE_ESCAPE )  268
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  275
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 276
memset ( mAlphaPtr , 0xFF , mStateData ); 277
mAlphaPtr += mStateData; 278
while ( mStateData > 0 )  280
mStateData --; 282
while ( mStateData > 0 )  285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 286
mAlphaPtr = mAlpha; 300
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  318
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
memset ( mAlphaPtr , 0xFF , mStateData ); 325
mAlphaPtr += mStateData; 326
mAlphaPtr += byte; 349
if ( mAlphaPtr > mAlpha + mBIH . width )  350
mAlphaPtr = mAlpha + mBIH . width; 351
while ( aCount > 0 && mStateData > 0 )  376
mStateData --; 380
while ( aCount > 0 && mStateData > 0 )  383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 386
if ( mStateData == 0 )  390
------------------------------
564 /home/speedy/test/source2slice/NVD/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strstr 29
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
------------------------------
565 /home/speedy/test/source2slice/NVD/CVE_2013_6378_VULN_lbs_debugfs_write.c strstr 25
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
------------------------------
566 /home/speedy/test/source2slice/NVD/CVE-2016-3062_VULN_mov_read_dref.c memmove 82
static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom) 1
AVStream * st ; 3
MOVStreamContext * sc ; 4
int entries , i , j ; 5
if ( c -> fc -> nb_streams < 1 )  7
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ]; 9
sc = st -> priv_data; 10
entries = avio_rb32 ( pb ); 13
if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) )  14
sc -> drefs_count = 0; 17
sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ); 18
if ( ! sc -> drefs )  19
sc -> drefs_count = entries; 21
for (i = 0; i < sc->drefs_count; i++) 23
MOVDref * dref = & sc -> drefs [ i ] ; 24
uint32_t size = avio_rb32 ( pb ) ; 25
int64_t next = avio_tell ( pb ) + size - 4 ; 26
if ( size < 12 )  28
dref -> type = avio_rl32 ( pb ); 31
if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 )  35
uint16_t volume_len , len ; 37
int16_t type ; 38
volume_len = avio_r8 ( pb ); 42
volume_len = FFMIN ( volume_len , 27 ); 43
for (type = 0; type != -1 && avio_tell(pb) < next; ) 66
if ( url_feof ( pb ) )  67
type = avio_rb16 ( pb ); 69
len = avio_rb16 ( pb ); 70
if ( len & 1 )  72
len += 1; 73
if ( type == 2 )  74
dref -> path = av_mallocz ( len + 1 ); 76
if ( ! dref -> path )  77
if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) )  80
len -= volume_len; 81
memmove ( dref -> path , dref -> path + volume_len , len ); 82
dref -> path [ len ] = 0; 83
for (j = 0; j < len; j++) 85
if ( dref -> path [ j ] == ':' )  86
dref -> path [ j ] = '/'; 87
av_log ( c -> fc , AV_LOG_DEBUG , "path %s\n" , dref -> path ); 88
if ( type == 0 )  89
dref -> dir = av_malloc ( len + 1 ); 91
if ( ! dref -> dir )  92
if ( dref -> dir [ j ] == ':' )  97
------------------------------
567 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memmove 133
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
568 /home/speedy/test/source2slice/NVD/CVE_2008_5134_PATCHED_lbs_process_bss.c memmove 110
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
569 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memmove 133
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
570 /home/speedy/test/source2slice/NVD/CVE_2008_5134_VULN_lbs_process_bss.c memmove 110
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
571 /home/speedy/test/source2slice/NVD/CVE_2010_2537_PATCHED_btrfs_ioctl_clone.c memmove 257
static noinline long CVE_2010_2537_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
ret = - EISDIR; 54
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
ret = - EXDEV; 58
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off + len > src -> i_size || off + len < off )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
datal -= skip + trim; 248
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
if ( skip )  254
u32 start = btrfs_file_extent_calc_inline_size ( 0 ) ; 255
memmove ( buf + start , buf + start + skip , datal ); 257
write_extent_buffer ( leaf , buf , btrfs_item_ptr_offset ( leaf , slot ) , size ); 263
key . offset ++; 274
vfree ( buf ); 293
------------------------------
572 /home/speedy/test/source2slice/NVD/CVE_2010_2537_VULN_btrfs_ioctl_clone.c memmove 257
static noinline long CVE_2010_2537_VULN_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off >= src -> i_size || off + len > src -> i_size )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
datal -= skip + trim; 248
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
if ( skip )  254
u32 start = btrfs_file_extent_calc_inline_size ( 0 ) ; 255
memmove ( buf + start , buf + start + skip , datal ); 257
write_extent_buffer ( leaf , buf , btrfs_item_ptr_offset ( leaf , slot ) , size ); 263
key . offset ++; 274
vfree ( buf ); 293
------------------------------
573 /home/speedy/test/source2slice/NVD/CVE_2010_2538_PATCHED_btrfs_ioctl_clone.c memmove 257
static noinline long CVE_2010_2538_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off + len > src -> i_size || off + len < off )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
datal -= skip + trim; 248
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
if ( skip )  254
u32 start = btrfs_file_extent_calc_inline_size ( 0 ) ; 255
memmove ( buf + start , buf + start + skip , datal ); 257
write_extent_buffer ( leaf , buf , btrfs_item_ptr_offset ( leaf , slot ) , size ); 263
key . offset ++; 274
vfree ( buf ); 293
------------------------------
574 /home/speedy/test/source2slice/NVD/CVE_2010_2538_VULN_btrfs_ioctl_clone.c memmove 257
static noinline long CVE_2010_2538_VULN_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
u64 off, u64 olen, u64 destoff) 2
struct inode * inode = fdentry ( file ) -> d_inode ; 4
struct btrfs_root * root = BTRFS_I ( inode ) -> root ; 5
struct file * src_file ; 6
struct inode * src ; 7
struct btrfs_trans_handle * trans ; 8
struct btrfs_path * path ; 9
struct extent_buffer * leaf ; 10
char * buf ; 11
struct btrfs_key key ; 12
u32 nritems ; 13
int slot ; 14
int ret ; 15
u64 len = olen ; 16
u64 bs = root -> fs_info -> sb -> s_blocksize ; 17
if ( ! ( file -> f_mode & FMODE_WRITE ) )  31
ret = mnt_want_write ( file -> f_path . mnt ); 34
if ( ret )  35
src_file = fget ( srcfd ); 38
if ( ! src_file )  39
src = src_file -> f_dentry -> d_inode; 44
if ( src == inode )  47
if ( ! ( src_file -> f_mode & FMODE_READ ) )  51
ret = - EISDIR; 54
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )  55
ret = - EXDEV; 58
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )  59
ret = - ENOMEM; 62
buf = vmalloc ( btrfs_level_size ( root , 0 ) ); 63
if ( ! buf )  64
path = btrfs_alloc_path ( ); 67
if ( ! path )  68
path -> reada = 2; 72
ret = - EINVAL; 83
if ( off >= src -> i_size || off + len > src -> i_size )  84
if ( len == 0 )  86
olen = len = src -> i_size - off; 87
if ( off + len == src -> i_size )  89
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off; 90
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )  94
trans = btrfs_start_transaction ( root , 1 ); 112
key . objectid = src -> i_ino; 119
key . type = BTRFS_EXTENT_DATA_KEY; 120
key . offset = 0; 121
while ( 1 )  123
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 ); 128
if ( ret < 0 )  129
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] ); 132
if ( path -> slots [ 0 ] >= nritems )  133
ret = btrfs_next_leaf ( root , path ); 134
if ( ret < 0 )  135
if ( ret > 0 )  137
leaf = path -> nodes [ 0 ]; 141
slot = path -> slots [ 0 ]; 142
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )  145
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )  149
struct btrfs_file_extent_item * extent ; 150
int type ; 151
u32 size ; 152
struct btrfs_key new_key ; 153
u64 datao = 0 , datal = 0 ; 155
u8 comp ; 156
size = btrfs_item_size_nr ( leaf , slot ); 158
extent = btrfs_item_ptr ( leaf , slot ,
struct btrfs_file_extent_item ) 164
comp = btrfs_file_extent_compression ( leaf , extent ); 165
type = btrfs_file_extent_type ( leaf , extent ); 166
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  167
datal = btrfs_file_extent_num_bytes ( leaf , extent ); 174
if ( type == BTRFS_FILE_EXTENT_INLINE )  176
datal = btrfs_file_extent_ram_bytes ( leaf , extent ); 178
if ( key . offset + datal < off || key . offset >= off + len )  183
memcpy ( & new_key , & key , sizeof ( new_key ) ); 187
new_key . objectid = inode -> i_ino; 188
new_key . offset = key . offset + destoff - off; 189
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )  191
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 193
if ( ret )  195
if ( type == BTRFS_FILE_EXTENT_INLINE )  232
u64 skip = 0 ; 233
u64 trim = 0 ; 234
if ( off > key . offset )  235
skip = off - key . offset; 236
new_key . offset += skip; 237
if ( key . offset + datal > off + len )  240
trim = key . offset + datal - ( off + len ); 241
if ( comp && ( skip || trim ) )  243
size -= skip + trim; 247
datal -= skip + trim; 248
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size ); 249
if ( ret )  251
if ( skip )  254
u32 start = btrfs_file_extent_calc_inline_size ( 0 ) ; 255
memmove ( buf + start , buf + start + skip , datal ); 257
write_extent_buffer ( leaf , buf , btrfs_item_ptr_offset ( leaf , slot ) , size ); 263
key . offset ++; 274
vfree ( buf ); 293
------------------------------
575 /home/speedy/test/source2slice/NVD/CVE-2016-7913_VULN_xc2028_set_config.c strcmp 28
static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) 1
struct xc2028_data * priv = fe -> tuner_priv ; 3
struct xc2028_ctrl * p = priv_cfg ; 4
memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ); 17
if ( p -> fname )  18
priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ); 19
if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) )  28
------------------------------
576 /home/speedy/test/source2slice/NVD/CVE_2004_1151_VULN_sys32_ni_syscall.c strcmp 5
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
------------------------------
577 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strcmp 415
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
int loop = 1 ; 347
p = ( char __user * ) iocts . arg; 349
i = 0; 350
while ( loop )  351
int j = 0 ; 352
while ( 1 )  354
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  355
get_user ( bname [ j ] , p ++ ); 357
switch ( bname [ j ] )  358
loop = 0; 360
bname [ j ] = '\0'; 363
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 364
j = ISDN_MSNLEN; 365
j ++; 368
if ( j >= ISDN_MSNLEN )  370
if ( ++ i > 9 )  373
p = ( char __user * ) iocts . arg; 377
for (i = 0; i < 10; i++) 378
snprintf ( bname , sizeof ( bname ) , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 379
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  383
p += strlen ( bname ); 385
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  400
if ( arg )  404
int i ; 405
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  407
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 409
if ( strlen ( iocts . drvid ) )  410
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 414
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  415
------------------------------
578 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strcmp 338
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
------------------------------
579 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strcmp 255
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int i ; 9
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
if ( arg )  243
int i ; 244
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
------------------------------
580 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strcmp 412
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
int loop = 1 ; 345
p = ( char __user * ) iocts . arg; 347
i = 0; 348
while ( loop )  349
int j = 0 ; 350
while ( 1 )  352
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  353
get_user ( bname [ j ] , p ++ ); 355
switch ( bname [ j ] )  356
loop = 0; 358
bname [ j ] = '\0'; 361
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 362
j = ISDN_MSNLEN; 363
j ++; 366
if ( j >= ISDN_MSNLEN )  368
if ( ++ i > 9 )  371
p = ( char __user * ) iocts . arg; 375
for (i = 0; i < 10; i++) 376
sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); 377
if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  381
p += strlen ( bname ); 383
if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  398
if ( arg )  402
int i ; 403
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  405
if ( strlen ( iocts . drvid ) )  407
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 411
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  412
------------------------------
581 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strcmp 336
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
------------------------------
582 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strcmp 254
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int i ; 9
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
if ( arg )  243
int i ; 244
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
------------------------------
583 /home/speedy/test/source2slice/NVD/CVE_2010_1437_PATCHED_find_keyring_by_name.c strcmp 27
struct key *CVE_2010_1437_PATCHED_find_keyring_by_name(const char *name, bool skip_perm_check) 1
struct key * keyring ; 3
int bucket ; 4
keyring = ERR_PTR ( - EINVAL ); 6
if ( ! name )  7
bucket = keyring_hash ( name ); 10
if ( keyring_name_hash [ bucket ] . next )  14
if ( strcmp ( keyring -> description , name ) != 0 )  27
------------------------------
584 /home/speedy/test/source2slice/NVD/CVE_2010_1437_VULN_find_keyring_by_name.c strcmp 27
struct key *CVE_2010_1437_VULN_find_keyring_by_name(const char *name, bool skip_perm_check) 1
struct key * keyring ; 3
int bucket ; 4
keyring = ERR_PTR ( - EINVAL ); 6
if ( ! name )  7
bucket = keyring_hash ( name ); 10
if ( keyring_name_hash [ bucket ] . next )  14
if ( strcmp ( keyring -> description , name ) != 0 )  27
------------------------------
585 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strcmp 656
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tsa && tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( p -> udptl )  627
if ( isa && udptlportno > 0 )  628
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  650
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  654
if ( strcmp ( p -> owner -> exten , "fax" ) )  656
------------------------------
586 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strcmp 225
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
587 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strcmp 223
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
588 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strcmp 173
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
589 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c strcmp 171
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
590 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strcmp 656
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( p -> udptl )  627
if ( udptlportno > 0 )  628
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  650
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  654
if ( strcmp ( p -> owner -> exten , "fax" ) )  656
------------------------------
591 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strcmp 225
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
592 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strcmp 223
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
593 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strcmp 173
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
594 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c strcmp 171
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
595 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 50
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
if ( strcmp ( accf_name , "none" ) == 0 )  50
------------------------------
596 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 48
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
------------------------------
597 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 46
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
------------------------------
598 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c strcmp 50
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
if ( strcmp ( accf_name , "none" ) == 0 )  50
------------------------------
599 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c strcmp 48
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
------------------------------
600 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c strcmp 46
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
------------------------------
601 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 623
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  603
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  611
if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  623
------------------------------
602 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 619
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  603
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  611
if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , "none" ) )  619
------------------------------
603 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 611
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  603
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  611
------------------------------
604 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 603
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  603
------------------------------
605 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 603
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  603
------------------------------
606 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 582
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  582
------------------------------
607 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 582
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  582
------------------------------
608 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 582
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  582
------------------------------
609 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 582
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  582
------------------------------
610 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 564
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
------------------------------
611 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 564
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
------------------------------
612 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 564
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  564
------------------------------
613 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 549
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
------------------------------
614 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 549
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 496
job -> state_value = IPP_JOB_HELD; 497
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  501
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 503
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 504
job -> state_value = IPP_JOB_HELD; 505
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 509
job -> state_value = IPP_JOB_PENDING; 510
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  515
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  521
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 528
if ( Classification )  540
if ( ClassifyOverride )  547
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  549
------------------------------
615 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 488
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 449
attr -> value_tag = IPP_TAG_NOVALUE; 451
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 452
attr -> value_tag = IPP_TAG_NOVALUE; 454
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 461
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 463
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 464
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 466
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  471
attr -> values [ 0 ] . integer = 0; 472
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  476
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 478
if ( ! attr )  479
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  481
val = "no-hold"; 483
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 485
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  488
------------------------------
616 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 421
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL )  347
attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP; 348
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  411
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  414
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  421
------------------------------
617 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 197
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
------------------------------
618 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_add_job.c strcmp 67
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_PATCHED_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
------------------------------
619 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_authenticate_job.c strcmp 122
static void
CVE_2015_1158_PATCHED_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
ipp_attribute_t * attr , * auth_info ; 7
int jobid ; 9
cupsd_job_t * job ; 10
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
con -> response -> request . status . status_code = IPP_OK; 29
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  41
jobid = attr -> values [ 0 ] . integer; 49
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
if ( job -> state_value != IPP_JOB_HELD )  93
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 109
if ( ! con -> username [ 0 ] && ! auth_info )  111
cupsd_printer_t * printer ; 113
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
------------------------------
620 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_authenticate_job.c strcmp 35
static void
CVE_2015_1158_PATCHED_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
------------------------------
621 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_PATCHED_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
------------------------------
622 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_PATCHED_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
------------------------------
623 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_cupsdProcessIPPRequest.c strcmp 136
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_PATCHED_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
------------------------------
624 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_cupsdProcessIPPRequest.c strcmp 126
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_PATCHED_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
------------------------------
625 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_cupsdProcessIPPRequest.c strcmp 116
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_PATCHED_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
------------------------------
626 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c strcmp 152
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
------------------------------
627 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c strcmp 152
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
------------------------------
628 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c strcmp 127
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
------------------------------
629 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c strcmp 127
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
------------------------------
630 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c strcmp 51
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
------------------------------
631 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_release_job.c strcmp 24
static void
CVE_2015_1158_PATCHED_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  24
------------------------------
632 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 365
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  255
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
if ( add_file ( con , job , filetype , compression ) )  289
if ( stat ( con -> filename , & fileinfo ) )  292
kbytes = 0; 293
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 295
job -> koctets += kbytes; 299
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  301
attr -> values [ 0 ] . integer += kbytes; 302
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  319
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  361
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 363
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  365
------------------------------
633 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 343
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  255
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
if ( add_file ( con , job , filetype , compression ) )  289
if ( stat ( con -> filename , & fileinfo ) )  292
kbytes = 0; 293
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 295
job -> koctets += kbytes; 299
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  301
attr -> values [ 0 ] . integer += kbytes; 302
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  319
if ( cupsdTimeoutJob ( job ) )  327
if ( job -> state_value == IPP_JOB_STOPPED )  330
if ( job -> state_value == IPP_JOB_HELD )  337
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  339
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 341
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  343
------------------------------
634 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 212
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
------------------------------
635 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 212
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
------------------------------
636 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 137
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
------------------------------
637 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c strcmp 46
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
------------------------------
638 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 661
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  661
------------------------------
639 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 657
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , "none" ) )  657
------------------------------
640 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 649
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
------------------------------
641 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 641
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
------------------------------
642 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 641
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
------------------------------
643 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
------------------------------
644 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
------------------------------
645 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
------------------------------
646 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
------------------------------
647 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
------------------------------
648 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
------------------------------
649 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
------------------------------
650 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 587
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
------------------------------
651 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 587
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
------------------------------
652 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 526
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
------------------------------
653 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 422
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
------------------------------
654 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 197
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
------------------------------
655 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_add_job.c strcmp 67
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
------------------------------
656 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_authenticate_job.c strcmp 122
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
ipp_attribute_t * attr , * auth_info ; 7
int jobid ; 9
cupsd_job_t * job ; 10
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
con -> response -> request . status . status_code = IPP_OK; 29
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  41
jobid = attr -> values [ 0 ] . integer; 49
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
if ( job -> state_value != IPP_JOB_HELD )  93
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 109
if ( ! con -> username [ 0 ] && ! auth_info )  111
cupsd_printer_t * printer ; 113
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
------------------------------
657 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_authenticate_job.c strcmp 35
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
------------------------------
658 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
------------------------------
659 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
------------------------------
660 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 136
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
------------------------------
661 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 126
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
------------------------------
662 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 116
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
------------------------------
663 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c strcmp 152
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
------------------------------
664 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c strcmp 152
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
------------------------------
665 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c strcmp 127
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
------------------------------
666 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c strcmp 127
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
------------------------------
667 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c strcmp 51
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
------------------------------
668 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_release_job.c strcmp 24
static void
CVE_2015_1158_VULN_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  24
------------------------------
669 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 369
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  259
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
if ( add_file ( con , job , filetype , compression ) )  293
if ( stat ( con -> filename , & fileinfo ) )  296
kbytes = 0; 297
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 299
job -> koctets += kbytes; 303
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  305
attr -> values [ 0 ] . integer += kbytes; 306
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  323
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  365
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 367
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  369
------------------------------
670 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 347
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
mime_type_t * filetype ; 24
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
struct stat fileinfo ; 33
int kbytes ; 34
int compression ; 35
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
compression = CUPS_FILE_NONE; 118
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
compression = CUPS_FILE_GZIP; 138
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( job -> num_files > 0 && attr -> values [ 0 ] . boolean )  161
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
ipp_attribute_t * doc_name ; 218
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 223
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 224
if ( ! filetype )  228
filetype = mimeType ( MimeDatabase , super , type ); 229
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
if ( ! filetype )  259
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  273
if ( add_file ( con , job , filetype , compression ) )  293
if ( stat ( con -> filename , & fileinfo ) )  296
kbytes = 0; 297
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 299
job -> koctets += kbytes; 303
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  305
attr -> values [ 0 ] . integer += kbytes; 306
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) != NULL && attr -> values [ 0 ] . boolean )  323
if ( cupsdTimeoutJob ( job ) )  331
if ( job -> state_value == IPP_JOB_STOPPED )  334
if ( job -> state_value == IPP_JOB_HELD )  341
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  343
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 345
if ( ! attr || ! strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  347
------------------------------
671 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 212
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
------------------------------
672 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 212
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
------------------------------
673 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 137
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  137
------------------------------
674 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c strcmp 46
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
------------------------------
675 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c socket 158
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
apr_bucket_free ( buf ); 326
context -> overlapped . Pointer = NULL; 328
if ( context -> accept_socket != INVALID_SOCKET )  334
closesocket ( context -> accept_socket ); 335
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 402
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
CloseHandle ( events [ 2 ] ); 448
------------------------------
676 /home/speedy/test/source2slice/NVD/CVE_2014_3523_PATCHED_winnt_accept.c socket 152
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
apr_bucket_free ( buf ); 326
context -> overlapped . Pointer = NULL; 328
if ( context -> accept_socket != INVALID_SOCKET )  334
closesocket ( context -> accept_socket ); 335
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 402
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
CloseHandle ( events [ 2 ] ); 448
------------------------------
677 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c socket 158
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
context -> overlapped . Pointer = NULL; 325
if ( context -> accept_socket != INVALID_SOCKET )  330
closesocket ( context -> accept_socket ); 331
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 341
while ( rv == WAIT_IO_COMPLETION )  342
if ( rv != WAIT_OBJECT_0 + 2 )  345
context -> sa_server = ( void * ) context -> buff; 352
context -> sa_server_len = sizeof ( context -> buff ) / 2; 353
context -> sa_client_len = context -> sa_server_len; 354
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 355
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 358
if ( context -> accept_socket == INVALID_SOCKET )  361
rv = apr_get_netos_error ( ); 363
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  364
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  378
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  383
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 398
context -> overlapped . Pointer = NULL; 399
err_count = 0; 400
context -> sa_server_len = sizeof ( context -> buff ) / 2; 402
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  403
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  409
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 413
sockinfo . os_sock = & context -> accept_socket; 417
sockinfo . local = context -> sa_server; 418
sockinfo . remote = context -> sa_client; 419
sockinfo . family = context -> sa_server -> sa_family; 420
sockinfo . type = SOCK_STREAM; 421
sockinfo . protocol = IPPROTO_TCP; 422
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 428
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 429
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 431
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 433
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 438
context = NULL; 441
CloseHandle ( events [ 2 ] ); 444
------------------------------
678 /home/speedy/test/source2slice/NVD/CVE_2014_3523_VULN_winnt_accept.c socket 152
static unsigned int __stdcall CVE_2014_3523_VULN_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
context -> overlapped . Pointer = NULL; 325
if ( context -> accept_socket != INVALID_SOCKET )  330
closesocket ( context -> accept_socket ); 331
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 341
while ( rv == WAIT_IO_COMPLETION )  342
if ( rv != WAIT_OBJECT_0 + 2 )  345
context -> sa_server = ( void * ) context -> buff; 352
context -> sa_server_len = sizeof ( context -> buff ) / 2; 353
context -> sa_client_len = context -> sa_server_len; 354
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 355
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 358
if ( context -> accept_socket == INVALID_SOCKET )  361
rv = apr_get_netos_error ( ); 363
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  364
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  378
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  383
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 398
context -> overlapped . Pointer = NULL; 399
err_count = 0; 400
context -> sa_server_len = sizeof ( context -> buff ) / 2; 402
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  403
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  409
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 413
sockinfo . os_sock = & context -> accept_socket; 417
sockinfo . local = context -> sa_server; 418
sockinfo . remote = context -> sa_client; 419
sockinfo . family = context -> sa_server -> sa_family; 420
sockinfo . type = SOCK_STREAM; 421
sockinfo . protocol = IPPROTO_TCP; 422
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 428
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 429
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 431
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 433
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 438
context = NULL; 441
CloseHandle ( events [ 2 ] ); 444
------------------------------
679 /home/speedy/test/source2slice/NVD/CVE_2004_1151_VULN_sys32_ni_syscall.c strcpy 8
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
strcpy ( lastcomm , me -> comm ); 8
------------------------------
680 /home/speedy/test/source2slice/NVD/CVE_2007_6151_PATCHED_isdn_ioctl.c strcpy 364
static int
CVE_2007_6151_PATCHED_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 249
if ( strlen ( iocts . drvid ) )  250
if ( p = strchr ( iocts . drvid , ',' ) )  251
* p = 0; 252
drvidx = - 1; 253
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 254
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  255
drvidx = i; 256
if ( drvidx == - 1 )  261
if ( iocts . arg )  263
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 266
dev -> profd = current; 269
if ( arg )  274
char __user * p = argp ; 275
int i ; 276
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  278
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 283
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  284
p += ISDN_MODEM_NUMREG; 287
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  288
p += ISDN_MSNLEN; 290
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  291
p += ISDN_LMSNLEN; 293
if ( arg )  301
char __user * p = argp ; 302
int i ; 303
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  305
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 310
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  311
p += ISDN_MODEM_NUMREG; 314
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  315
p += ISDN_LMSNLEN; 317
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  318
p += ISDN_MSNLEN; 320
if ( arg )  329
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  331
iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0; 334
if ( strlen ( iocts . drvid ) )  335
drvidx = - 1; 336
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 337
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  338
drvidx = i; 339
drvidx = 0; 343
if ( drvidx == - 1 )  344
if ( cmd == IIOCSETMAP )  346
int loop = 1 ; 347
p = ( char __user * ) iocts . arg; 349
i = 0; 350
while ( loop )  351
int j = 0 ; 352
while ( 1 )  354
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  355
get_user ( bname [ j ] , p ++ ); 357
switch ( bname [ j ] )  358
loop = 0; 360
bname [ j ] = '\0'; 363
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 364
j = ISDN_MSNLEN; 365
j ++; 368
if ( j >= ISDN_MSNLEN )  370
if ( ++ i > 9 )  373
if ( copy_to_user ( argp , & dev , sizeof ( ulong ) ) )  393
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  415
------------------------------
681 /home/speedy/test/source2slice/NVD/CVE_2007_6151_VULN_isdn_ioctl.c strcpy 362
static int
CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) 2
uint minor = iminor ( inode ) ; 4
int drvidx ; 6
int i ; 9
char __user * p ; 10
void __user * argp = ( void __user * ) arg ; 19
if ( minor == ISDN_MINOR_STATUS )  27
switch ( cmd )  28
if ( arg )  34
int i ; 36
if ( ! dev -> drivers )  63
if ( minor <= ISDN_MINOR_BMAX )  65
if ( minor <= ISDN_MINOR_CTRLMAX )  74
switch ( cmd )  82
if ( arg )  234
dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; 237
drvidx = - 1; 242
if ( arg )  243
int i ; 244
char * p ; 245
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  246
if ( strlen ( iocts . drvid ) )  249
if ( p = strchr ( iocts . drvid , ',' ) )  250
* p = 0; 251
drvidx = - 1; 252
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 253
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  254
drvidx = i; 255
if ( drvidx == - 1 )  260
if ( iocts . arg )  262
dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; 265
dev -> profd = current; 268
if ( arg )  273
char __user * p = argp ; 274
int i ; 275
if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  277
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 282
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  283
p += ISDN_MODEM_NUMREG; 286
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  287
p += ISDN_MSNLEN; 289
if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  290
p += ISDN_LMSNLEN; 292
if ( arg )  300
char __user * p = argp ; 301
int i ; 302
if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  304
for (i = 0; i < ISDN_MAX_CHANNELS; i++) 309
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  310
p += ISDN_MODEM_NUMREG; 313
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  314
p += ISDN_LMSNLEN; 316
if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  317
p += ISDN_MSNLEN; 319
if ( arg )  328
if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  330
if ( strlen ( iocts . drvid ) )  333
drvidx = - 1; 334
for (i = 0; i < ISDN_MAX_DRIVERS; i++) 335
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  336
drvidx = i; 337
drvidx = 0; 341
if ( drvidx == - 1 )  342
if ( cmd == IIOCSETMAP )  344
int loop = 1 ; 345
p = ( char __user * ) iocts . arg; 347
i = 0; 348
while ( loop )  349
int j = 0 ; 350
while ( 1 )  352
if ( ! access_ok ( VERIFY_READ , p , 1 ) )  353
get_user ( bname [ j ] , p ++ ); 355
switch ( bname [ j ] )  356
loop = 0; 358
bname [ j ] = '\0'; 361
strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); 362
j = ISDN_MSNLEN; 363
j ++; 366
if ( j >= ISDN_MSNLEN )  368
if ( ++ i > 9 )  371
if ( copy_to_user ( argp , & dev , sizeof ( ulong ) ) )  391
if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  412
------------------------------
682 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strcpy 111
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
683 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c strcpy 110
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
while ( ( s -> managerid = rand ( ) ^ ( unsigned long ) s ) == 0 )  38
s -> eventq = master_eventq; 42
while ( s -> eventq -> next )  43
s -> eventq = s -> eventq -> next; 44
if ( ! s -> authenticated && ( httptimeout > 5 ) )  52
s -> sessiontimeout += 5; 53
s -> sessiontimeout += httptimeout; 55
if ( s )  58
struct message m = { 0 } ; 59
char tmp [ 80 ] ; 60
unsigned int x ; 61
size_t hdrlen ; 62
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 64
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 65
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 66
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 67
m . hdrcount = x + 1; 68
if ( process_message ( s , & m ) )  71
s -> needdestroy = 1; 85
sprintf ( tmp , "%08lx" , s -> managerid ); 88
if ( s -> outputstr )  99
char * tmp ; 100
if ( format == FORMAT_XML )  101
tmp = xml_translate ( s -> outputstr -> str , params ); 102
if ( format == FORMAT_HTML )  103
tmp = html_translate ( s -> outputstr -> str ); 104
tmp = s -> outputstr -> str; 106
if ( tmp )  107
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 108
if ( retval )  109
strcpy ( retval , workspace ); 110
strcpy ( retval + strlen ( retval ) , tmp ); 111
c = retval + strlen ( retval ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 125
ast_build_string ( & c , & len , "</table></body>\r\n" ); 127
return retval ; 152
------------------------------
684 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strcpy 106
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
685 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c strcpy 105
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
686 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strcpy 90
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
687 /home/speedy/test/source2slice/NVD/CVE_2009_1439_PATCHED_CIFSTCon.c strcpy 87
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
688 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strcpy 90
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
689 /home/speedy/test/source2slice/NVD/CVE_2009_1439_VULN_CIFSTCon.c strcpy 87
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
------------------------------
690 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c fopen 182
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
691 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c fopen 182
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
692 /home/speedy/test/source2slice/NVD/CVE_2009_2484_PATCHED_Win32AddConnection.c LoadLibrary 12
static void CVE_2009_2484_PATCHED_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
FreeLibrary ( hdll ); 60
------------------------------
693 /home/speedy/test/source2slice/NVD/CVE_2009_2484_VULN_Win32AddConnection.c LoadLibrary 12
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
FreeLibrary ( hdll ); 60
------------------------------
694 /home/speedy/test/source2slice/NVD/CVE_2008_1390_PATCHED_generic_http_callback.c sscanf 15
static char *CVE_2008_1390_PATCHED_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
sscanf ( v -> value , "%lx" , & ident ); 15
------------------------------
695 /home/speedy/test/source2slice/NVD/CVE_2008_1390_VULN_generic_http_callback.c sscanf 15
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
sscanf ( v -> value , "%lx" , & ident ); 15
------------------------------
696 /home/speedy/test/source2slice/NVD/CVE_2010_1224_PATCHED_ast_append_ha.c sscanf 30
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
int x ; 7
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
------------------------------
697 /home/speedy/test/source2slice/NVD/CVE_2010_1224_VULN_ast_append_ha.c sscanf 30
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
int x ; 7
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
------------------------------
698 /home/speedy/test/source2slice/NVD/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c sscanf 122
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
char keepchar ; 10
int len , backasswards ; 14
int interim_response = 0 ; 15
apr_table_t * save_table ; 18
if ( len <= 0 )  47
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  119
int major , minor ; 120
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  122
keepchar = buffer [ 12 ]; 136
buffer [ 12 ] = '\0'; 137
r -> status = atoi ( & buffer [ 9 ] ); 138
if ( keepchar != '\0' )  140
buffer [ 12 ] = keepchar; 141
buffer [ 12 ] = ' '; 146
buffer [ 13 ] = '\0'; 147
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 149
save_table = apr_table_make ( r -> pool , 2 ); 157
if ( r -> headers_out == NULL )  165
if ( ! apr_is_empty_table ( save_table ) )  187
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 189
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 235
r -> status = 200; 272
r -> status_line = "200 OK"; 273
if ( ap_is_HTTP_INFO ( r -> status ) )  277
interim_response ++; 278
interim_response = 0; 281
while ( interim_response && ( interim_response < AP_MAX_INTERIM_RESPONSES ) )  483
------------------------------
699 /home/speedy/test/source2slice/NVD/CVE_2010_2068_VULN_ap_proxy_http_process_response.c sscanf 120
static
apr_status_t CVE_2010_2068_VULN_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
char keepchar ; 10
int len , backasswards ; 14
int interim_response = 0 ; 15
apr_table_t * save_table ; 18
if ( len <= 0 )  47
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  117
int major , minor ; 118
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  120
keepchar = buffer [ 12 ]; 134
buffer [ 12 ] = '\0'; 135
r -> status = atoi ( & buffer [ 9 ] ); 136
if ( keepchar != '\0' )  138
buffer [ 12 ] = keepchar; 139
buffer [ 12 ] = ' '; 144
buffer [ 13 ] = '\0'; 145
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 147
save_table = apr_table_make ( r -> pool , 2 ); 155
if ( r -> headers_out == NULL )  163
if ( ! apr_is_empty_table ( save_table ) )  185
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 187
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 233
r -> status = 200; 270
r -> status_line = "200 OK"; 271
if ( ap_is_HTTP_INFO ( r -> status ) )  275
interim_response ++; 276
interim_response = 0; 279
while ( interim_response && ( interim_response < AP_MAX_INTERIM_RESPONSES ) )  481
------------------------------
700 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c sscanf 68
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
ast_log ( LOG_WARNING , "Invalid SIP response code: '%d'\n" , respid ); 73
if ( ( respid == 200 ) || ( ( respid >= 300 ) && ( respid <= 399 ) ) )  87
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
handle_response ( p , respid , e + len , req , seqno ); 111
------------------------------
701 /home/speedy/test/source2slice/NVD/CVE_2013_5641_PATCHED_handle_incoming.c sscanf 37
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
------------------------------
702 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c sscanf 68
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
------------------------------
703 /home/speedy/test/source2slice/NVD/CVE_2013_5641_VULN_handle_incoming.c sscanf 37
static int CVE_2013_5641_VULN_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
------------------------------
704 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 308
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
705 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 308
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
706 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 290
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
ast_verbose ( "Found RTP text format %d\n" , codec ); 296
ast_rtp_codecs_payloads_set_m_type ( & newtextrtp , NULL , codec ); 298
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
707 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 263
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
708 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 263
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
709 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 245
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
ast_verbose ( "Found RTP video format %d\n" , codec ); 251
ast_rtp_codecs_payloads_set_m_type ( & newvideortp , NULL , codec ); 253
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
710 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 211
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
711 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 211
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
712 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 192
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
ast_verbose ( "Found RTP audio format %d\n" , codec ); 198
ast_rtp_codecs_payloads_set_m_type ( & newaudiortp , NULL , codec ); 201
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
713 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 159
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
714 /home/speedy/test/source2slice/NVD/CVE_2013_5642_PATCHED_process_sdp.c sscanf 159
static int CVE_2013_5642_PATCHED_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
715 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 308
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
716 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 308
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
717 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 290
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
ast_verbose ( "Found RTP text format %d\n" , codec ); 296
ast_rtp_codecs_payloads_set_m_type ( & newtextrtp , NULL , codec ); 298
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
718 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 263
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
719 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 263
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
720 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 245
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
ast_verbose ( "Found RTP video format %d\n" , codec ); 251
ast_rtp_codecs_payloads_set_m_type ( & newvideortp , NULL , codec ); 253
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
721 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 211
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
722 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 211
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
723 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 192
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
ast_verbose ( "Found RTP audio format %d\n" , codec ); 198
ast_rtp_codecs_payloads_set_m_type ( & newaudiortp , NULL , codec ); 201
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
724 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 159
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
725 /home/speedy/test/source2slice/NVD/CVE_2013_5642_VULN_process_sdp.c sscanf 159
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
726 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_ast_http_manid_from_vars.c sscanf 9
uint32_t CVE_2014_2286_PATCHED_ast_http_manid_from_vars(struct ast_variable *headers) 1
struct ast_variable * v , * cookies ; 4
cookies = ast_http_get_cookies ( headers ); 6
for (v = cookies; v; v = v->next) 7
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  8
sscanf ( v -> value , "%30x" , & mngid ); 9
------------------------------
727 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_ast_http_manid_from_vars.c sscanf 9
uint32_t CVE_2014_2286_VULN_ast_http_manid_from_vars(struct ast_variable *headers) 1
struct ast_variable * v , * cookies ; 4
cookies = ast_http_get_cookies ( headers ); 6
for (v = cookies; v; v = v->next) 7
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  8
sscanf ( v -> value , "%30x" , & mngid ); 9
------------------------------
728 /home/speedy/test/source2slice/NVD/CVE_2015_0253_PATCHED_read_request_line.c sscanf 103
static int CVE_2015_0253_PATCHED_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
const char * ll ; 3
const char * pro ; 5
unsigned int major = 1 , minor = 0 ; 7
char http [ 5 ] ; 8
apr_size_t len ; 9
int num_blank_lines = 0 ; 10
int max_blank_lines = r -> server -> limit_req_fields ; 11
if ( max_blank_lines <= 0 )  13
max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS; 14
apr_status_t rv ; 33
r -> the_request = NULL; 38
rv = ap_rgetline ( & ( r -> the_request ) , ( apr_size_t ) ( r -> server -> limit_req_line + 2 ) , & len , r , 0 , bb ); 39
if ( rv != APR_SUCCESS )  42
while ( ( len <= 0 ) && ( ++ num_blank_lines < max_blank_lines ) )  62
r -> request_time = apr_time_now ( ); 70
ll = r -> the_request; 71
r -> method = ap_getword_white ( r -> pool , & ll ); 72
r -> method_number = ap_method_number_of ( r -> method ); 78
if ( r -> method_number == M_GET && r -> method [ 0 ] == 'H' )  79
r -> header_only = 1; 80
if ( ll [ 0 ] )  85
r -> assbackwards = 0; 86
pro = ll; 87
len = strlen ( ll ); 88
r -> assbackwards = 1; 90
pro = "HTTP/0.9"; 91
len = 8; 92
r -> protocol = apr_pstrmemdup ( r -> pool , pro , len ); 94
if ( len == 8 && pro [ 0 ] == 'H' && pro [ 1 ] == 'T' && pro [ 2 ] == 'T' && pro [ 3 ] == 'P' && pro [ 4 ] == '/' && apr_isdigit ( pro [ 5 ] ) && pro [ 6 ] == '.' && apr_isdigit ( pro [ 7 ] ) )  97
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
------------------------------
729 /home/speedy/test/source2slice/NVD/CVE_2015_0253_VULN_read_request_line.c sscanf 103
static int CVE_2015_0253_VULN_read_request_line(request_rec *r, apr_bucket_brigade *bb) 1
const char * ll ; 3
const char * pro ; 5
unsigned int major = 1 , minor = 0 ; 7
char http [ 5 ] ; 8
apr_size_t len ; 9
int num_blank_lines = 0 ; 10
int max_blank_lines = r -> server -> limit_req_fields ; 11
if ( max_blank_lines <= 0 )  13
max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS; 14
apr_status_t rv ; 33
r -> the_request = NULL; 38
rv = ap_rgetline ( & ( r -> the_request ) , ( apr_size_t ) ( r -> server -> limit_req_line + 2 ) , & len , r , 0 , bb ); 39
if ( rv != APR_SUCCESS )  42
while ( ( len <= 0 ) && ( ++ num_blank_lines < max_blank_lines ) )  62
r -> request_time = apr_time_now ( ); 70
ll = r -> the_request; 71
r -> method = ap_getword_white ( r -> pool , & ll ); 72
r -> method_number = ap_method_number_of ( r -> method ); 78
if ( r -> method_number == M_GET && r -> method [ 0 ] == 'H' )  79
r -> header_only = 1; 80
if ( ll [ 0 ] )  85
r -> assbackwards = 0; 86
pro = ll; 87
len = strlen ( ll ); 88
r -> assbackwards = 1; 90
pro = "HTTP/0.9"; 91
len = 8; 92
r -> protocol = apr_pstrmemdup ( r -> pool , pro , len ); 94
if ( len == 8 && pro [ 0 ] == 'H' && pro [ 1 ] == 'T' && pro [ 2 ] == 'T' && pro [ 3 ] == 'P' && pro [ 4 ] == '/' && apr_isdigit ( pro [ 5 ] ) && pro [ 6 ] == '.' && apr_isdigit ( pro [ 7 ] ) )  97
if ( 3 == sscanf ( r -> protocol , "%4s/%u.%u" , http , & major , & minor ) && ( strcasecmp ( "http" , http ) == 0 ) && ( minor < HTTP_VERSION ( 1 , 0 ) ) )  103
------------------------------
730 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c sscanf 171
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
731 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c sscanf 171
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
732 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c sscanf 109
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
------------------------------
733 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_print_job.c sscanf 92
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
------------------------------
734 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c sscanf 195
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  212
filetype = mimeType ( MimeDatabase , super , type ); 229
if ( filetype )  231
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "Request file type is %s/%s." , filetype -> super , filetype -> type ); 232
filetype = mimeType ( MimeDatabase , super , type ); 236
if ( filetype )  238
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 245
ippSetString ( job -> attrs , & jformat , 0 , mimetype ); 250
ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 252
if ( ! filetype )  255
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s/%s\"." ) , super , type ); 257
if ( printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  269
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 271
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported document-format \"%s\"." ) , mimetype ); 274
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 277
if ( add_file ( con , job , filetype , compression ) )  289
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 310
------------------------------
735 /home/speedy/test/source2slice/NVD/CVE_2015_1158_PATCHED_send_document.c sscanf 179
static void
CVE_2015_1158_PATCHED_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
------------------------------
736 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c sscanf 109
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
------------------------------
737 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_print_job.c sscanf 92
static void
CVE_2015_1158_VULN_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
------------------------------
738 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c sscanf 195
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 10
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
cupsd_printer_t * printer ; 32
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
printer = cupsdFindDest ( job -> dest ); 100
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  187
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  195
------------------------------
739 /home/speedy/test/source2slice/NVD/CVE_2015_1158_VULN_send_document.c sscanf 179
static void
CVE_2015_1158_VULN_send_document(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
int jobid ; 11
cupsd_job_t * job ; 12
char job_uri [ HTTP_MAX_URI ] , scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 13
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 25
if ( ! strcmp ( uri -> name , "printer-uri" ) )  46
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  52
jobid = attr -> values [ 0 ] . integer; 60
if ( strncmp ( resource , "/jobs/" , 6 ) )  72
jobid = atoi ( resource + 6 ); 83
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  90
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  106
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  120
if ( ( attr = ippFindAttribute ( con -> request , "last-document" , IPP_TAG_BOOLEAN ) ) == NULL )  146
if ( ! con -> filename )  154
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  172
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  179
------------------------------
740 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_httpd_helper_thread.c fgets 52
static void *CVE_2014_2286_PATCHED_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
char header_line [ 4096 ] ; 4
struct ast_tcptls_session_instance * ser = data ; 5
struct ast_variable * headers = NULL ; 6
struct ast_variable * tail = headers ; 7
char * uri , * method ; 8
int remaining_headers ; 10
if ( ast_atomic_fetchadd_int ( & session_count , + 1 ) >= session_limit )  12
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  16
method = ast_skip_blanks ( buf ); 21
uri = ast_skip_nonblanks ( method ); 22
if ( * uri )  23
* uri ++ = '\0'; 24
uri = ast_skip_blanks ( uri ); 37
if ( * uri )  39
remaining_headers = MAX_HTTP_REQUEST_HEADERS; 51
while ( fgets ( header_line , sizeof ( header_line ) , ser -> f ) )  52
char * name , * value ; 53
ast_trim_blanks ( header_line ); 56
if ( ast_strlen_zero ( header_line ) )  57
value = header_line; 61
name = strsep ( & value , ":" ); 62
if ( ! value )  63
value = ast_skip_blanks ( value ); 67
if ( ast_strlen_zero ( value ) || ast_strlen_zero ( name ) )  68
ast_trim_blanks ( name ); 72
if ( ! remaining_headers -- )  74
if ( ! headers )  79
headers = ast_variable_new ( name , value , __FILE__ ); 80
tail = headers; 81
tail -> next = ast_variable_new ( name , value , __FILE__ ); 83
tail = tail -> next; 84
if ( ! tail )  86
ast_variables_destroy ( headers ); 91
handle_uri ( ser , uri , http_method , headers ); 99
ast_variables_destroy ( headers ); 105
------------------------------
741 /home/speedy/test/source2slice/NVD/CVE_2014_2286_PATCHED_httpd_helper_thread.c fgets 16
static void *CVE_2014_2286_PATCHED_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
struct ast_tcptls_session_instance * ser = data ; 5
if ( ast_atomic_fetchadd_int ( & session_count , + 1 ) >= session_limit )  12
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  16
------------------------------
742 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_httpd_helper_thread.c fgets 47
static void *CVE_2014_2286_VULN_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
char header_line [ 4096 ] ; 4
struct ast_tcptls_session_instance * ser = data ; 5
if ( ast_atomic_fetchadd_int ( & session_count , + 1 ) >= session_limit )  11
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  15
while ( fgets ( header_line , sizeof ( header_line ) , ser -> f ) )  47
ast_trim_blanks ( header_line ); 51
if ( ast_strlen_zero ( header_line ) )  52
value = header_line; 56
name = strsep ( & value , ":" ); 57
if ( ! value )  58
value = ast_skip_blanks ( value ); 62
if ( ast_strlen_zero ( value ) || ast_strlen_zero ( name ) )  63
ast_trim_blanks ( name ); 67
if ( ! headers )  69
headers = ast_variable_new ( name , value , __FILE__ ); 70
tail = headers; 71
tail -> next = ast_variable_new ( name , value , __FILE__ ); 73
tail = tail -> next; 74
handle_uri ( ser , uri , http_method , headers ); 83
if ( headers )  89
ast_variables_destroy ( headers ); 90
------------------------------
743 /home/speedy/test/source2slice/NVD/CVE_2014_2286_VULN_httpd_helper_thread.c fgets 15
static void *CVE_2014_2286_VULN_httpd_helper_thread(void *data) 1
char buf [ 4096 ] ; 3
struct ast_tcptls_session_instance * ser = data ; 5
if ( ast_atomic_fetchadd_int ( & session_count , + 1 ) >= session_limit )  11
if ( ! fgets ( buf , sizeof ( buf ) , ser -> f ) )  15
------------------------------
744 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 877
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( argc > callbackIndex )  851
if ( getenv ( "MOZ_PROCESS_UPDATES" ) == nullptr )  877
------------------------------
745 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 234
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 499
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 606
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 658
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 739
if ( ! sUsingService )  861
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 878
------------------------------
746 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 165
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
LOG ( ( "MOZ_UPDATER_PRIO=%s" , prioEnv ) ); 173
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
747 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 123
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( getenv ( "MOZ_OS_UPDATE" ) )  123
------------------------------
748 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 57
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
------------------------------
749 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_NS_main.c getenv 4
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
------------------------------
750 /home/speedy/test/source2slice/NVD/CVE_2015_0833_PATCHED_UpdateThreadFunc.c getenv 89
static void
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
rv = ProcessReplaceRequest ( ); 7
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 42
if ( rv == OK )  55
if ( rv == OK )  56
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 57
MARChannelStringTable MARStrings ; 61
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  62
MARStrings . MARChannelID [ 0 ] = '\0'; 65
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 68
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  74
rv = CopyInstallDirToDestDir ( ); 75
if ( rv == OK )  78
rv = DoUpdate ( ); 79
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  89
------------------------------
751 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 877
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( argc > callbackIndex )  851
if ( getenv ( "MOZ_PROCESS_UPDATES" ) == nullptr )  877
------------------------------
752 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 234
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 499
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 606
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 658
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 739
if ( ! sUsingService )  861
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 878
------------------------------
753 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 165
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
LOG ( ( "MOZ_UPDATER_PRIO=%s" , prioEnv ) ); 173
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
------------------------------
754 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 123
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( getenv ( "MOZ_OS_UPDATE" ) )  123
------------------------------
755 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 57
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
------------------------------
756 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_NS_main.c getenv 4
int CVE_2015_0833_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
------------------------------
757 /home/speedy/test/source2slice/NVD/CVE_2015_0833_VULN_UpdateThreadFunc.c getenv 54
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
rv = ProcessReplaceRequest ( ); 7
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
MARChannelStringTable MARStrings ; 26
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
MARStrings . MARChannelID [ 0 ] = '\0'; 30
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 33
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
rv = CopyInstallDirToDestDir ( ); 40
if ( rv == OK )  43
rv = DoUpdate ( ); 44
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  54
------------------------------
